"Scala_Spark
单选题 （共计 10 题，总计 20分）
1、下面选项中a的取值不一致的是？（ ）。
","[{'optionContent': 'A.val a = 3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.val a:Double = 1 + 2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.var a = 1; a += 2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.val b = 1.+(2); val a = b.toInt \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"2、哪一个是Action执行方法？（ ）。
","[{'optionContent': 'A.Reduce \n', 'isCorrect': '-1'}, {'optionContent': 'B.Join \n', 'isCorrect': '-1'}, {'optionContent': 'C.Map \n', 'isCorrect': '-1'}, {'optionContent': 'D.Union \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"3、指出在Scala中何种情况下赋值语句x=y=1是合法的？（ ）。
","[{'optionContent': 'A.var x={} \n', 'isCorrect': '-1'}, {'optionContent': 'B.var x=1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.var x=""test"" \n', 'isCorrect': '-1'}, {'optionContent': 'D.var x=(1,1) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"4、类定义如下，描述不正确的是
abstract class Element 
{ 
def contents: Array[String] 
} 
？（ ）。
","[{'optionContent': 'A.Element是一个抽象类。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Element不能实例化。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.contents成员定义错误，没有初始化。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.contents方法是类Element的抽象成员。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"5、对于拉链操作val t1 = Array(1, 3); val t2 = Array(2,4) ; t1.zip(t2)返回结果正确的是？（ ）。
","[{'optionContent': 'A.（1,2,3,4) \n', 'isCorrect': '-1'}, {'optionContent': 'B.（(1,3),(2,4)) \n', 'isCorrect': '-1'}, {'optionContent': 'C.（(1,2),(3,4)) \n', 'isCorrect': '-1'}, {'optionContent': 'D.（(1,4),(3,4)) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"6、有关柯里化描述错误的是 ？（ ）。
","[{'optionContent': 'A.柯里化是指将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数作为参数的函数。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.柯里化是多参数列表函数的特例。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.将函数def add(x: Int, y: Int) = x + y，变形为def add(x: Int)(y: Int) = x + y的过程是一个柯里化过程。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.柯里化允许用户自建立控制结构 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"7、scala中，下面的哪个类定义是不正确的？（ ）。
","[{'optionContent': 'A.class Counter{def counter = “counter”} \n', 'isCorrect': '-1'}, {'optionContent': 'B.class Counter{val counter = “counter”} \n', 'isCorrect': '-1'}, {'optionContent': 'C.class Counter{var counter:String} \n', 'isCorrect': '-1'}, {'optionContent': 'D.class Counter{def counter () {}} \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"8、哪一个是Action执行方法？（ ）。
","[{'optionContent': 'A.Map \n', 'isCorrect': '-1'}, {'optionContent': 'B.FlatMap \n', 'isCorrect': '-1'}, {'optionContent': 'C.Fliter \n', 'isCorrect': '-1'}, {'optionContent': 'D.Count \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"9、关于元组 Tuple 说法错误的是？（ ）。
","[{'optionContent': 'A.元组的可以包含不同类型的元素 \n', 'isCorrect': '-1'}, {'optionContent': 'B.元组是不可变的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.访问元组第一个元素的方式为 pair._1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.元组最多只有2个元素 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"10、在Scala中如何获取字符串”Hello”的首字符和尾字符？
","[{'optionContent': 'A.”Hello”(0),”Hello”(5) \n', 'isCorrect': '-1'}, {'optionContent': 'B.Hello”.take(1),”Hello”.reverse(0) \n', 'isCorrect': '-1'}, {'optionContent': 'C.“Hello”(1),”Hello”(5) \n', 'isCorrect': '-1'}, {'optionContent': 'D.“Hello”.take(0),”Hello”.takeRight(1) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"多选题 （共计 10 题，总计 20分）
11、对于Spark的运行模式描述正确的是？（ ）。
","[{'optionContent': 'A.Standalone是单机模式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Local模式一般用于测试 \n', 'isCorrect': '-1'}, {'optionContent': 'C.On Yarn模式由Spark的Master来负责集群资源管理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Local模式是单机模式 \n', 'isCorrect': '-1'}]","【答案解析】local：只启动一个executorlocal[k]:启动k个executorlocal：启动跟cpu数目相同的 executorstandalone模式分布式部署集群， 自带完整的服务，资源管理和任务监控是Spark自己监控Spark on yarn模式分布式部署集群，资源和任务监控交给yarn管理
","【正确答案】B,D
"
"12、以下哪些方法是执行方法？（ ）。
","[{'optionContent': 'A.count \n', 'isCorrect': '-1'}, {'optionContent': 'B.top \n', 'isCorrect': '-1'}, {'optionContent': 'C.foreach \n', 'isCorrect': '-1'}, {'optionContent': 'D.mapPartitions \n', 'isCorrect': '-1'}]","【答案解析】对于SparkRDD方法的基本掌握
","【正确答案】A,B,C
"
"13、以下对RDD持久化机制描述正确的是？（ ）。
","[{'optionContent': 'A.cache()方法可以缓存RDD \n', 'isCorrect': '-1'}, {'optionContent': 'B.cache()方法支持memory_only_ser级别 \n', 'isCorrect': '-1'}, {'optionContent': 'C.persist()方法默认的是memory_only级别 \n', 'isCorrect': '-1'}, {'optionContent': 'D.persist()方法支持memory_only_ser级别 \n', 'isCorrect': '-1'}]","【答案解析】Spark可以使用 persist 和 cache 方法将任意 RDD 缓存到内存、磁盘文件系统中。缓存是容错的，如果一个 RDD 分片丢失，可以通过构建它的 transformation自动重构。被缓存的 RDD 被使用的时，存取速度会被大大加速。一般的executor内存60%做 cache， 剩下的40%做task。
","【正确答案】A,C,D
"
"14、以下说法正确的是？（ ）。
","[{'optionContent': 'A.窄依赖底层会应用流水线优化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.窄依赖不会产生shuffle \n', 'isCorrect': '-1'}, {'optionContent': 'C.filter方法会产生宽依赖 \n', 'isCorrect': '-1'}, {'optionContent': 'D.借助依赖关系,RDD可以实现恢复数据 \n', 'isCorrect': '-1'}]","【答案解析】对于Spark依赖关系的基本掌握
","【正确答案】A,C,D
"
"15、以下对RDD持久化机制描述正确的是？（ ）。
","[{'optionContent': 'A.可以将RDD存到磁盘上 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以将RDD存到缓存中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.缓存RDD会避免重新计算，提高性能 \n', 'isCorrect': '-1'}, {'optionContent': 'D.未缓存的RDD数据会被GC清理掉 \n', 'isCorrect': '-1'}]","【答案解析】Spark可以使用 persist 和 cache 方法将任意 RDD 缓存到内存、磁盘文件系统中。缓存是容错的，如果一个 RDD 分片丢失，可以通过构建它的 transformation自动重构。被缓存的 RDD 被使用的时，存取速度会被大大加速。一般的executor内存60%做 cache， 剩下的40%做task。
","【正确答案】A,B,C,D
"
"16、以下对Spark的共享变量描述正确的是？（ ）。
","[{'optionContent': 'A.广播变量缓存到各个节点的内存中，而不是每个 Task \n', 'isCorrect': '-1'}, {'optionContent': 'B.广播变量被创建后，能在集群中运行的任何函数调用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.广播变量是只读的，不能在被广播后修改 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sc.broadcast(数据)用于创建广播变量 \n', 'isCorrect': '-1'}]","【答案解析】广播变量（Broadcast Variables）– 广播变量缓存到各个节点的内存中，而不是每个 Task– 广播变量被创建后，能在集群中运行的任何函数调用– 广播变量是只读的，不能在被广播后修改– 对于Scala&Spark集的广播， Spark 尝试使用高效的广播算法来降低通信成本
","【正确答案】A,B,C,D
"
"17、以下哪些是Spark 的DAGScheduler的功能？（ ）。
","[{'optionContent': 'A.接受用户提交的job \n', 'isCorrect': '-1'}, {'optionContent': 'B.将DAG划分为不同的stage \n', 'isCorrect': '-1'}, {'optionContent': 'C.决定每个task的最佳位置，任务在数据所在节点上运行 \n', 'isCorrect': '-1'}, {'optionContent': 'D.将taskSet提交给TaskScheduler \n', 'isCorrect': '-1'}]","【答案解析】主要功能：1.接受用户提交的job；2.将job根据类型划分为不同的stage，记录那些RDD，stage被物化，并在每一个stage内产生一系列的task，并封装成taskset；3.决定每个task的最佳位置，任务在数据所在节点上运行，并结合当前的缓存情况，将taskSet提交给TaskScheduler；4.重新提交shuffle输出丢失的stage给taskScheduler；注：一个stage内部的错误不是由shuffle输出丢失造成的，DAGScheduler是不管的，由TaskScheduler负责尝试重新提交task执行。
","【正确答案】A,B,C,D
"
"18、spark中worker 的主要工作是什么？（ ）。
","[{'optionContent': 'A.管理当前节点内存，CPU的使用情况 \n', 'isCorrect': '-1'}, {'optionContent': 'B.接受master发送过来的资源指令 \n', 'isCorrect': '-1'}, {'optionContent': 'C.启动executor进程执行Task \n', 'isCorrect': '-1'}, {'optionContent': 'D.worker不会运行代码，具体运行的是executor \n', 'isCorrect': '-1'}]","【答案解析】worker不会运行代码，具体运行的是executor，可以运行具体application斜的业务逻辑代码，操作代码的节点，不会去运行代码
","【正确答案】A,B,C,D
"
"19、以下关于Spark的数据倾斜处理方式正确的是？（ ）。
","[{'optionContent': 'A.提高executor的资源大小（内存和核数）。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.检查数据本身是否异常数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.找出异常的key，判断是哪些key造成的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.使用map side join 替代  reduce side join \n', 'isCorrect': '-1'}]","【答案解析】1.发现数据倾斜的时候，不要急于提高executor的资源，修改参数或是修改程序，首先要检查数据本身，是否存在异常数据。2.找出异常的key。3.如果任务长时间卡在最后最后1个(几个)任务，首先要对key进行抽样分析，判断是哪些key造成的。 选取key，对数据进行抽样，统计出现的次数，根据出现次数大小排序取出前几个。
","【正确答案】A,B,C,D
"
"20、以下哪些方法是懒方法（变换操作）？（ ）。
","[{'optionContent': 'A.top \n', 'isCorrect': '-1'}, {'optionContent': 'B.sort \n', 'isCorrect': '-1'}, {'optionContent': 'C.sortBy \n', 'isCorrect': '-1'}, {'optionContent': 'D.collect \n', 'isCorrect': '-1'}]","【答案解析】对于SparkRDD方法的基本掌握
","【正确答案】B,C
"
"21、如果需要使用scala库中的sqrt函数,如sqrt(2)，下列引用包的方式错误的是？（ ）。
","[{'optionContent': 'A.import scala.math._ \n', 'isCorrect': '-1'}, {'optionContent': 'B.import sqrt \n', 'isCorrect': '-1'}, {'optionContent': 'C.import math._ \n', 'isCorrect': '-1'}, {'optionContent': 'D.import math.sqrt \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"22、以下单例对象，定义错误的是？（ ）。
","[{'optionContent': 'A.object A{var str = “”} \n', 'isCorrect': '-1'}, {'optionContent': 'B.object A(str:String){} \n', 'isCorrect': '-1'}, {'optionContent': 'C.object A{def str = “”} \n', 'isCorrect': '-1'}, {'optionContent': 'D.object A{val str = “”} \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"23、下面哪个端口不是 spark 自带服务的端口（ ）。
","[{'optionContent': 'A.8080 \n', 'isCorrect': '-1'}, {'optionContent': 'B.4040 \n', 'isCorrect': '-1'}, {'optionContent': 'C.7077 \n', 'isCorrect': '-1'}, {'optionContent': 'D.8090 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"24、关于函数def fac(n:Int) = { var r = 1 ; for(i <- 1 to n) r = r * i ; r} fac(5)输出结果正确的是？（ ）。
","[{'optionContent': 'A.15 \n', 'isCorrect': '-1'}, {'optionContent': 'B.120 \n', 'isCorrect': '-1'}, {'optionContent': 'C.200 \n', 'isCorrect': '-1'}, {'optionContent': 'D.300 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"25、下面哪个不是 RDD 的特点（ ）。
","[{'optionContent': 'A.可分区 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可序列化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可修改 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可持久化 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"26、scala语言中，关于List的定义。不正确的是？（ ）。
","[{'optionContent': 'A.val list = List(1,2,3)。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.val list = List[Int](1,2,3)。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.val list = List[String](‘a’,’b’,’c’)。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.val list = List[String]()。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"27、哪一个不是Spark RDD的创建方式？（ ）。
","[{'optionContent': 'A.将普通集合转变为RDD \n', 'isCorrect': '-1'}, {'optionContent': 'B.使用本地文件创建RDD \n', 'isCorrect': '-1'}, {'optionContent': 'C.读取HDFS文件创建RDD \n', 'isCorrect': '-1'}, {'optionContent': 'D.直接将Avro数据转变为RDD \n', 'isCorrect': '-1'}]","【答案解析】1).使用程序中的集合创建rdd2).使用本地文件系统创建rdd3).使用hdfs创建rdd，4).基于数据库db创建rdd5).基于Nosql创建rdd，如hbase6).基于s3创建rdd，7).基于数据流，如socket创建rdd
","【正确答案】D
"
"28、Task 运行所在的Executor 是启动在哪个组件上？（ ）。
","[{'optionContent': 'A.Driver \n', 'isCorrect': '-1'}, {'optionContent': 'B.Master \n', 'isCorrect': '-1'}, {'optionContent': 'C.Worker \n', 'isCorrect': '-1'}, {'optionContent': 'D.Yarn \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"29、哪些方式可以创建RDD？（ ）。
","[{'optionContent': 'A.将一个普通集合类型转变为RDD \n', 'isCorrect': '-1'}, {'optionContent': 'B.读取Linux本地文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.读取Window本地文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.读取HDFS文件 \n', 'isCorrect': '-1'}]","【答案解析】对于Spark RDD概念的基本掌握
","【正确答案】A,B,C,D
"
"30、以下对于Spark pipeline（数据流管道）机制描述争取的是？（ ）。
","[{'optionContent': 'A.窄依赖底层会执行pipeline(数据流管道)优化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.管道中RDD是在内存里计算的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.管道中RDD的持久化是发生在shuffle write时 \n', 'isCorrect': '-1'}, {'optionContent': 'D.管道中RDD的持久化是发生在shuffle read时 \n', 'isCorrect': '-1'}]","【答案解析】spark的pipeline管道计算模式相当于执行了一个高阶函数，也就是说来一条数据然后计算一条数据，会把所有的逻辑走完然后落地。而Hadoop的MapReduce是1+1=2，2+1=3这样的计算模式，也就是计算完落地，然后再计算，然后再落地到磁盘或者内存，最后数据是落在计算节点上，按reduce的hash分区落地。管道计算模式完全基于内存计算，所以比MapReduce快的原因。
","【正确答案】A,B,C
"
"31、以下说法正确的是？（ ）。
","[{'optionContent': 'A.窄依赖，父子分区一对一关系 \n', 'isCorrect': '-1'}, {'optionContent': 'B.窄依赖会产生shuffle \n', 'isCorrect': '-1'}, {'optionContent': 'C.宽依赖，父子分区一对多关系 \n', 'isCorrect': '-1'}, {'optionContent': 'D.宽依赖会产生shuffle \n', 'isCorrect': '-1'}]","【答案解析】对于Spark依赖关系的基本掌握
","【正确答案】A,C,D
"
"32、Spark的技术栈有哪些？（ ）。
","[{'optionContent': 'A.Spark Core \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spark RDD \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spark DAG \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spark MLlib \n', 'isCorrect': '-1'}]","【答案解析】1.Spark core：是其它组件的基础，spark的内核，主要包含：有向循环图、RDD、Lingage、Cache、broadcast等，并封装了底层通讯框架，是Spark的基础。2.SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行类似Map、Reduce和Join等复杂操作，将流式计算分解成一系列短小的批处理作业。3.Spark sql：Shark是SparkSQL的前身，Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询，同时进行更复杂的数据分析4.BlinkDB ：是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎，它允许用户通过权衡数据精度来提升查询响应时间，其数据的精度被控制在允许的误差范围内。5.MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib，MLI、ML Optimizer和MLRuntime。6.GraphX是Spark中用于图和图并行计算
","【正确答案】A,D
"
"33、表达式for(i <- 1 to 3; for(j <- 1 to 3; if i != j ) print((10 * i + j)) + "" ""输出结果正确的是？（ ）。
","[{'optionContent': 'A.11 12 13 21 22 23 31 32 33 \n', 'isCorrect': '-1'}, {'optionContent': 'B.11 13 21 23 31 33 \n', 'isCorrect': '-1'}, {'optionContent': 'C.12 13 21 23 31 32 \n', 'isCorrect': '-1'}, {'optionContent': 'D.11 12 21 22 31 32 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"34、下面哪个操作肯定是宽依赖  （ ）。
","[{'optionContent': 'A.ReduceBykey \n', 'isCorrect': '-1'}, {'optionContent': 'B.Map \n', 'isCorrect': '-1'}, {'optionContent': 'C.FlatMap \n', 'isCorrect': '-1'}, {'optionContent': 'D.MapPartitions \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"35、哪一个不是Spark Shuffle优化的手段？（ ）。
","[{'optionContent': 'A.压缩数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.尽量减少磁盘I/O \n', 'isCorrect': '-1'}, {'optionContent': 'C.更换更高效的序列化框架 \n', 'isCorrect': '-1'}, {'optionContent': 'D.减少分区数 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"36、下面哪个操作是窄依赖 （ ）。
","[{'optionContent': 'A.ReduceBykey \n', 'isCorrect': '-1'}, {'optionContent': 'B.Filter \n', 'isCorrect': '-1'}, {'optionContent': 'C.Group \n', 'isCorrect': '-1'}, {'optionContent': 'D.Sort \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"37、spark程序支持用哪些语言编写？
","[{'optionContent': 'A.Java \n', 'isCorrect': '-1'}, {'optionContent': 'B.C# \n', 'isCorrect': '-1'}, {'optionContent': 'C.Scala \n', 'isCorrect': '-1'}, {'optionContent': 'D.Python \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"38、哪一个不是RDD的弹性的体现？（ ）。
","[{'optionContent': 'A.stage如果失败会自动进行特定次数的重试，而且只会计算失败的分片 \n', 'isCorrect': '-1'}, {'optionContent': 'B.checkpoint和persist，数据计算之后持久化缓存 \n', 'isCorrect': '-1'}, {'optionContent': 'C.数据调度弹性，DAG TASK调度和资源无关 \n', 'isCorrect': '-1'}, {'optionContent': 'D.RDD可以通过读取HDFS文件来创建 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"39、关于辅助构造器，以下说法不正确的是？（ ）。
","[{'optionContent': 'A.辅助构造器的名称为this。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.辅助构造器的定义要调用已定义的辅助构造器或主构造器。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.辅助构造器可以有任意多个。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.辅助构造器必须要带参数。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"40、以下关于Spark的数据倾斜描述正确的是？（ ）。
","[{'optionContent': 'A.产生数据倾斜会拖慢整个任务的执行速度。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.过多的数据在同一task中运行也是一种数据倾斜 \n', 'isCorrect': '-1'}, {'optionContent': 'C.数据倾斜的后果之一是可能撑爆executor的内存 \n', 'isCorrect': '-1'}, {'optionContent': 'D.执行join操作不会发生数据倾斜 \n', 'isCorrect': '-1'}]","【答案解析】数据倾斜的后果1.spark中的stage的执行时间受限于最后那个执行完成的task,因此运行缓慢的任务会拖垮整个程序的运行速度（分布式程序运行的速度是由最慢的那个task决定的）。2.过多的数据在同一个task中运行，将会把executor撑爆。
","【正确答案】A,B,C
"
"41、以下对Spark的累加器描述正确的是？（ ）。
","[{'optionContent': 'A.累加器只支持加法操作 \n', 'isCorrect': '-1'}, {'optionContent': 'B.累加器是只读的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.累加器可以全局被访问到 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sc.accumulator用于创建累加器 \n', 'isCorrect': '-1'}]","【答案解析】累加器只支持加法操作，可以高效地并行，用于实现计数器和变量求和。Spark 原生支持数值类型和标准可变集合的计数器，但用户可以添加新的类型。只有驱动程序才能获取累加器的值
","【正确答案】A,C,D
"
"42、spark中的RDD是什么，有哪些特性？（ ）。
","[{'optionContent': 'A.就是一个集合，用于存放数据的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.分布式，可以并行在集群计算 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以设置和调整分区数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.中文翻译为弹性分布式数据集 \n', 'isCorrect': '-1'}]","【答案解析】对于Spark的RDD概念的基本掌握
","【正确答案】A,B,C,D
"
"43、以下哪些方法是懒方法（变换操作）？（ ）。
","[{'optionContent': 'A.reduceByKey \n', 'isCorrect': '-1'}, {'optionContent': 'B.reduce \n', 'isCorrect': '-1'}, {'optionContent': 'C.take \n', 'isCorrect': '-1'}, {'optionContent': 'D.first \n', 'isCorrect': '-1'}]","【答案解析】对于SparkRDD方法的基本掌握
","【正确答案】A,C
"
"44、以下哪些是Spark的组件（ ）。
","[{'optionContent': 'A.Master \n', 'isCorrect': '-1'}, {'optionContent': 'B.Worker \n', 'isCorrect': '-1'}, {'optionContent': 'C.Driver \n', 'isCorrect': '-1'}, {'optionContent': 'D.DAG \n', 'isCorrect': '-1'}]","【答案解析】主要有如下组件：1.master：管理集群和节点，不参与计算。2.worker：计算节点，进程本身不参与计算，和master汇报。3.Driver：运行程序的main方法，创建spark context对象。4.spark context：控制整个application的生命周期，包括dagsheduler和task scheduler等组件。5.client：用户提交程序的入口。
","【正确答案】A,B,C
"
"45、以下哪些是Spark调优的可行手段（ ）。
","[{'optionContent': 'A.设置合适的资源量 \n', 'isCorrect': '-1'}, {'optionContent': 'B.启用高效的序列化方法如kyro \n', 'isCorrect': '-1'}, {'optionContent': 'C.提高数据的本地性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.复用RDD进行缓存 \n', 'isCorrect': '-1'}]","【答案解析】spark调优比较复杂，但是大体可以分为三个方面来进行，1.平台层面的调优：防止不必要的jar包分发，提高数据的本地性，选择高效的存储格式如parquet，2.应用程序层面的调优：过滤操作符的优化降低过多小任务，降低单条记录的资源开销，处理数据倾斜，复用RDD进行缓存，作业并行化执行等等，3.JVM层面的调优：设置合适的资源量，设置合理的JVM，启用高效的序列化方法如kyro，增大off head内存等等
","【正确答案】A,B,C,D
"
"46、以下关于Spark的数据倾斜处理方式正确的是？（ ）。
","[{'optionContent': 'A.隔离执行，将异常的key过滤出来单独处理，最后与正常数据的处理结果进行union操作 \n', 'isCorrect': '-1'}, {'optionContent': 'B.对key先添加随机值，进行操作后，去掉随机值，再进行一次操作 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用map side join \n', 'isCorrect': '-1'}, {'optionContent': 'D.对异常数据过滤后再处理 \n', 'isCorrect': '-1'}]","【答案解析】1.发现数据倾斜的时候，不要急于提高executor的资源，修改参数或是修改程序，首先要检查数据本身，是否存在异常数据。2.找出异常的key。3.如果任务长时间卡在最后最后1个(几个)任务，首先要对key进行抽样分析，判断是哪些key造成的。 选取key，对数据进行抽样，统计出现的次数，根据出现次数大小排序取出前几个。
","【正确答案】A,B,C,D
"
"47、spark中的RDD是什么，有哪些特性？（ ）。
","[{'optionContent': 'A.就是一个集合，用于存放数据的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.RDD数据可以存储在内存里或磁盘上 \n', 'isCorrect': '-1'}, {'optionContent': 'C.RDD的分区是可以改变的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.和Array和List没什么区别 \n', 'isCorrect': '-1'}]","【答案解析】对于Spark的RDD概念的基本掌握
","【正确答案】A,B,C
"
"48、scala 中，类和它的伴生对象说法错误的是？（ ）。
","[{'optionContent': 'A.类和它的伴生对象定义在同一个文件中。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.类和它的伴生对象可以有不同的名称。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.类和它的伴生对象可以互相访问私有特性。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.类和它的伴生对象可以实现既有实例方法又有静态方法。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"49、默认的存储级别（ ）。
","[{'optionContent': 'A.MEMORY_ONLY \n', 'isCorrect': '-1'}, {'optionContent': 'B.MEMORY_ONLY_SER \n', 'isCorrect': '-1'}, {'optionContent': 'C.MEMORY_AND_DISK \n', 'isCorrect': '-1'}, {'optionContent': 'D.MEMORY_AND_DISK_SER \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"50、关于数组val a = Array(1,2,3)下列说法错误的是？（ ）。
","[{'optionContent': 'A.val b = 2 * a // b 等于 Array(2,4,6) \n', 'isCorrect': '-1'}, {'optionContent': 'B.val b = a.map(_*2) // b 等于 Array(2,4,6) \n', 'isCorrect': '-1'}, {'optionContent': 'C.val b = for(elem <- a) yield 2 * elem // b 等于 Array(2,4,6) \n', 'isCorrect': '-1'}, {'optionContent': 'D.val b = for(elem <- a if elem % 2 == 0) yield 2 * elem // b 等于 Array(4) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"51、不属于Scala 7种数据类型之一的是？
","[{'optionContent': 'A.char \n', 'isCorrect': '-1'}, {'optionContent': 'B.int \n', 'isCorrect': '-1'}, {'optionContent': 'C.long \n', 'isCorrect': '-1'}, {'optionContent': 'D.longlong \n', 'isCorrect': '-1'}]","【答案解析】Scala支持数据类型：Byte、Short、Int、Long、Float、Double、Char
","【正确答案】D
"
"52、关于累加器，下面哪个是错误的 （ ）。
","[{'optionContent': 'A.支持加法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.支持数值类型 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可并行 \n', 'isCorrect': '-1'}, {'optionContent': 'D.不支持自定义类型 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"53、Spark中的stage指的是？（ ）。
","[{'optionContent': 'A.一个RDD \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个RDD中的一个Parition \n', 'isCorrect': '-1'}, {'optionContent': 'C.DAG中按照宽窄依赖关系而划分出的一个阶段 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一组Task的集合 \n', 'isCorrect': '-1'}]","【答案解析】对于SparkStage概念的基本掌握
","【正确答案】C,D
"
"54、下列对Spark 的DAG描述正确的是？（ ）。
","[{'optionContent': 'A.DAG中文含义为有向有环图 \n', 'isCorrect': '-1'}, {'optionContent': 'B.DAG中只记录了RDD之间的宽依赖关系 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个DAG可以产生多个Job \n', 'isCorrect': '-1'}, {'optionContent': 'D.DAG可以被划分为多个Stage \n', 'isCorrect': '-1'}]","【答案解析】对于Spark DAG概念的基本掌握
","【正确答案】C,D
"
"55、Spark的技术栈有哪些？（ ）。
","[{'optionContent': 'A.Spark Streaming \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spark Stage \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spark Task \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spark Graphx \n', 'isCorrect': '-1'}]","【答案解析】1.Spark core：是其它组件的基础，spark的内核，主要包含：有向循环图、RDD、Lingage、Cache、broadcast等，并封装了底层通讯框架，是Spark的基础。2.SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行类似Map、Reduce和Join等复杂操作，将流式计算分解成一系列短小的批处理作业。3.Spark sql：Shark是SparkSQL的前身，Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询，同时进行更复杂的数据分析4.BlinkDB ：是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎，它允许用户通过权衡数据精度来提升查询响应时间，其数据的精度被控制在允许的误差范围内。5.MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib，MLI、ML Optimizer和MLRuntime。6.GraphX是Spark中用于图和图并行计算
","【正确答案】A,D
"
"56、以下对RDD持久化机制描述正确的是？（ ）。
","[{'optionContent': 'A.persist可以指定一个StorageLevel \n', 'isCorrect': '-1'}, {'optionContent': 'B.尽可能不要存储到硬盘上,否则，重新计算一个分区的速度，和与从硬盘中读取基本差不多快 \n', 'isCorrect': '-1'}, {'optionContent': 'C.复制存储级别可以让你在RDD上持续的运行任务，而不需要等待丢失的分区被重新计算 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在不会使用cached RDD的时候，及时使用unpersist方法来释放它 \n', 'isCorrect': '-1'}]","【答案解析】Spark的不同StorageLevel ，目的满足内存使用和CPU效率权衡上的不同需求。我们建议通过以下的步骤来进行选择：1.如果你的RDDs可以很好的与默认的存储级别(MEMORY_ONLY)契合，就不需要做任何修改了。这已经是CPU使用效率最高的选项，它使得RDDs的操作尽可能的快。2.如果不行，试着使用MEMORY_ONLY_SER并且选择一个快速序列化的库使得对象在有比较高的空间使用率的情况下，依然可以较快被访问。3.尽可能不要存储到硬盘上，除非计算数据集的函数，计算量特别大，或者它们过滤了大量的数据。否则，重新计算一个分区的速度，和与从硬盘中读取基本差不多快。4.如果你想有快速故障恢复能力，使用复制存储级别(例如：用Spark来响应web应用的请求)。所有的存储级别都有通过重新计算丢失数据恢复错误的容错机制，但是复制存储级别可以让你在RDD上持续的运行任务，而不需要等待丢失的分区被重新计算。5.如果你想要定义你自己的存储级别(比如复制因子为3而不是2)，可以使用StorageLevel 单例对象的apply()方法。在不会使用cached RDD的时候，及时使用unpersist方法来释放它。
","【正确答案】A,B,C,D
"
"57、Spark的部署模式包括？
","[{'optionContent': 'A.local模式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.standalone模式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.yarn模式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Mesos模式 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A,B,C,D
"
"58、对于函数
def getGoodsPrice(goods:String) = { 
val prices = Map(“book” -> 5, “pen” -> 2, “sticker” -> 1) 
prices.getOrElse(goods, 0) 
} 
结果说法错误的是？（ ）。
","[{'optionContent': 'A.getGoodsPrice(""book"") // 等于 5 \n', 'isCorrect': '-1'}, {'optionContent': 'B.getGoodsPrice(""pen"") _x0016_// 等于 2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.getGoodsPrice(""sticker"") // 等于 1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.getGoodsPrice(""sock"") // 等于 “sock” \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"59、下列数组定义与其他不一致的是？（ ）。
","[{'optionContent': 'A.val a = Array[Int](0, 0) \n', 'isCorrect': '-1'}, {'optionContent': 'B.val a = Array(0, 0) \n', 'isCorrect': '-1'}, {'optionContent': 'C.val a = new Array[Int](2) \n', 'isCorrect': '-1'}, {'optionContent': 'D.val a = Array[Int](1, 1) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"60、以下关于Spark的数据倾斜描述正确的是？（ ）。
","[{'optionContent': 'A.现象是：多数task执行速度较快,少数task执行时间非常长，或者等待很长时间后提示你内存不足，执行失败。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.原因可能是key本身分布不均衡 \n', 'isCorrect': '-1'}, {'optionContent': 'C.原因可能是key的设置不合理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.原因可能是执行了reduceByKey操作 \n', 'isCorrect': '-1'}]","【答案解析】Spark产生数据倾斜的原因可能是：1.key本身分布不均衡（包括大量的key为空）2.key的设置不合理3.shuffle时的并发度不够4.计算方式有误
","【正确答案】A,B,C,D
"
"61、def fac(n:Int, x:String=""x"", y:Int=0) = {println(x*(n+y))} 输出结果不一致的是？（ ）。
","[{'optionContent': 'A.fac(2) \n', 'isCorrect': '-1'}, {'optionContent': 'B.fac(1, y=1) \n', 'isCorrect': '-1'}, {'optionContent': 'C.fac(1, ""x"") \n', 'isCorrect': '-1'}, {'optionContent': 'D.fac(1, ""x"", 1) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"62、关于数组的常用算法，下列说法错误的是？（ ）。
","[{'optionContent': 'A.Array(1,7,2,9).sum // 等于 19 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Array(1,7,2,9).sorted // 等于 Array(9,7,2,1) \n', 'isCorrect': '-1'}, {'optionContent': 'C.Array(""one"",""two"",""three"").max // 等于 ""two"" \n', 'isCorrect': '-1'}, {'optionContent': 'D.Array(""one"",""two"",""three"").mkString(""-"") // 等于 ""one-two-three"" \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"63、Spark 的数据本地性是在哪个环节确定的？（ ）。
","[{'optionContent': 'A.DAG生成阶段 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Stage划分阶段 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Task执行阶段 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SparkContext向ClusterManager申请资源阶段 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"64、下列哪个不是 RDD 的缓存方法（ ）。
","[{'optionContent': 'A.Persist() \n', 'isCorrect': '-1'}, {'optionContent': 'B.Cache() \n', 'isCorrect': '-1'}, {'optionContent': 'C.Memory() \n', 'isCorrect': '-1'}, {'optionContent': 'D.Unpersist() \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"65、Spark的技术栈有哪些？（ ）。
","[{'optionContent': 'A.MapReduce \n', 'isCorrect': '-1'}, {'optionContent': 'B.Yarn \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spark Sql \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spark Streaming \n', 'isCorrect': '-1'}]","【答案解析】1.Spark core：是其它组件的基础，spark的内核，主要包含：有向循环图、RDD、Lingage、Cache、broadcast等，并封装了底层通讯框架，是Spark的基础。2.SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行类似Map、Reduce和Join等复杂操作，将流式计算分解成一系列短小的批处理作业。3.Spark sql：Shark是SparkSQL的前身，Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询，同时进行更复杂的数据分析4.BlinkDB ：是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎，它允许用户通过权衡数据精度来提升查询响应时间，其数据的精度被控制在允许的误差范围内。5.MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib，MLI、ML Optimizer和MLRuntime。6.GraphX是Spark中用于图和图并行计算
","【正确答案】C,D
"
"66、以下哪些方法是执行方法？（ ）。
67、哪一个不是RDD的弹性的体现？（ ）。
","[{'optionContent': 'A.saveAsTextFile \n', 'isCorrect': '-1'}, {'optionContent': 'B.flatMap \n', 'isCorrect': '-1'}, {'optionContent': 'C.groupBy \n', 'isCorrect': '-1'}, {'optionContent': 'D.reduce \n', 'isCorrect': '-1'}, {'optionContent': 'A.自动的进行内存和磁盘的存储切换 \n', 'isCorrect': '-1'}, {'optionContent': 'B.基于Lingage的高效容错 \n', 'isCorrect': '-1'}, {'optionContent': 'C.task如果失败会自动进行特定次数的重试 \n', 'isCorrect': '-1'}, {'optionContent': 'D.RDD可以通过读取本地文件方式创建 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"68、Stage 的 Task 的数量由什么决定  （ ）。
","[{'optionContent': 'A.Partition \n', 'isCorrect': '-1'}, {'optionContent': 'B.Job \n', 'isCorrect': '-1'}, {'optionContent': 'C.Stage \n', 'isCorrect': '-1'}, {'optionContent': 'D.TaskScheduler \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"69、下面哪个操作是窄依赖？
","[{'optionContent': 'A.join \n', 'isCorrect': '-1'}, {'optionContent': 'B.filter \n', 'isCorrect': '-1'}, {'optionContent': 'C.group \n', 'isCorrect': '-1'}, {'optionContent': 'D.sort \n', 'isCorrect': '-1'}]","【答案解析】窄依赖是指1个父RDD分区对应1个子RDD的分区。换句话说，一个父RDD的分区对应于一个子RDD的分区，或者多个父RDD的分区对应于一个子RDD的分区。所以窄依赖又可以分为两种情况：1个子RDD的分区对应于1个父RDD的分区，比如map，filter，union等算子1个子RDD的分区对应于N个父RDD的分区，比如co-partioned join
","【正确答案】B
"
"70、scala 中，类成员的缺省访问级别是？（ ）。
","[{'optionContent': 'A.public \n', 'isCorrect': '-1'}, {'optionContent': 'B.private \n', 'isCorrect': '-1'}, {'optionContent': 'C.protected \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不对 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"71、函数 def fac(n:Int) = { var r = 1; for(i <- 1 to n )r = r * i :r} fac(5)输出结果是？
","[{'optionContent': 'A.60 \n', 'isCorrect': '-1'}, {'optionContent': 'B.120 \n', 'isCorrect': '-1'}, {'optionContent': 'C.15 \n', 'isCorrect': '-1'}, {'optionContent': 'D.存在语法错误，程序报错。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"72、对于Spark 的Job描述正确的是？（ ）。
","[{'optionContent': 'A.一旦driver程序中出现action，就会生成一个job \n', 'isCorrect': '-1'}, {'optionContent': 'B.执行count（）方法会生成一个job \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个DAG只能有一个Job \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个DAG可以有多个Job \n', 'isCorrect': '-1'}]","【答案解析】一旦driver程序中出现action，就会生成一个job，比如count等，向DAGScheduler提交job，如果driver程序后面还有action，那么其他action也会对应生成相应的job，所以，driver端有多少action就会提交多少job，这可能就是为什么spark将driver程序称为application而不是job 的原因。每一个job可能会包含一个或者多个stage，最后一个stage生成result，在提交job 的过程中，DAGScheduler会首先从后往前划分stage，划分的标准就是宽依赖，一旦遇到宽依赖就划分，然后先提交没有父阶段的stage们，并在提交过程中，计算该stage的task数目以及类型，并提交具体的task，在这些无父阶段的stage提交完之后，依赖该stage 的stage才会提交。
","【正确答案】A,B,D
"
"73、RDD和DataFrame最大的区别是？
","[{'optionContent': 'A.科学统计支持 \n', 'isCorrect': '-1'}, {'optionContent': 'B.多了schema \n', 'isCorrect': '-1'}, {'optionContent': 'C.存储方式不一样 \n', 'isCorrect': '-1'}, {'optionContent': 'D.外部数据源支持 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"74、Scala默认引入（无需声明即可使用）的包，不包括
","[{'optionContent': 'A.java.lang \n', 'isCorrect': '-1'}, {'optionContent': 'B.scala._ \n', 'isCorrect': '-1'}, {'optionContent': 'C.jre.interface \n', 'isCorrect': '-1'}, {'optionContent': 'D.Predef._ \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"75、Scala中，何为伴生对象？
","[{'optionContent': 'A.功能等同于守护线程，伴随与其他对象而存在 \n', 'isCorrect': '-1'}, {'optionContent': 'B.当一个单例存在同名类时 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Scala自动生成的对象的备份 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个对象所依赖的其他对象 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"76、以下哪些方法是会产生窄依赖？（ ）。
","[{'optionContent': 'A.map \n', 'isCorrect': '-1'}, {'optionContent': 'B.flatMap \n', 'isCorrect': '-1'}, {'optionContent': 'C.reduceByKey \n', 'isCorrect': '-1'}, {'optionContent': 'D.groupBy \n', 'isCorrect': '-1'}]","【答案解析】对于Spark依赖关系的基本掌握
","【正确答案】A,B
"
"77、Scala里，final修饰符的描述正确的是？（ ）。
","[{'optionContent': 'A.类的声明上添加final修饰符确保成员不被子类重载 \n', 'isCorrect': '-1'}, {'optionContent': 'B.类的声明上添加final修饰符把整个类声明为final，这个类不能被继承 \n', 'isCorrect': '-1'}, {'optionContent': 'C.类的声明上添加final修饰符确保成员只能被子类重载一次 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上说法都是错误的 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"78、下列对Spark 的DAG描述正确的是？（ ）。
","[{'optionContent': 'A.由多个RDD组成的逻辑上的计算链 \n', 'isCorrect': '-1'}, {'optionContent': 'B.DAG中记录了RDD之间的依赖关系 \n', 'isCorrect': '-1'}, {'optionContent': 'C.DAG可以被划分为多个Stage \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个DAG可以产生多个Job \n', 'isCorrect': '-1'}]","【答案解析】对于Spark DAG概念的基本掌握
","【正确答案】A,B,C,D
"
"79、对于Spark中Driver的描述正确的是？（ ）。
","[{'optionContent': 'A.一个spark作业运行时包括一个driver进程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.driver进程也就是作业的主进程，具有main函数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.driver有sparkContext的实例对象，是程序的入口 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以设置driver进程的内存大小 \n', 'isCorrect': '-1'}]","【答案解析】考察对Driver概念的了解
","【正确答案】A,B,C,D
"
"80、哪一个是懒方法？（ ）。
","[{'optionContent': 'A.Reduce \n', 'isCorrect': '-1'}, {'optionContent': 'B.Collect \n', 'isCorrect': '-1'}, {'optionContent': 'C.SaveAsTextFile \n', 'isCorrect': '-1'}, {'optionContent': 'D.SortByKey \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"81、Scala关于变量定义、赋值，错误的是？（ ）。
","[{'optionContent': 'A.val a = 3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.val a:String = 3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.var b:Int = 3 ; b = 6 \n', 'isCorrect': '-1'}, {'optionContent': 'D.var b = ""Hello World!"" ; b = ""123"" \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"82、Spark 支持的分布式部署方式中哪个是错误的 （ ）。
","[{'optionContent': 'A.Standalone \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spark on mesos \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spark on Yarn \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spark on Local \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"83、在Scala中如何获取字符串“Hello”的首字符和尾字符？（ ）。
","[{'optionContent': 'A.""Hello""(0)，""Hello""(5) \n', 'isCorrect': '-1'}, {'optionContent': 'B.""Hello"".take(1)，""Hello"".reverse(0) \n', 'isCorrect': '-1'}, {'optionContent': 'C.""Hello""(1)，""Hello""(5) \n', 'isCorrect': '-1'}, {'optionContent': 'D.""Hello"".take(0)， ""Hello"".takeRight(1) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"84、val tokens = ""one two three four two two three four"".split("" "") 
val map = new HashMap[String,Int] 
for(key <- tokens){ 
map(key) = map.getOrElse(key,0) + 1 
} 
？
","[{'optionContent': 'A.map(“one”) 等于 2 \n', 'isCorrect': '-1'}, {'optionContent': 'B.map(“two”) 等于 2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.map(“three”) 等于 3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.map(“four”) 等于 2 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"85、
关于函数def sum(args:Int*) = {var r = 0 ; for(arg <- args) r += arg ; r}} 输出结果不一致的是？（ ）。
","[{'optionContent': 'A.sum(1,2,3) \n', 'isCorrect': '-1'}, {'optionContent': 'B.sum(6) \n', 'isCorrect': '-1'}, {'optionContent': 'C.sum(2,4) \n', 'isCorrect': '-1'}, {'optionContent': 'D.sum(1,1,1,2) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"86、
以下哪些方法是懒方法（变换操作）？（ ）。
","[{'optionContent': 'A.map \n', 'isCorrect': '-1'}, {'optionContent': 'B.max \n', 'isCorrect': '-1'}, {'optionContent': 'C.join \n', 'isCorrect': '-1'}, {'optionContent': 'D.filter \n', 'isCorrect': '-1'}]","【答案解析】对于SparkRDD方法的基本掌握]
","【正确答案】A,C,D
"
"87、Spark 1.3.1之后， master 和 worker 通过什么方式进行通信的 （ ）。
","[{'optionContent': 'A.http \n', 'isCorrect': '-1'}, {'optionContent': 'B.nio \n', 'isCorrect': '-1'}, {'optionContent': 'C.netty \n', 'isCorrect': '-1'}, {'optionContent': 'D.Akka \n', 'isCorrect': '-1'}]","【答案解析】一直以来，基于Akka实现的RPC通信框架是Spark引以为豪的主要特性，也是与Hadoop等分布式计算框架对比过程中一大亮点，但是时代和技术都在演化，从Spark1.3.1版本开始，为了解决Scala&Spark块（如shuffle）的传输问题，Spark引入了Netty通信框架，到了1.6.0版本，Netty居然完全取代了Akka，承担Spark内部所有的RPC通信以及数据流传输。那么Akka又是什么东西？从Akka出现背景来说，它是基于Actor的RPC通信系统，它的核心概念也是Message，它是基于协程的，性能不容置疑；基于scala的偏函数，易用性也没有话说，但是它毕竟只是RPC通信，无法适用大的package/stream的数据传输，这也是Spark早期引入Netty的原因。那么Netty为什么可以取代Akka？首先不容置疑的是Akka可以做到的，Netty也可以做到，但是Netty可以做到，Akka却无法做到，原因？在软件栈中，Akka相比Netty要Higher一点，它专门针对RPC做了很多事情，而Netty相比更加基础一点，可以为不同的应用层通信协议（RPC，FTP，HTTP等）提供支持，在早期的Akka版本，底层的NIO通信就是用的Netty；其次一个优雅的工程师是不会允许一个系统中容纳两套通信框架；最后，虽然Netty没有Akka协程级的性能优势，但是Netty内部高效的Reactor线程模型，无锁化的串行设计，高效的序列化，零拷贝，内存池等特性也保证了Netty不会存在性能问题。
","【正确答案】C
"
"88、Spark Job 默认的调度模式（ ）。
","[{'optionContent': 'A.FIFO \n', 'isCorrect': '-1'}, {'optionContent': 'B.FAIR \n', 'isCorrect': '-1'}, {'optionContent': 'C.无 \n', 'isCorrect': '-1'}, {'optionContent': 'D.运行时指定 \n', 'isCorrect': '-1'}]","【答案解析】Spark中的调度模式主要有两种：FIFO和FAIR。默认情况下Spark的调度模式是FIFO（先进先出），谁先提交谁先执行，后面的任务需要等待前面的任务执行。而FAIR（公平调度）模式是多个任务共同使用整个集群资源
","【正确答案】A
"
"



Kafka
1、
Kafka消息获取与推送是采用什么模式？
","[{'optionContent': 'A.生产者push，消费者puch \n', 'isCorrect': '-1'}, {'optionContent': 'B.生产者pull，消费者pull \n', 'isCorrect': '-1'}, {'optionContent': 'C.生产者push，消费者pull \n', 'isCorrect': '-1'}, {'optionContent': 'D.生产者pull，消费者push \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
2、
Kafka与传统消息队列的区别错误的是？
","[{'optionContent': 'A.持久化日志 \n', 'isCorrect': '-1'}, {'optionContent': 'B.分布式系统，可以以集群模式运行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.支持实时的流式处理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.增加了对ECC内存的支持 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"
3、
关于Kafka数据顺序性说法正确的是？
","[{'optionContent': 'A.一个消费者组内部是有序的，消费者组之间是无序的。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个消费者组内部是无序的，消费者组之间是有序的。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个消费者组内部是无序的，消费者组之间也是无序的。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个消费者组内部是有序的，消费者组之间也是有序的。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
4、
关于Kafka的术语，下列说法错误的是：
","[{'optionContent': 'A.Kafka集群中的每台服务器叫Broker，整个集群由Zookeeper进行管理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Kafka采用发布订阅模式，每条消息都要发送到指定的Topic上 \n', 'isCorrect': '-1'}, {'optionContent': 'C.每个Topic可分为多个Partition，这样可以提高Kafka的并发执行能力 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Replica用于提高Kafka的扩展性，它分为Leader Replica、Follower Replica \n', 'isCorrect': '-1'}]","【答案解析】Replica的存在是为了保证数据的完整性和可靠性，而不是保证Kakfa的扩展性，器扩展性是由Partition来保证的。因此D错误。
","【正确答案】D
"
"
5、
关于Kafka的说法错误的是：
","[{'optionContent': 'A.Kafka是一个分布式的流媒体平台。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Kafka可以应用于消息系统、日志收集、用户行为追踪、流式处理等多种场景 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Kafka具有高吞吐量、消息持久化、高可靠性、高扩展性等优点 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Kafka采用硬盘持久化消息，所以性能比其他消息队列略低 \n', 'isCorrect': '-1'}]","【答案解析】Kafka虽然存在持久化机制，但是底层采用的是零拷贝机制，所以读写效率和其他消息队列对比并不会低，因此D错误。
","【正确答案】D
"
"
多选题 （共计 2 题，总计 4分）
6、
关于kafka的特点，描述正确的是：
","[{'optionContent': 'A.高吞吐量 \n', 'isCorrect': '-1'}, {'optionContent': 'B.持久化数据存储 \n', 'isCorrect': '-1'}, {'optionContent': 'C.分布式系统 \n', 'isCorrect': '-1'}, {'optionContent': 'D.易于扩展 \n', 'isCorrect': '-1'}]","【答案解析】Kafka的特点如下：高吞吐率：在廉价的商用机器上单机可支持100W条/秒消息消息持久化：所有的消息都会存储在磁盘上，不会产生消息的丢失分布式，可伸缩同时满足适应在线流处理和离线批处理
","【正确答案】A,B,C,D
"
"
7、
对于Kafka的如下描述中，正确的是
","[{'optionContent': 'A.Kafka中的每条消息都必读对应一个主题 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个主题对应一个分区，不能修改 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Kafka拥有副本机制，replica间没有主从之分，即平等 \n', 'isCorrect': '-1'}, {'optionContent': 'D.副本在选举的时候会考虑ISR策略 \n', 'isCorrect': '-1'}]","【答案解析】Kafka中的数据必须对应一个分区，可以更改数据的分区，所以A正确，B错误。Kakfa的副本会选举出leader和follower，所以C错误。
","【正确答案】A,D
"
"




HBase
1、
下列关于HRegionServer的各个组件描述正确的是：
","[{'optionContent': 'A.WAL是负责记录日志，采用了局部性原理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.BlockCache能够有效的保证数据的可靠性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.目前版本的HBase中，WAL只支持串行写 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HRegion中，HStore的个数由列族的数量决定 \n', 'isCorrect': '-1'}]","【答案解析】WAL负责记录日志，用于保证操作不会丢失，从HBase的0.96版本开始，支持并行写机制，所以A、C错误。BlockCache是读缓存，维系在内存中，采用了局部性原理，所以B错误。
","【正确答案】D
"
"
2、
关于hbase 实时查询的原理错误的是
","[{'optionContent': 'A.实时查询，可以认为是从内存中查询 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HBase 的机制是数据先写入到内存中，当数据量达到一定的量（如 128M），再写入磁盘中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HBase实时查询建立在强大的索引机制上。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
3、
下列各项中，关于HBase的列族叙述正确的是：
","[{'optionContent': 'A.HBase是以列族作为基本结构，一个HBase表中至少包含1个列族 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个HBase表创建好之后，列族可以动态增删 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个列族中至少包含1个列 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个列族中的列是固定不能改变的 \n', 'isCorrect': '-1'}]","【答案解析】HBase表中的列族在定义表的时候就需要指定，表定义好之后列族就不能再改变了，所以B错误。列族中的列可以动态的增删，所以个列族中可以包含0个或者多个列，因此C、D错误。
","【正确答案】A
"
"
4、
Hbase写入数据过程说法正确的是
","[{'optionContent': 'A.向Hhbase写入数据的时候首先要经过hlog记录操作 \n', 'isCorrect': '-1'}, {'optionContent': 'B.memstore存储数据在本地磁盘中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.memstore会变成storefile，storefile可以随意的修改 \n', 'isCorrect': '-1'}, {'optionContent': 'D.默认情况下，storefile在最后会合成一个大文件 \n', 'isCorrect': '-1'}]","【答案解析】在向HBase中添加数据的时候是先添加到hlog中，然后写入到memStore中，memStore是一个写缓存，是维系在内存中的，而当memStore达到一定条件的时候会进行冲刷，冲刷出storeFile，所以A正确，B错误。因为storeFile是维系在HDFS上的，所以只支持一次写入多次读取，因此storeFile不能修改，所以C错误。默认情况下，采用的合并机制是minor compact机制，是将多个小的storefile合成几个大的storefile，所以不是合成一个大文件，因此D错误。
","【正确答案】A
"
"
5、
关于行存储和列存储的说法，正确的是：
","[{'optionContent': 'A.在写入时，行存储和列存储的性能一样 \n', 'isCorrect': '-1'}, {'optionContent': 'B.行存储对于磁盘的利用时连续的，列存储对于磁盘的利用是不连续的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在进行全表查询的时候，列存储更快 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在实际生产环境中，因为使用指定字段查询的方式更多，所以行存储更占优势 \n', 'isCorrect': '-1'}]","【答案解析】行存储对于磁盘的利用是连续的，所以写入性能更高，更适合于全表查询；而列存储对于磁盘的利用是不连续的，所以写入性能较低，比较适合于针对字段的查询。
","【正确答案】B
"
"
6、
下列关于HBase中行键的说法错误的是：
","[{'optionContent': 'A.HBase中行键是用来做检索记录的主键 \n', 'isCorrect': '-1'}, {'optionContent': 'B.行键在使用的时候必须唯一 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HBase在存储的时候会对数据进行排序，默认是自然排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HBase行键在设计的时候要尽量减短且有意义 \n', 'isCorrect': '-1'}]","【答案解析】HBase会对行键进行排序，但是使用的是字典序而不是自然排序，所以C错误。
","【正确答案】C
"
"
7、
关于HMaster的职责，不包括的是：
","[{'optionContent': 'A.管理HRegionServer \n', 'isCorrect': '-1'}, {'optionContent': 'B.通过心跳机制来向Zookeeper注册节点保持联系 \n', 'isCorrect': '-1'}, {'optionContent': 'C.管理表结构 \n', 'isCorrect': '-1'}, {'optionContent': 'D.管理表中的数据 \n', 'isCorrect': '-1'}]","【答案解析】因为对表中数据的修改不经过HMaster，所以D错误。
","【正确答案】D
"
"
8、
HBase在读取数据的时候，读取的顺序是：
","[{'optionContent': 'A.BlockCache-memStore-HFile \n', 'isCorrect': '-1'}, {'optionContent': 'B.HFile-memStore-BlockCache \n', 'isCorrect': '-1'}, {'optionContent': 'C.memStore-HFile-BlockCache \n', 'isCorrect': '-1'}, {'optionContent': 'D.BlockCache-HFile-memStore \n', 'isCorrect': '-1'}]","【答案解析】BlockCache是读缓存，memStore是写缓存，HFile是数据最终的存储文件，所以读取顺序是先读缓存，然后是写缓存，最后才是HFile
","【正确答案】A
"
"
9、
hBase的子表hRegion的最大占用空间是？
","[{'optionContent': 'A.256M \n', 'isCorrect': '-1'}, {'optionContent': 'B.512M \n', 'isCorrect': '-1'}, {'optionContent': 'C.1G \n', 'isCorrect': '-1'}, {'optionContent': 'D.2G \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
10、
下列关于HBase的说法错误的是：
","[{'optionContent': 'A.HBase是一种非关系型的分布式数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HBase可以基于Hadoop构建也可以基于本地文件系统构建 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HBase的设计思想是基于行级别来设计存储数据的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HBase提供了完整的增删改查的能力 \n', 'isCorrect': '-1'}]","【答案解析】HBase是基于列级别来存储的而不是行级别，所以C错误。
","【正确答案】C
"
"
多选题 （共计 6 题，总计 12分）
11、
下列是HBase的特点的是：
","[{'optionContent': 'A.可以分布式存储 \n', 'isCorrect': '-1'}, {'optionContent': 'B.适合于存储稀疏数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以存储结构化和半结构化数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.提供了完整的增删改查的能力 \n', 'isCorrect': '-1'}]","【答案解析】HBASE是通过集群来存储数据，数据最终要落地到HDFS上是一种NoSQL的非关系型数据库，不符合关系型数据库的范式面向列存储，底层基于key-value结构适合存储半结构化、非结构化的数据适合存储稀疏的数据，空的数据不占用空间提供实时的增删改查的能力，但是不提供严格的事务机制，只能在行级别提供事务
","【正确答案】A,B,C,D
"
"
12、
下列关于HRegion的说法正确的是：
","[{'optionContent': 'A.HRegion是HBase中数据存储的最小单位 \n', 'isCorrect': '-1'}, {'optionContent': 'B.默认情况下，HRegion在达到10M的时候会均分为2个HRegion \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个HRegion由一个或者多个HStore组成 \n', 'isCorrect': '-1'}, {'optionContent': 'D.每一个HStore中包含0个或者多个HFile \n', 'isCorrect': '-1'}]","【答案解析】HRegion是HBase中分布式存储和负载均衡的最小单位，而数据存储的基本单位是HStore。
","【正确答案】B,C,D
"
"
13、
Hbase中HRegion的概念说法正确的是
","[{'optionContent': 'A.HRregion是HBase表分布式存储和负载均衡的基本单元 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HRegion是存储数据的最小单元 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个HRegion是由一个或者多个HStore来组成 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HRegion是Hbase表纵向切分的产物 \n', 'isCorrect': '-1'}]","【答案解析】HBase中，数据存储的最小单元是HStore，所以B错误。HRegion是HBase中表结构的横向切分的产物，而横向切分的产物是列族，所以D错误。
","【正确答案】A,C
"
"
14、
下列关于HMaster的说法正确的是：
","[{'optionContent': 'A.HMaster不存在单点故障，因为可以启动多个HMaster \n', 'isCorrect': '-1'}, {'optionContent': 'B.HMaster在启动的时候会主动的向Zookeeper注册临时节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.active HMaster通过监控Zookeeper中/hbase/backup-masters节点来确定backup HMaster的存活情况 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HMaster负责管理HBase表中的数据 \n', 'isCorrect': '-1'}]","【答案解析】因为对表中数据的修改不经过HMaster，所以D错误。
","【正确答案】A,B,C
"
"
15、
下列各项中，HRegionServer的组成结构的是：
","[{'optionContent': 'A.HLog \n', 'isCorrect': '-1'}, {'optionContent': 'B.memStore \n', 'isCorrect': '-1'}, {'optionContent': 'C.HRegion \n', 'isCorrect': '-1'}, {'optionContent': 'D.BlockCache \n', 'isCorrect': '-1'}]","【答案解析】HRegionServer由WAL（HLog）、HRegion以及BlockCache组成，而memStore是HRegion的组成结构之一。
","【正确答案】A,C,D
"
"
16、
下列关于HFile的说法正确的是：
","[{'optionContent': 'A.Data Block是数据存储的基本单位，大的DataBlock利于遍历，小的DataBlock便于查询 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在HFile的第二个版本中引入了布隆过滤器，能够在查询的时候更有效的去掉无用的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.单个HFile中数据是有序的，且按照行键进行自然排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.布隆过滤器的特点是能确定数据不存在，但是不能确定数据存在 \n', 'isCorrect': '-1'}]","【答案解析】单个HFile中的数据确实是有序的，但是是按照行键进行字典排序。
","【正确答案】A,B,D
"
"
17、关于hbase的特点说法错误的是
","[{'optionContent': 'A.hbase是一个分布式的，基于列式存储的数据库，基于hadoop的hdfs存储，zookeeper进行管理。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.hbase为null的数据不会被存储 \n', 'isCorrect': '-1'}, {'optionContent': 'C.hbase可以用作高性能的关系型数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'D.hbase是主从结构，hmaster作为主节点，hregionServer作为从节点 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"







Hive

1、
一下不属于Hive权限的是？
","[{'optionContent': 'A.ALL \n', 'isCorrect': '-1'}, {'optionContent': 'B.ALTER \n', 'isCorrect': '-1'}, {'optionContent': 'C.CREATE \n', 'isCorrect': '-1'}, {'optionContent': 'D.DELETE \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"
2、
对于语句
create table teacher(name string) clustered by (name) into 12 buckets row format delimited fields terminated by ' ';
select * from teacher tablesample(bucket 1 out of 3 on name);
中的bucket 1 out of 3 on name，下列说法正确的是：
","[{'optionContent': 'A.1 out of 3表示从编号为1的桶开始抽样，一共抽3个桶的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1 out of 3表示从编号为1的桶开始抽样，一共抽4个桶的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.1 out of 3表示从编号未1的桶开始抽样，一共抽1/3个桶的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.1 out of 3表示从编号未1的桶开始抽样，一共抽1/4个桶的数据 \n', 'isCorrect': '-1'}]","【答案解析】x out of y表示从第x个桶开始抽样，一共抽取桶数/y个桶的数据。所以1 out of 3是从第1个桶开始抽样，抽取12/3=4个桶的数据。
","【正确答案】B
"
"
3、
Hive数据倾斜原因不包括？
","[{'optionContent': 'A.key分布不均匀 \n', 'isCorrect': '-1'}, {'optionContent': 'B.业务数据本身的特性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.各个节点带宽不一 \n', 'isCorrect': '-1'}, {'optionContent': 'D.某些SQL语句本身就有数据倾斜 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
4、
下列关于Hive的说法错误的是：
","[{'optionContent': 'A.Hive是Apache提供的基于Hadoop的数仓工具 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Hive提供了类SQL语句用于进行数据的实时分析 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Hive在底层会将SQL转化为MapReduce来执行 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hive可以基于Hadoop进行数据的ETL过程 \n', 'isCorrect': '-1'}]","【答案解析】Hive是Apache提供的基于Hadoop的数仓工具，提供了类SQL语句，在底层会转化为MapReduce执行，但是执行效率比较低，所以适合于做离线分析，因此B错误。
","【正确答案】B
"
"
5、
Hive中，关于分区表说法错误的是：
","[{'optionContent': 'A.使用分区表在指定的分区中进行查询的时候能够有效的提高效率 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在分区表中不建议跨分区进行查询 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果将未分区的表中的数据插入到已分区表中的时候，需要开启动态分区机制，并且需要指定分区字段 \n', 'isCorrect': '-1'}, {'optionContent': 'D.分区表中的分区只支持单一字段分区 \n', 'isCorrect': '-1'}]","【答案解析】分区表中支持多字段分区，分区字段的前后顺序决定形成的层级目录的关系。
","【正确答案】D
"
"
6、
Hive最初是由哪家公司开发的？
","[{'optionContent': 'A.Amazon \n', 'isCorrect': '-1'}, {'optionContent': 'B.Facebook \n', 'isCorrect': '-1'}, {'optionContent': 'C.Google \n', 'isCorrect': '-1'}, {'optionContent': 'D.Yahoo \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"
7、
下列不是Hive数据类型的是？
","[{'optionContent': 'A.SMALINT \n', 'isCorrect': '-1'}, {'optionContent': 'B.STRUCT \n', 'isCorrect': '-1'}, {'optionContent': 'C.LIST \n', 'isCorrect': '-1'}, {'optionContent': 'D.ARRAY \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
8、
关于数据仓库和数据库的说法正确的是：
","[{'optionContent': 'A.两者都是提供了完整的增删改查的能力 \n', 'isCorrect': '-1'}, {'optionContent': 'B.两个都提供了完整的事务能力 \n', 'isCorrect': '-1'}, {'optionContent': 'C.两者针对冗余的处理是不同的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.两者的数据种类都相对单一 \n', 'isCorrect': '-1'}]","【答案解析】数据库中数据的种类和来源相对单一，提供了完整的增删改查的能力，且提供了完整的事务能力，但是数据库强调的是避免冗余；数据仓库中数据的种类和来源相对多样，但是只提供了增和查的能力，不支持修改，且一般强调事务，并且在数据仓库中一般会认为的制造冗余（副本）。
","【正确答案】C
"
"
9、
Hive中关于内部表和外部表的说法正确的是：
","[{'optionContent': 'A.内部表是用于管理HDFS已经存在的文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.外部表在删除的时候会将原文件一起删除 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在加载外部表的时候需要指定字段之间的间隔方式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.将本地文件加载到HDFS上使用的是外部表 \n', 'isCorrect': '-1'}]","【答案解析】外部表是用于管理HDFS上已经存在的表，在删除的时候不会删除源文件；内部表是在Hive中自己创建的表，在删除的时候会删除对应的文件。所以A、B错误。无论是内部表还是外部表，在加载文件的时候都需要指定字段之间的间隔方式，所以C正确。将本地文件加载到Hive上采用的是内部表，所以D错误。
","【正确答案】C
"
"
10、
下列关于hive内部表与外部表说法正确的是？
","[{'optionContent': 'A.创建内部表，会将数据移动到数据仓库指向的路径 \n', 'isCorrect': '-1'}, {'optionContent': 'B.创建内部表，会记录数据的所在地址 \n', 'isCorrect': '-1'}, {'optionContent': 'C.创建外部表，会将数据移动到数据仓库指向的路径 \n', 'isCorrect': '-1'}, {'optionContent': 'D.删除外部表，会将记录数据的路径上的原始数据一并删除 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
多选题 （共计 5 题，总计 10分）
11、
Hive提高查询效率的手段包括：
","[{'optionContent': 'A.建立索引 \n', 'isCorrect': '-1'}, {'optionContent': 'B.使用分桶表查询 \n', 'isCorrect': '-1'}, {'optionContent': 'C.建立视图 \n', 'isCorrect': '-1'}, {'optionContent': 'D.减少join的使用 \n', 'isCorrect': '-1'}]","【答案解析】分桶表是将数据进行分桶以便于进行数据的抽样，所以不能提高查询效率；而如果想要提高查询效率，可以考虑使用分区表。
","【正确答案】A,C,D
"
"
12、
下列关于OLAP和OLTP系统的说法正确的是：
","[{'optionContent': 'A.一般数据库支持的是OLAP，数据仓库支持的是OLTP \n', 'isCorrect': '-1'}, {'optionContent': 'B.OLAP一般面向管理、市场人员等，OLTP面向技术人员 \n', 'isCorrect': '-1'}, {'optionContent': 'C.OLTP强调的是事务的处理；OLAP则强调数据分析 \n', 'isCorrect': '-1'}, {'optionContent': 'D.OLAP是实时捕获数据，OLTP是存储历史数据 \n', 'isCorrect': '-1'}]","【答案解析】OLAP是联机分析处理系统，强调数据分析，使用数据仓库来存储和处理历史数据，跟过的是面向市场、管理等非技术人员；OLTP是联机事务处理系统，强调事务处理，使用数据库来存储数据，面向DBA等技术人员。
","【正确答案】B,C
"
"
13、
Hive中，关于索引的说法正确的是：
","[{'optionContent': 'A.Hive中的索引需要手动建立 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果在Hive表中新添加了数据，会自动建立索引 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在删除索引表的时候会删除原数据表 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hive中可以根据指定的字段建立索引 \n', 'isCorrect': '-1'}]","【答案解析】在Hive中因为不存在主键的概念，所以不会自动建立索引需要手动建立索引，而在建立索引的时候需要指定字段，因此A、D正确。如果向Hive中新添了数据，那么需要手动更新索引表，所以B错误。
","【正确答案】A,C,D
"
"
14、
ETL包括的过程有：
","[{'optionContent': 'A.Extract \n', 'isCorrect': '-1'}, {'optionContent': 'B.Transform \n', 'isCorrect': '-1'}, {'optionContent': 'C.Transaction \n', 'isCorrect': '-1'}, {'optionContent': 'D.Load \n', 'isCorrect': '-1'}]","【答案解析】ETL指的是数据的提取Extract、转化Transform和加载Load，而Transaction是事务，不包含在ETL过程中
","【正确答案】A,B,D
"
"
15、
下列各项中，关于Hive的视图的说法正确的是：
","[{'optionContent': 'A.Hive支持物化视图和虚拟视图 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Hive中的视图在建立好之后就已经触发了查询语句查询了数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.视图定义中若包含了order by/limit等语句，且查询视图时也定义了order by/limit等语句，则此时视图中的优先级更高 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hive中的视图支持迭代视图 \n', 'isCorrect': '-1'}]","【答案解析】Hive目前只支持虚拟视图不支持物化视图，所以A错误。Hive视图中定义的查询语句只有在视图第一次被使用的时候才会被触发，所以B错误。
","【正确答案】C,D
"
"




Flume
1、
Flume 采集数据会丢失吗？
","[{'optionContent': 'A.发生宕机有可能会丢失 \n', 'isCorrect': '-1'}, {'optionContent': 'B.不会，Channel 存储可以存储在 File 中，数据传输自身有事务。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"
2、
flume 的 source,sink,channel 说法正确的是？
channel ：数据缓存
sink ：把数据发送到目的地 
channel ：把数据发送到目的地
sink ：数据缓存 
channel ：数据清洗
sink ：把数据发送到目的地 
channel ：把数据发送到目的地
sink ：数据清洗 
","[{'optionContent': 'A.source ：搜集数据\n', 'isCorrect': '-1'}, {'optionContent': 'B.source ：搜集数据\n', 'isCorrect': '-1'}, {'optionContent': 'C.source ：搜集数据\n', 'isCorrect': '-1'}, {'optionContent': 'D.source ：搜集数据\n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
3、
下列关于Flume的说法，错误的是：
","[{'optionContent': 'A.Flume是Apache提供的一套用于进行日志收集的系统 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在Flume中，数据是以Event形式展现和传输的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.利用Flume，可以灵活的构建复杂流动模型 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Flume目前有2个版本：Flume-og和Flume-ng，这两个版本是兼容的 \n', 'isCorrect': '-1'}]","【答案解析】Flume确实包含两个版本，但是两个版本之间不兼容，所以D错误。
","【正确答案】D
"
"
4、
在Flume中，如果需要对传输的数据进行一些数据的处理和修改，则需要使用：
","[{'optionContent': 'A.Selector \n', 'isCorrect': '-1'}, {'optionContent': 'B.Interceptor \n', 'isCorrect': '-1'}, {'optionContent': 'C.Processor \n', 'isCorrect': '-1'}, {'optionContent': 'D.Filter \n', 'isCorrect': '-1'}]","【答案解析】Selector负责数据的分发方式是复制模式或者是路由模式，不能改变数据，所以A错误。Interceptor中提供了正则格式允许对数据进行改动，所以B正确。Processor是输出方式的指定，决定是采用优先输出还是负载均衡方式，不能改变数据，所以C错误。
","【正确答案】B
"
"
5、
下列关于Flume的Channel中，描述错误的是：
","[{'optionContent': 'A.Memory Channel是内存通道，特点是读写速度快，但是不可靠 \n', 'isCorrect': '-1'}, {'optionContent': 'B.File Channel是文件通道，特点是读写速度慢，但是可靠 \n', 'isCorrect': '-1'}, {'optionContent': 'C.JDBC Channel支持MySQL、Oracle等数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Memory Spillable Channel是内存溢出通道，在存储数据的时候先将数据存入内存，如果内存已满再放入磁盘 \n', 'isCorrect': '-1'}]","【答案解析】JDBC Channel目前只支持Derby数据库。
","【正确答案】C
"
"
6、
下列关于Flum的Source的阐述错误的是：
","[{'optionContent': 'A.AVRO Source需要接收被AVRO序列化之后的数据才能使用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HTTP Source可以接收GET和POST两种请求，其中最稳定的是GET请求 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spooling Directory Source用于监听指定目录，如果目录中新添了文件，会自动采集新文件中的内容 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Sequence Generator Source经常用于测试阶段，测试流动模型是否搭建成功 \n', 'isCorrect': '-1'}]","【答案解析】HTTP的请求方式有7种，但是HTTP Source只能接收GET和POST两种，但是GET请求不稳定，所以实际过程中使用的是POST，因此B错误。
","【正确答案】B
"
"
多选题 （共计 3 题，总计 6分）
7、
下列关于Flume中EventDrivenSource和PollableSource的说法正确的是：
","[{'optionContent': 'A.EventDrivenSource是主动型Source \n', 'isCorrect': '-1'}, {'optionContent': 'B.PollableSource是被动型Source \n', 'isCorrect': '-1'}, {'optionContent': 'C.EventDrivenSource需要自定义线程去获取数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.PollableSource已经提供了线程主动拉取数据 \n', 'isCorrect': '-1'}]","【答案解析】EventDrivenSource是被动型Source，需要自定义线程去获取数据；PollableSource是主动型Source，已经提供了线程去拉去数据。
","【正确答案】C,D
"
"
8、
下列各项中是Agent的组件的是：
","[{'optionContent': 'A.Source \n', 'isCorrect': '-1'}, {'optionContent': 'B.Channel \n', 'isCorrect': '-1'}, {'optionContent': 'C.Selector \n', 'isCorrect': '-1'}, {'optionContent': 'D.Sink \n', 'isCorrect': '-1'}]","【答案解析】Agent一共包含3个组件：Source，Channel和Sink，其中Source中包含子组件Selector和Interceptor
","【正确答案】A,B,D
"
"9、
以下Flume启动指令的参数中，说法正确的是：
","[{'optionContent': 'A.--conf，简写为–c，表示启动的配置文件所在的路径 \n', 'isCorrect': '-1'}, {'optionContent': 'B.--name，简写为-n，表示指定agent的名称 \n', 'isCorrect': '-1'}, {'optionContent': 'C.--file，简写为-f，表示指定要执行的格式文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.-Dflume.root.logger，可以简写为-Dlog，表示指定日志格式 \n', 'isCorrect': '-1'}]","【答案解析】- - Dflume.root.logger不能简写，用于表示日志信息输出的方式。
","【正确答案】A,B,C
"
"



Hadoop
1、
下列关于Shuffle说法正确的是：
","[{'optionContent': 'A.默认情况下，如果一个文件切片是240M，则一定会产生3次的spill过程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.默认情况下，Spill文件的大小是80M \n', 'isCorrect': '-1'}, {'optionContent': 'C.在缓冲区中，数据会进行排序，采用的是快速排序的方式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.如果溢写文件个数大于等于3个，则在merge过程中一定会进行combine \n', 'isCorrect': '-1'}]","【答案解析】缓冲区的溢写次数和原始数据大小没有关系而是要看MapTask处理之后产生的数据量的大小，所以A错误。Spill文件的大小要考虑序列化因素的影响，所以文件大小不一定是80M，因此B错误。只有在指定了Combiner之后，在merge过程中才可能会产生combine，所以D错误。
","【正确答案】C
"
"2
、
关于SecondaryNameNode 哪项是正确的？
","[{'optionContent': 'A.它是NameNode的热备 \n', 'isCorrect': '-1'}, {'optionContent': 'B.它对内存没有要求 \n', 'isCorrect': '-1'}, {'optionContent': 'C.他的目的使帮助NameNode合并编辑日志，减少NameNode 启动时间 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SecondaryNameNode应与NameNode 部署到一个节点 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"3
、
下列关于Hadoop的说法正确的是：
","[{'optionContent': 'A.Hadoop是Apache提供的一套分布式框架 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Hadoop集群一旦搭建好之后不能动态扩展 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Hadoop目前的所有版本都是兼容的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hadoop提供的主要功能是存储而不能计算 \n', 'isCorrect': '-1'}]","【答案解析】Hadoop是Apache提供的一个开源的、可靠的、可扩展的系统架构，可以利用分布式架构来进行海量数据的存储以及计算。所以A正确，B、D错误。Hadoop目前所有版本中，Hadoop1.0和Hadoop2.0版本是不兼容的，所以B错误。
","【正确答案】A
"
"4
、
如果将某一个节点设置为NameNode，则这个节点在选择时候最好是：
","[{'optionContent': 'A.计算型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.内存型 \n', 'isCorrect': '-1'}, {'optionContent': 'C.高IO型 \n', 'isCorrect': '-1'}, {'optionContent': 'D.大磁盘型 \n', 'isCorrect': '-1'}]","【答案解析】因为NameNode需要存储大量的元数据而对磁盘消耗相对较小，所以在选择时候最好选择内存型。
","【正确答案】B
"
"5
、
以下操作，在缓冲区中的发生顺序为：
","[{'optionContent': 'A.partition-combine-sort-spill \n', 'isCorrect': '-1'}, {'optionContent': 'B.sort-partition-combine-spill \n', 'isCorrect': '-1'}, {'optionContent': 'C.spill-sort-combine-partition \n', 'isCorrect': '-1'}, {'optionContent': 'D.partition-sort-combine-spill \n', 'isCorrect': '-1'}]","【答案解析】数据在缓冲区中会先分区，后排序，如果指定了Combiner，那么 排序之后才会进行合并，最后进行溢写。
","【正确答案】D
"
"6
、
下列关于机架感知策略，说法错误的是：
","[{'optionContent': 'A.HDFS中所谓的机架指的是逻辑机架而不是物理机架 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HDFS中的机架本质上是一个映射，可以利用Shell或者Python等脚本实现 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实际开发中，可以将一个或者多个物理机架上的节点映射在一个逻辑机架上 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HDFS中，不能将一个物理机架上节点映射在多个逻辑机架上 \n', 'isCorrect': '-1'}]","【答案解析】因为HDFS中的机架本质上是一个映射，所以可以将一个物理机架上的节点映射到不同的逻辑机架上，因此D错误。
","【正确答案】D
"
"7
、
HDFS（2.7版本）默认BlockSize是多大
","[{'optionContent': 'A.64MB \n', 'isCorrect': '-1'}, {'optionContent': 'B.128MB \n', 'isCorrect': '-1'}, {'optionContent': 'C.256MB \n', 'isCorrect': '-1'}, {'optionContent': 'D.512MB \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"8
、
在MapReduce中，能够将完全杂乱的数据变成有序数据是在下列哪一步发生的？
","[{'optionContent': 'A.缓冲区中的sort \n', 'isCorrect': '-1'}, {'optionContent': 'B.merge中的sort \n', 'isCorrect': '-1'}, {'optionContent': 'C.fetch \n', 'isCorrect': '-1'}, {'optionContent': 'D.group \n', 'isCorrect': '-1'}]","【答案解析】缓冲区的排序是将杂乱的数据整理成有序数据，merge过程中的排序是将局部有序整理成整体有序，fetch是抓取数据，group是将相同的键对应的值分到一组中
","【正确答案】A
"
"9
、
下列关于NameNode的职能描述错误的是：
","[{'optionContent': 'A.管理DataNode \n', 'isCorrect': '-1'}, {'optionContent': 'B.存储元数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.对外接收操作 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对数据进行切块 \n', 'isCorrect': '-1'}]","【答案解析】对数据进行切块是在客户端进行而不是NameNode负责，所以D错误。
","【正确答案】D
"
"10
、
以下不是Hadoop调度器的是？
","[{'optionContent': 'A.FIFO \n', 'isCorrect': '-1'}, {'optionContent': 'B.Capacity Scheduler \n', 'isCorrect': '-1'}, {'optionContent': 'C.Fair Scheduler \n', 'isCorrect': '-1'}, {'optionContent': 'D.Memory Scheduler \n', 'isCorrect': '-1'}]","【答案解析】比较流行的三种调度器有：默认调度器FIFO，计算能力调度器Capacity Scheduler，公平调度器Fair Scheduler默认调度器FIFOhadoop中默认的调度器，采用先进先出的原则计算能力调度器Capacity Scheduler选择占用资源小，优先级高的先执行公平调度器Fair Scheduler同一队列中的作业公平共享队列中所有资源
","【正确答案】D
"
"
11、
下列各项中不属于Shuffle的优化的是：
","[{'optionContent': 'A.适当增加Combiner过程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.增大缓冲区 \n', 'isCorrect': '-1'}, {'optionContent': 'C.增加fetch线程的数量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.指定sort的方式 \n', 'isCorrect': '-1'}]","【答案解析】Shuffle的调优常见的有以下几种方式：调大缓冲区；增大缓冲区阈值；引入combine过程；对final out文件进行压缩；增多fetch的线程数；降低ReduceTask的阈值；提高merge因子
","【正确答案】D
"
"
12、
下列关于MapReduce的分区机制，说法正确的是：
","[{'optionContent': 'A.在MapReduce中，分区的作用是将数据进行分门别类 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个分区可以对应多个ReduceTask \n', 'isCorrect': '-1'}, {'optionContent': 'C.分区的数量不影响结果文件的数量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.默认情况下，因为代码中没有显式的指定分区类，所以是不进行分区的 \n', 'isCorrect': '-1'}]","【答案解析】在MapReduce中，要求一个分区对应一个ReduceTask，而一个ReduceTask会产生一个结果文件，所以B、C错误。在默认情况下，如果不指定，则MapReduce中的分区类用的是HashPartitioner，所以D错误。
","【正确答案】A
"
"
13、
在Shuffle的merge过程中进行排序使用的排序方式是：
","[{'optionContent': 'A.冒泡排序 \n', 'isCorrect': '-1'}, {'optionContent': 'B.归并排序 \n', 'isCorrect': '-1'}, {'optionContent': 'C.快速排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.插入排序 \n', 'isCorrect': '-1'}]","【答案解析】merge过程中的排序是将局部有序数据变成整体有序，而冒泡、快速、插入排序都是讲杂乱数据整理成有序数据，效率较低
","【正确答案】B
"
"
14、
下列关于Block说法错误的是：
","[{'optionContent': 'A.Block是HDFS中数据存储的基本单位 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过dfs.blocksize来调节Block的大小 \n', 'isCorrect': '-1'}, {'optionContent': 'C.切块的意义之一是能够进行快速的备份 \n', 'isCorrect': '-1'}, {'optionContent': 'D.默认情况下，如果一个文件的大小是20M，则这个文件对应的Block大小是128M \n', 'isCorrect': '-1'}]","【答案解析】当一个文件不足一个Block大小的时候，则这个文件整体作为一个Block且文件大小就是Block的大小，所以D错误。
","【正确答案】D
"
"

15、
下列各项中，执行流程正确的是：
","[{'optionContent': 'A.InputFormat-Mapper-Reducer-OutputFormat \n', 'isCorrect': '-1'}, {'optionContent': 'B.Mapper-InputFormat-Reducer-OutputFormat \n', 'isCorrect': '-1'}, {'optionContent': 'C.InputFormat-Mapper-OutputFormat-Reducer \n', 'isCorrect': '-1'}, {'optionContent': 'D.Mapper-InputFormat-OutputFormat-Reducer \n', 'isCorrect': '-1'}]","【答案解析】在MapReduce 的计算过程中，应该是先利用InputFormat对文件进行切片读取数据，然后交给Mapper处理，之后交给Reducer进行规约，最后由OutputFormat来决定输出格式，输出到指定的位置。
","【正确答案】A
"
"
16、
Hadoop可以运行的模式不包括？
","[{'optionContent': 'A.单机模式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主从模式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.伪分布模式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.完全分布模式 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"
17、
Hadoop的NameNode的端口号是？
","[{'optionContent': 'A.70 \n', 'isCorrect': '-1'}, {'optionContent': 'B.30 \n', 'isCorrect': '-1'}, {'optionContent': 'C.60 \n', 'isCorrect': '-1'}, {'optionContent': 'D.56 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
18、
下列不属于Hadoop集群中hadoop进程的是？
","[{'optionContent': 'A.NameNode \n', 'isCorrect': '-1'}, {'optionContent': 'B.SecondaryNameNode \n', 'isCorrect': '-1'}, {'optionContent': 'C.MasterNode \n', 'isCorrect': '-1'}, {'optionContent': 'D.DataNode \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
19、
下列关于HDFS的回收站机制说法正确的是：
","[{'optionContent': 'A.默认情况下，HDFS的回收站机制是间隔1440min之后将数据清除 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过fs.trash.interval属性来调节回收间隔时间 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果需要还原回收站中的数据，需要通过hadoop fs -get命令进行还原 \n', 'isCorrect': '-1'}, {'optionContent': 'D.如果需要关闭回收站机制，可以通过dfs.trash.enabled属性来设置 \n', 'isCorrect': '-1'}]","【答案解析】在HDFS中，回收站机制默认是不开启，可以通过fs.trash.interval属性设置间隔时间来开启回收站机制，如果需要关闭回收站，则时间设置为0或者不设置即可，所以A、D错误，B正确。如果需要将回收站中的内容进行还原，可以通过hadoop fs -mv命令来操作，所以C错误。
","【正确答案】B
"
"
20、
下列各项中，关于SecondaryNameNode的说法正确的是：
","[{'optionContent': 'A.SecondaryNameNode是NameNode的热备份 \n', 'isCorrect': '-1'}, {'optionContent': 'B.SecondaryNameNode可以辅助NameNode完成edits文件的滚动 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果HDFS集群中不存在SecondaryNameNode，则无法完成edits文件的滚动 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SecondaryNameNode如果宕机会导致数据丢失 \n', 'isCorrect': '-1'}]","【答案解析】SecondaryNameNode只是辅助NameNode进行edits的滚动，但是不能对NameNode进行实时热备，所以A错误，B正确。在HDFS集群中，如果不存在SecondaryNameNode，则edits滚动由NameNode自己完成，所以C错误。因为SecondaryNameNode只是辅助NameNode进行edits的滚动，既不能进行实时热备又不存储具体数据，所以宕机也不会引起数据丢失，因此D错误。
","【正确答案】B
"
"
21、
下列关于Yarn的描述正确的是：
","[{'optionContent': 'A.Yarn的管理结构是ResourceManager直接管理具体的子任务 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ApplicationMaster如果划分出来5个MapTask以及2个ReduceTask，则会和ResourceManager申请7份资源 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果某一个MapTask出现异常退出，则ResourceManager会试图重启这个任务 \n', 'isCorrect': '-1'}, {'optionContent': 'D.提交的每一个job任务会对应一个ApplicationMaster \n', 'isCorrect': '-1'}]","【答案解析】Yarn的结构是ResourceManager管理ApplicationMaster，ApplicationMaster管理具体的子任务，而当子任务失败的时候，是由ApplicationMaster负责重新启动这个子任务，所以A、C错误。ApplicationMaster在和ResourceManager申请资源的时候是尽量多的申请，所以默认情况下，5个MapTask以及2个ReduceTask会申请17份资源，但是ResourceManager实际上会返回7份资源，所以B错误。
","【正确答案】D
"
"
22、
在dfs目录中，不包括的子目录是：
","[{'optionContent': 'A.data \n', 'isCorrect': '-1'}, {'optionContent': 'B.name \n', 'isCorrect': '-1'}, {'optionContent': 'C.namesecondary \n', 'isCorrect': '-1'}, {'optionContent': 'D.secondaryname \n', 'isCorrect': '-1'}]","【答案解析】dfs目录中包含3个子目录：data、name、namesecondary
","【正确答案】D
"
"
23、
下列关于副本的说法正确的是：
","[{'optionContent': 'A.默认情况下副本数量为3，即一个Block需要进行3次复制额外产生3个副本 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果第一个副本是集群内部上传，则谁上传就放在谁身上 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在Hadoop2.0的所有版本中，第二个副本都是和第一个副本放在同一个机架的节点上的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.副本的意义是为了能够保证数据不会丢失且减少数据的冗余 \n', 'isCorrect': '-1'}]","【答案解析】默认情况下副本数量为3，是指一个Block需要进行2次复制加上原来的Block一共构成3个副本，所以A错误。在Hadoop2.7版本以前，第二个副本是放在和第一个副本不同机架的节点上，所以C错误。Hadoop副本的出现虽然能够保证数据不丢失，但是相同的数据却要存储多份，此时是人为的制造冗余而不是减少冗余，所以D错误。
","【正确答案】B
"
"
24、
下列关于edits文件的滚动，说法正确的是：
","[{'optionContent': 'A.默认情况下，当edits文件大小达到128M的时候，会进行滚动 \n', 'isCorrect': '-1'}, {'optionContent': 'B.默认情况下，edits文件滚动的时间间隔是360s \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果NameNode因为网络隔离分裂出集群，那么当NameNode重新连入集群之后会产生edits文件的滚动 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以利用hadoop dfsadmin -rollEdits指令来进行强制滚动 \n', 'isCorrect': '-1'}]","【答案解析】默认情况下，当edits文件大小达到64M的时候会进行滚动，所以A错误。默认情况下，edits文件滚动的间隔时间为3600s，所以B错误。NameNode因为分裂而离开集群，之后重新连入集群并不会产生edits文件的改动，因为此时HDFS集群不会对外提供服务因此不产生新的元数据，而NameNode进行重启的时候才会产生edits文件的滚动，所以C错误。
","【正确答案】D
"
"25、
下列哪个程序通常与 NameNode 在一个节点启动？
","[{'optionContent': 'A.SecondaryNameNode \n', 'isCorrect': '-1'}, {'optionContent': 'B.DataNode \n', 'isCorrect': '-1'}, {'optionContent': 'C.TaskTracker \n', 'isCorrect': '-1'}, {'optionContent': 'D.JobTracker \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"
26、
下列关于MapReduce的序列化的说法错误的是：
","[{'optionContent': 'A.MapReduce之所以要求数据能够被序列化，是因为在计算过程中涉及到数据的存储和传输过程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.MapReduce的序列化采用的是Java原生序列化机制 \n', 'isCorrect': '-1'}, {'optionContent': 'C.MapReduce要求序列化的对象中的属性值不能为null \n', 'isCorrect': '-1'}, {'optionContent': 'D.MapReduce要求对应的类实现Writable接口之后才能被序列化 \n', 'isCorrect': '-1'}]","【答案解析】MapReduce在计算过程中，涉及到spill过程，涉及到MapTask和ReduceTask之间的通信问题，所以要求数据能够被序列化，因此A正确。MapReduce的序列化机制是在AVRO的基础上进行了封装，要求对应的类实现Writable接口，所以B错误，D正确。
","【正确答案】B
"
"
27、
下面哪个程序负责 HDFS 数据存储
","[{'optionContent': 'A.NameNode \n', 'isCorrect': '-1'}, {'optionContent': 'B.JobTracker \n', 'isCorrect': '-1'}, {'optionContent': 'C.DataNode \n', 'isCorrect': '-1'}, {'optionContent': 'D.SecondaryNameNode \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
28、
下列关于小文件的说法错误的是：
","[{'optionContent': 'A.在HDFS上存储小文件会产生大量元数据占用大量内存 \n', 'isCorrect': '-1'}, {'optionContent': 'B.每一个小文件会对应一个切片，则大量小文件会导致产生大量的MapTask \n', 'isCorrect': '-1'}, {'optionContent': 'C.目前对于小文件的处理手段只有合并 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hadoop Archive是Hadoop提供的一种原生的处理小文件的方式 \n', 'isCorrect': '-1'}]","【答案解析】目前市面上行对于小文件的处理手段有2种：合并和打包
","【正确答案】C
"
"
29、
关于MapReduce三个阶段的先后顺序，正确的是
","[{'optionContent': 'A.map shffle reduce \n', 'isCorrect': '-1'}, {'optionContent': 'B.shffle map reduce \n', 'isCorrect': '-1'}, {'optionContent': 'C.map reduce shffle \n', 'isCorrect': '-1'}, {'optionContent': 'D.reduce shffle map \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
30、
HDFS中，一个block的默认备份数量是？
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.4 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
31、
下列关于NameNode中，元数据的说法正确的是：
","[{'optionContent': 'A.在NameNode中，元数据只存储在磁盘中 \n', 'isCorrect': '-1'}, {'optionContent': 'B.元数据在磁盘上的存储位置由hadoop.tmp.dir属性来指定 \n', 'isCorrect': '-1'}, {'optionContent': 'C.fsimage中的元数据是实时的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.元数据中只包含文件信息、Block和DataNode之间的映射等内容 \n', 'isCorrect': '-1'}]","【答案解析】在NameNode中，元数据是存储在磁盘以及内存中的，所以A错误。元数据在产生变动的时候是先更新到内存中，此时fsimage中的元数据并没有发生改变，所以不是实时的，因此B错误。
","【正确答案】B
"
"
32、
在默认情况下，如果不指定，则使用的输入格式类是：
","[{'optionContent': 'A.FileInputFormat \n', 'isCorrect': '-1'}, {'optionContent': 'B.TextInputFormat \n', 'isCorrect': '-1'}, {'optionContent': 'C.KeyValueTextInputFormat \n', 'isCorrect': '-1'}, {'optionContent': 'D.NLineTextInputFormat \n', 'isCorrect': '-1'}]","【答案解析】默认情况下，使用的是TextInputFormat。FileInputFormat是TextInputFormat的父类，本身是一个抽象类。KeyValueTextInputFormat用于读取文本文件，如果行被分隔符（默认是\t）分割为两部分，第一部分为key，剩下的部分为value；如果没有分隔符，整行作为 key，value为空。NLineInputFormat是将文件以行为单位进行split，将文件的每一行对应一个mapper。得到的key是每一行的位置偏移量（LongWritable类型），value是每一行的内容，Text类型。适合于行数不多但是每一行的字段较多的场景
","【正确答案】B
"
"
33、
MapTask中，缓冲区设置为环形的目的是：
","[{'optionContent': 'A.减少阻塞 \n', 'isCorrect': '-1'}, {'optionContent': 'B.地址/空间复用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.减少磁盘交互 \n', 'isCorrect': '-1'}, {'optionContent': 'D.节省网络资源 \n', 'isCorrect': '-1'}]","【答案解析】缓冲区设置为环形是为了做到地址复用，减少寻址时间
","【正确答案】B
"
"

34、
在Hadoop集群中，Zookeeper的作用是：
","[{'optionContent': 'A.管理NameNode，对NameNode进行故障切换 \n', 'isCorrect': '-1'}, {'optionContent': 'B.管理DataNode，负责监控DataNode的运行情况 \n', 'isCorrect': '-1'}, {'optionContent': 'C.管理ResourceManager，负责对ResourceManager进行状态切换 \n', 'isCorrect': '-1'}, {'optionContent': 'D.管理JournalNode，负责监控JournalNode的运行情况 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper通过FailoverController进程对NameNode进行监控，负责NameNode的状态切换。
","【正确答案】A
"
"
35、
如果一个文件是650M，则在默认情况下，对应的Block和Split的个数为：
","[{'optionContent': 'A.5，5 \n', 'isCorrect': '-1'}, {'optionContent': 'B.5，6 \n', 'isCorrect': '-1'}, {'optionContent': 'C.6，5 \n', 'isCorrect': '-1'}, {'optionContent': 'D.6，6 \n', 'isCorrect': '-1'}]","【答案解析】在默认情况下，Block和Split的大小都是128M，但是需要注意的是在切片过程中由一个切片阈值1.1的问题，所以应该是产生6个Block以及5个Split
","【正确答案】C
"
"
多选题 （共计 10 题，总计 20分）
36、
下列关于MapReduce的排序机制，说法正确的是：
","[{'optionContent': 'A.在MapReduce中，默认的会对键进行排序 \n', 'isCorrect': '-1'}, {'optionContent': 'B.MapReduce中键所对应的类需要实现WritableComparable接口 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果两个键的比较结果为0，则两个键会被认为是同一个键，从而导致对应的值分到了一个组 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在排序过程中，只能对单个属性进行排序 \n', 'isCorrect': '-1'}]","【答案解析】MapReduce中，允许对多个属性进行排序，此时称之为二次排序，所以D错误。
","【正确答案】A,B,C
"
"
37、
下列关于数据倾斜的说法错误的是：
","[{'optionContent': 'A.数据倾斜本质原因是因为Shuffle过程中分区规则的不合理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.数据倾斜只会发生在Reduce端 \n', 'isCorrect': '-1'}, {'optionContent': 'C.目前为止，对于Reduce端的数据倾斜常用的解决方案为：二阶段聚合或者是join \n', 'isCorrect': '-1'}, {'optionContent': 'D.数据倾斜会导致MapReduce过程中产生慢任务从而降低效率 \n', 'isCorrect': '-1'}]","【答案解析】试题解析    数据倾斜的本质原因是因为数据本身就是不均匀的，具有倾斜特性，所以A错误。数据倾斜在Map端以及Reduce端都可能发生，所以B错误。
","【正确答案】A,B
"
"
38、
下列各项中，关于HDFS的安全模式说法正确的是：
","[{'optionContent': 'A.在安全模式中，HDFS不对外提供服务 \n', 'isCorrect': '-1'}, {'optionContent': 'B.当数据块的数量满足的最小副本数条件时，会自动退出安全模式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在伪分布式条件下的安全模式中，副本数量可以设置为3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.安全模式目的是在系统启动时检查各个DataNode上数据块的有效性 \n', 'isCorrect': '-1'}]","【答案解析】在安全模式中，HDFS对外提供读服务但是不提供写服务，所以A错误。在伪分布式条件下的安全模式中，因为存在副本数量的校验，考虑到副本放置策略问题，所以副本数量必须设置为1，因此C错误。
","【正确答案】B,D
"
"
39、
下列关于MapReduce的说法正确的是：
","[{'optionContent': 'A.MapReduce是Hadoop提供的一种原生的用于进行分布式计算的模型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.MapReduce将计算过程拆分为3个阶段：Map、Shuffle以及Reduce阶段 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在MapReduce中，Mapper的输出类型和Reducer的输入类型应该一致 \n', 'isCorrect': '-1'}, {'optionContent': 'D.MapReduce在处理数据的时候，会将数据进行切块 \n', 'isCorrect': '-1'}]","【答案解析】MapReduce是将计算过程拆分为2个阶段：Map和Reduce，而Shuffle只是Map阶段和Reduce阶段过程中的一个计算步骤，所以B错误。MapReduce在计算的时候是将数据进行切片而不是切块，切片是逻辑切分，切块是物理切分，所以D错误。
","【正确答案】B,D
"
"
40、
下列关于job执行流程的准备阶段中，包含的内容有：
","[{'optionContent': 'A.检查输入输出 \n', 'isCorrect': '-1'}, {'optionContent': 'B.计算切片 \n', 'isCorrect': '-1'}, {'optionContent': 'C.设置缓存存根 \n', 'isCorrect': '-1'}, {'optionContent': 'D.分配MapTask和ReduceTask \n', 'isCorrect': '-1'}]","【答案解析】Job在准备阶段会包含以下5个操作：检查输入输出路径，提交jar包和配置，计算切片，设置缓存存根以及提交提交jar包
","【正确答案】A,B,C
"
"
41、
大数据的特点包括：
","[{'optionContent': 'A.数据量大 \n', 'isCorrect': '-1'}, {'optionContent': 'B.数据增长速度快 \n', 'isCorrect': '-1'}, {'optionContent': 'C.数据价值密度大 \n', 'isCorrect': '-1'}, {'optionContent': 'D.数据的真实性 \n', 'isCorrect': '-1'}]","【答案解析】大数据的特点包括：数据量大，数据的种类和样式多，数据增长速度快，数据价值密度低，数据的真实性，连通性，以及动态性，可视化和合法性
","【正确答案】A,B,D
"
"
42、
下列属于Yarn的相关进程的是：
","[{'optionContent': 'A.ResourceManager \n', 'isCorrect': '-1'}, {'optionContent': 'B.JobTracker \n', 'isCorrect': '-1'}, {'optionContent': 'C.NodeManager \n', 'isCorrect': '-1'}, {'optionContent': 'D.ApplicationMaster \n', 'isCorrect': '-1'}]","【答案解析】Yarn中的进程包括：ResourceManager、NodeManager以及ApplicationMaster，而JobTracker在Hadoop2.0中就已经不再出现了。
","【正确答案】A,C,D
"
"
43、
下列关于HDFS的写流程，说法错误的是：
","[{'optionContent': 'A.客户端在写入数据的时候，会选择响应速度最快的节点来进行读取，即“最近”的节点 \n', 'isCorrect': '-1'}, {'optionContent': 'B.客户端需要自己连接对应的节点写入全部的三个副本 \n', 'isCorrect': '-1'}, {'optionContent': 'C.数据在写完之后就不能再进行修改了，但是可以继续追加 \n', 'isCorrect': '-1'}, {'optionContent': 'D.客户端在写完全部数据之后，会通知NameNode关闭文件 \n', 'isCorrect': '-1'}]","【答案解析】客户端在选择最近的节点，指的是网络拓扑距离最近，所以A错误。客户端在写入的时候只连接一个节点写入一个副本，其余副本由节点之间自动通过pipeline进行备份，所以B错误。HDFS支持的是一次写入多次读取，不支持修改但是支持追加写入，所以C正确。
","【正确答案】A,B
"
"
44、
下列关于删除流程的说法错误的是：
","[{'optionContent': 'A.客户端在收到ack信号之后，就表示数据此时已经真正从HDFS上移除了 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在DataNode发送心跳之后，NameNode会进行心跳响应，要求删除对应数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.DataNode在接收到心跳响应之后才会删除对应的Block \n', 'isCorrect': '-1'}, {'optionContent': 'D.客户端可以要求NameNode删除指定文件中的某段数据 \n', 'isCorrect': '-1'}]","【答案解析】NameNode在收到请求之后会记录操作修改内存中的元数据，然后给客户端返回ack表示删除成功给，此时只是修改了元数据但是没有真正删除Block，所以A错误。如果要求删除文件中的某段数据这是在对文件内容进行修改，但是HDFS中支持的是一次写入多次读取，不支持修改，所以D错误。
","【正确答案】A,D
"
"
45、
下列关于数据本地化策略的描述正确的是：
","[{'optionContent': 'A.数据本地化的目的是为了减少网络传输，提高效率 \n', 'isCorrect': '-1'}, {'optionContent': 'B.数据本地化的内容之一是TaskTracker要和DataNode部署在相同的节点上 \n', 'isCorrect': '-1'}, {'optionContent': 'C.数据本地化的内容之一是在分配MapTask的时候，哪个节点上有数据则分配给哪个节点 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ReduceTask无法满足数据本地化策略 \n', 'isCorrect': '-1'}]","【答案解析】数据本地化包含了两块内容：TaskTracker和DataNode在相同的节点上，MapTask分配给有数据的节点，这样子在处理数据的时候能够在本机上读取，减少对网络的消耗，所以A、B、C正确。因为ReduceTask的数据是MapTask的执行结果，而MapTask是分布在各个节点上的，所以ReduceTask无法满足数据本地化，因此D正确。
","【正确答案】A,B,C,D
"
"
46、
Hadoop中包含的模块有：
","[{'optionContent': 'A.MapReduce \n', 'isCorrect': '-1'}, {'optionContent': 'B.Ozone \n', 'isCorrect': '-1'}, {'optionContent': 'C.HDFS \n', 'isCorrect': '-1'}, {'optionContent': 'D.AVRO \n', 'isCorrect': '-1'}]","【答案解析】Hadoop目前包含的模块有HDFS，MapReduce，YARN，Ozone以及Submarine
","【正确答案】A,B,C
"
"
47、
下列各项中，属于DataNode的状态的是：
","[{'optionContent': 'A.服役 \n', 'isCorrect': '-1'}, {'optionContent': 'B.退役 \n', 'isCorrect': '-1'}, {'optionContent': 'C.活跃 \n', 'isCorrect': '-1'}, {'optionContent': 'D.备份 \n', 'isCorrect': '-1'}]","【答案解析】DataNode的状态移动有以下机中：预服役、服役、预退役、退役
","【正确答案】A,B
"
"
48、
下列关于job执行流程的说法，错误的是：
","[{'optionContent': 'A.JobTracker在分配任务的时候，会主动联系TaskTracker \n', 'isCorrect': '-1'}, {'optionContent': 'B.TaskTracker在领取到任务之后，会去对应的节点下载jar包，体现逻辑动数据定的思想 \n', 'isCorrect': '-1'}, {'optionContent': 'C.TaskTracker会在本节点内启动一个JVM子进程来执行任务 \n', 'isCorrect': '-1'}, {'optionContent': 'D.默认情况下，一个JVM子进程可以执行多个任务 \n', 'isCorrect': '-1'}]","【答案解析】JobTracker在划分好任务之后，会等待Task Tracker的心跳来分配任务，所以A错误。默认情况下，一个任务会开启一个JVM子进程，只有开启uber模式，才能做到JVM的宠用，所以D错误。
","【正确答案】A,D
"
"
49、
下列关于HDFS的读取流程，说法正确的是：
","[{'optionContent': 'A.在读取过程中，NameNode在收到客户端的请求之后，会从DataNode中读取数据然后返回给客户端 \n', 'isCorrect': '-1'}, {'optionContent': 'B.客户端在读取数据的时候，会选择响应速度最快的节点来进行读取，即“最近”的节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.客户端在读取完一个Block之后，会进行checksum的验证 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当读取完最后一个Block之后，客户端会通知NameNode关闭文件 \n', 'isCorrect': '-1'}]","【答案解析】在读取过程中，NameNode在收到请求之后给客户端返回的是Block地址而不是读取的数据，所以A错误。客户端在选择最近的节点，指的是网络拓扑距离最近，所以B错误。
","【正确答案】C,D
"
"
50、
下列关于NameNode和DataNode之间的心跳机制阐述中，说法正确的是：
","[{'optionContent': 'A.NameNode会主动给DataNode发送心跳要求存储数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.DataNode的心跳间隔是3s \n', 'isCorrect': '-1'}, {'optionContent': 'C.DataNode的心跳信息中包含了DataNode的状态以及Block信息 \n', 'isCorrect': '-1'}, {'optionContent': 'D.NameNode和DataNode之间的心跳是通过HTTP请求完成 \n', 'isCorrect': '-1'}]","【答案解析】在心跳机制中，NameNode会等待DataNode的心跳信息而不是主动给DataNode发送心跳，所以A错误。NameNode和DataNode之间的心跳是通过RPC方式进行通信而不是HTTP请求，所以D错误。
","【正确答案】B,C
"
"
51、
下列关于MapReduce中的Combiner机制阐述正确的是：
","[{'optionContent': 'A.Combiner能够有效的提高MapReduce的执行效率 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Combiner是保证结果不变从而减少数据总量 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Combiner的执行逻辑往往和Reducer是相同的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Combiner适合于任何场景下的MapReduce \n', 'isCorrect': '-1'}]","【答案解析】Combiner是将相同的键对应的值提前进行了合并，减少了shuffle过程中缓冲区和磁盘的交互，所以能够有效的提高效率，因此A正确。Combiner适合于进行求和、求最值等场景，但是如果进行求平均之类的运算，则不适合，所以D错误。
","【正确答案】A,B,C
"
"
52、
下列各项中，是HDFS的特点的是：
","[{'optionContent': 'A.可以存储超大文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以快速的应对和检测故障 \n', 'isCorrect': '-1'}, {'optionContent': 'C.不能存储小文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.标准的一致性模型 \n', 'isCorrect': '-1'}]","【答案解析】Hadoop的特点包含以下几条：支持超大文件；能够检测和快速应对硬件故障；流式数据访问；简化的一致性模型（即一次写入多次读取）；高容错性；可构建在廉价机器上；不能低延迟数据访问；不建议存储大量的小文件；不支持超强的事务。这个过程中需要注意，HDFS是不建议存储小文件，而不是不能存储小文件，所以C错误。
","【正确答案】A,B,D
"
"
53、
下列各项中说法正确的是：
","[{'optionContent': 'A.在执行hadoop namenode -format之后，hadoop.tmp.dir指定的路径下会产生dfs目录 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在格式化完成之后，name目录中会产生fsimage文件和edits文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在HDFS中，接收的每一个操作都会分配一个全局递增的编号，称之为是事务id \n', 'isCorrect': '-1'}, {'optionContent': 'D.edits_inprogress文件的作用是记录当前正在执行的事务文件。后面的编号是以上一次txid+1来命名的 \n', 'isCorrect': '-1'}]","【答案解析】hadoop namenode -format是格式化NameNode的指令，在格式化之后，会在指定的路径下产生dfs目录以及dfs的子目录name目录，在name的current目录中此时会包含fsimage、VERSION以及seen_txid三个文件，而在启动之后才会产生edits文件，所以A正确，B错误。在HDFS中，会对每一个接收的写操作分配一个全局递增的事务id，但是读操作不会产生事务id，所以C错误。
","【正确答案】A,D
"
"
54、
关于HDFS的说法错误的是：（）
","[{'optionContent': 'A.HDFS是Hadoop提供的一套用于进行分布式存储的体系 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HDFS包含的进程主要有NameNode、DataNode、SecondaryNameNode、ResourceManager以及NodeManager \n', 'isCorrect': '-1'}, {'optionContent': 'C.HDFS在存储数据的时候会将数据进行切片 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HDFS能够有效保证数据的完整性 \n', 'isCorrect': '-1'}]","【答案解析】HDFS是Hadoop提供的一套分布式的可扩展的存储体系，所以A正确。HDFS中的进程包含NameNode、DataNode、SecondaryNameNode三个，而不包含ResourceManager和NodeManager，所以B错误。HDFS在存储数据的时候是将数据进行切块而不是切片，所以C错误。HDFS会自动的对数据进行备份以保证数据不丢失从而保证数据的完整性，所以D正确。
","【正确答案】B,C
"
"

高并发基础
单选题 （共计 10 题，总计 20分）
1、Zookeeper集群中的一台服务器出现那种情况时需要进行选举？
","[{'optionContent': 'A.服务器初始化启动。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.非Leader服务器宕机或无法联系。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.新的服务器添加 \n', 'isCorrect': '-1'}, {'optionContent': 'D.服务器负载超出服务器能力范围 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举。　　(1) 服务器初始化启动。　　(2) 服务器运行期间无法和Leader保持连接。
","【正确答案】A
"
"2、下列关于红黑树的说法正确的是：
","[{'optionContent': 'A.红黑树本质上是一棵二叉树 \n', 'isCorrect': '-1'}, {'optionContent': 'B.红黑树适合于增删多而查询少的场景 \n', 'isCorrect': '-1'}, {'optionContent': 'C.红黑树的查询时间复杂度是nlog(n) \n', 'isCorrect': '-1'}, {'optionContent': 'D.在红黑树中，新添的节点的颜色可以是黑色的 \n', 'isCorrect': '-1'}]","【答案解析】红黑树是一棵自平衡二叉查找树的体现，是二叉树的一种，所以A正确。因为在红黑树中新添节点可能会导致红黑树自平衡的修正，但是查找却相对快速，所以红黑树适合于查询多而增删少的场景，因此B错误。红黑树的查询时间复杂度是Olog(n)，所以C错误。在红黑树中，新添的节点一定是红节点，因为如果是黑节点则会导致黑节点的高度不一致，所以D错误
","【正确答案】A
"
"3、Znode的数据节点不包括？
","[{'optionContent': 'A.持久节点 \n', 'isCorrect': '-1'}, {'optionContent': 'B.临时节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.持久顺序节点 \n', 'isCorrect': '-1'}, {'optionContent': 'D.自建顺序节点 \n', 'isCorrect': '-1'}]","【答案解析】PERSISTENT-持久节点除非手动删除，否则节点一直存在于Zookeeper上EPHEMERAL-临时节点临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。PERSISTENT_SEQUENTIAL-持久顺序节点基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。EPHEMERAL_SEQUENTIAL-临时顺序节点基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
","【正确答案】D
"
"4、下列关于ConcurrentHashMap的说法错误的是：
","[{'optionContent': 'A.ConcurrentHashMap本身是一个异步式线程安全的映射 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在JDK1.7中，ConcurrentHashMap底层采用的是数组+红黑树机制来存储数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在JDK1.8之前，ConcurrentHashMap采用了分桶锁机制来保证其线程安全性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在使用ConcurrentHashMap的时候，如果指定了初始容量为5，则实际容量为8 \n', 'isCorrect': '-1'}]","【答案解析】在JDK1.8之前，ConcurrentHashMap底层采用了分段锁机制来保证其异步以及安全的特点，所以A，C正确。ConcurrentHashMap的红黑树机制是JDK1.8引入的，所以B错误。在ConcurrentHashMap中，如果指定初始容量为n，且2^x<=n<2^(x+1)，则实际初始容量为2^(x+1)。所以如果初始容量指定为5，因为4<5<8，即2^2<5<2^3，所以实际初始容量为8，因此D正确。
","【正确答案】B
"
"5、Zookeeper保证了如下分布式一致性特性，其中那一项是不正确的？
","[{'optionContent': 'A.顺序一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.原子性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可靠性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.多视图 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper保证了如下分布式一致性特性：顺序一致性原子性单一视图可靠性实时性（最终一致性）
","【正确答案】D
"
"6、下列关于RPC的说法错误的是：
","[{'optionContent': 'A.RPC全称是远程过程调用，是一种进程间的通信方式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.RPC允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节 \n', 'isCorrect': '-1'}, {'optionContent': 'C.RPC中，一般利用接口作为存根 \n', 'isCorrect': '-1'}, {'optionContent': 'D.RPC的特点是复杂高效且只能用于特定的场景 \n', 'isCorrect': '-1'}]","【答案解析】RPC的特点是简单、通用、高效，所以D错误。
","【正确答案】D
"
"7、红黑树以下性质错误的是
","[{'optionContent': 'A.每个结点要么是红的，要么是黑的。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.根节点是红的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果一个结点是红的，那么它的俩个儿子都是黑的。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"8、下列关于锁的说法正确的是：
","[{'optionContent': 'A.Lock锁默认采用的是公平策略 \n', 'isCorrect': '-1'}, {'optionContent': 'B.读锁只允许一个线程读取但是不允许线程写入 \n', 'isCorrect': '-1'}, {'optionContent': 'C.写锁只允许一个线程写入但是不允许线程读取 \n', 'isCorrect': '-1'}, {'optionContent': 'D.公平策略的效率比非公平策略的效率要高 \n', 'isCorrect': '-1'}]","【答案解析】因为公平策略的效率要低于非公平策略，所以Lock默认采用的是非公平策略，因此A、D错误。读写锁的特点是读锁允许多个线程同时读取但是不允许写入，而写锁允许一个线程写入但是不允许读取，所以B错误，C正确。
","【正确答案】C
"
"9、下列关于序列化的说法正确的是：
","[{'optionContent': 'A.序列化指的是将数据转化为指定的格式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.序列化的目的是数据的转化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.序列化的衡量标准是代码是否简洁 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Java原生的序列化机制能够做到跨语言跨平台 \n', 'isCorrect': '-1'}]","【答案解析】序列化是指按照指定的要求将数据转化为指定的格式，转化之后要考虑数据的存储和传输，所以A正确，B错误。序列化的衡量标准主要有3个：占用资源量，序列化之后的数据量以及能够跨平台跨语言，但是不包括代码是否简洁，所以C错误。Java原生的序列化机制能够跨平台但是不能够跨语言，所以D错误。
","【正确答案】A
"
"10、下列关于Zookeeper的各项配置中，描述正确的是：
","[{'optionContent': 'A.默认情况下，initLimit的值为10*tickTime，即默认follower在启动之后，需要在10s中之内完成数据的同步 \n', 'isCorrect': '-1'}, {'optionContent': 'B.默认情况下，syncLimit的值为5*tickTime，即默认leader在给follower发送信息之后，会在5s内等待follower的反馈结果 \n', 'isCorrect': '-1'}, {'optionContent': 'C.globalOutStandingLimit表示最大请求堆积数，表示leader最多能临时存储的请求个数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.server.x=hostname:IP1:IP2，其中IP1是选举端口，IP2是原子广播的端口 \n', 'isCorrect': '-1'}]","【答案解析】在默认情况下，tickTime=2000ms，即2s，所以initLimit=10*tickTime=20s，syncLimit=5*tickTime=10s，所以A、B错误。server.x=hostname:IP1:IP2中，IP1是原子广播端口，IP2是选举端口，所以D错误。
","【正确答案】C
"
"多选题 （共计 10 题，总计 20分）
11、下列各项中，是Zookeeper的节点类型的是：
","[{'optionContent': 'A.PERSISTENT \n', 'isCorrect': '-1'}, {'optionContent': 'B.EPHEMERAL \n', 'isCorrect': '-1'}, {'optionContent': 'C.PERSISTENT_SEQUENTIAL \n', 'isCorrect': '-1'}, {'optionContent': 'D.EPHEMERAL_SEQUENTIAL \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper中节点一共有4种：PERSISTENT：持久节点EPHEMERAL：临时节点PERSISTENT_SEQUENTIAL：持久顺序节点EPHEMERAL_SEQUENTIAL：临时顺序节点
","【正确答案】A,B,C,D
"
"12、下列关于NIO的说法正确的是：
","[{'optionContent': 'A.NIO是JDK1.4提供的一种异步阻塞式IO \n', 'isCorrect': '-1'}, {'optionContent': 'B.NIO的作用是用于完成数据的传输 \n', 'isCorrect': '-1'}, {'optionContent': 'C.NIO中包含三大组件：Buffer，Channel以及Selector \n', 'isCorrect': '-1'}, {'optionContent': 'D.NIO在使用的时候可以基于事件驱动模式来实现 \n', 'isCorrect': '-1'}]","【答案解析】NIO是JDK1.4所提供的一种同步式阻塞式IO，而异步式阻塞式IO是JDK1.8提供的AIO，所以A错误。无论是传统的BIO，或者是非阻塞的NIO还是最新的AIO，其作为IO流的作用都是用于完成数据的传输，所以B正确。NIO包含三大组件：Buffer用于数据的存储，Channel用于数据的传输，Selector用于通道的选择，所以C正确。NIO中的Selector是基于事件机制来实现的，而其在服务器端所提供的事件主要是有三种：accept、read、write，所以D正确。
","【正确答案】B,C,D
"
"13、Zookeeper集群中，节点状态包括：
","[{'optionContent': 'A.voting \n', 'isCorrect': '-1'}, {'optionContent': 'B.leader \n', 'isCorrect': '-1'}, {'optionContent': 'C.follower \n', 'isCorrect': '-1'}, {'optionContent': 'D.standalone \n', 'isCorrect': '-1'}]","【答案解析】在Zookeeper集群中，节点状态包括4种：looking/voting、follower、leader、observer，而standalone是Zookeeper的单机模式中的节点状态而不是集群中的节点状态，所以A，B，C正确，D错误。
","【正确答案】A,B,C
"
"14、下列关于线程池的说法错误的是：
","[{'optionContent': 'A.线程池的意义是提高线程的利用率，减少线程的创建和销毁 \n', 'isCorrect': '-1'}, {'optionContent': 'B.利用线程池可以使服务器端的并发压力降低从而提高服务器的并发性能 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在线程池中，即使核心线程未满，但是如果有空闲的核心线程，则新来的请求会交给空闲的核心线程 \n', 'isCorrect': '-1'}, {'optionContent': 'D.核心线程在使用完成之后会被销毁 \n', 'isCorrect': '-1'}]","【答案解析】线程池的目的是为了通过减少线程的创建和销毁从而提高线程的利用率，并且核心线程在使用完成之后不会被销毁而是会等待下一个请求，所以A正确，D错误。由于线程池的存在，是的服务器端可以利用少量线程去处理大量请求，所以能够一定程度的提高服务器的并发性能，因此B正确。在线程池中，如果核心线程未满，即使有空闲的核心线程，新来的请求也会在线程池中创建一个对应的核心线程而不是交给空闲的核心线程，直到所有的核心线程被创建满为止，所以C错误。
","【正确答案】C,D
"
"15、下列关于BlockingQueue的说法错误的是：
","[{'optionContent': 'A.BlockingQueue适用于生产消费模型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在BlockingQueue中，如果队列满了，则再利用put方法添加元素的时候会抛出异常 \n', 'isCorrect': '-1'}, {'optionContent': 'C.PriorityBlockingQueue在利用迭代器遍历的时候能够保证排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.BlockingQueue遵循”两端放入两端拿取“的原则 \n', 'isCorrect': '-1'}]","【答案解析】BlockingQueue的特点有2个：FIFO以及阻塞，在队列为空的时候试图获取会被阻塞，在队列满了之后试图添加会被阻塞，而这两个特性很适合于生产消费场景，所以A正确。在BlockingQueue中，队列已满，利用put方法添加元素会产生阻塞，而利用add方法添加会抛出异常，所以B错误。PriorityBlockingQueue只有逐个拿取可以保证排序，如果利用迭代器遍历则不保证排序，所以C错误。BlockingQueue遵循FIFO的选择，而”两端放入两端拿取”是BlockingDeque的特点，所以D错误。
","【正确答案】B,C,D
"
"16、下列关于分叉合并的说法正确的是：
","[{'optionContent': 'A.分叉合并的目的是为了提高CPU的利用率 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在分叉合并中，如果一个核上的线程执行完成会空闲下来等待其他核上的线程执行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.无论数据量大小，分叉合并的效率都会高于循环的效率 \n', 'isCorrect': '-1'}, {'optionContent': 'D.分叉合并可以有效的提高CPU核的使用量 \n', 'isCorrect': '-1'}]","【答案解析】分叉合并通过增加使用核的数量来提高CPU的利用率，所以A、D正确。在分叉合并中，如果一个核上的所有的任务执行完成之后，会利用工作窃取策略去其他核上偷取任务，因此并不会空闲下来，所以B错误。分叉合并适合于数据量较大的时候，在数据量小的时候利用分叉合并的效率反而低于循环，所以C错误。
","【正确答案】A,D
"
"17、下列关于Callable的说法错误的是：
","[{'optionContent': 'A.Callable中的泛型表示的是参数类型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Callable需要有返回值，而Runnable没有返回值 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Callable线程和Runnable线程一样可以通过Thread类来启动 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Callable线程中的异常可以通过全局方式来进行处理 \n', 'isCorrect': '-1'}]","【答案解析】Callable需要一个返回值，所以泛型表示的是返回值的类型而不是参数的类型，因此A错误，B正确。Callable线程只能通过线程池启动，而Runnable可以通过Thread类或者线程池来启动，所以C错误。因为Callable中的call方法允许抛出异常，所以可以通过全局方式来处理异常，因此D正确。
","【正确答案】A,C
"
"18、下列关于NIO的说法错误的是：
","[{'optionContent': 'A.因为NIO是非阻塞式IO，所以NIO用于数据传输的Channel默认是非阻塞的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.NIO中的Selector是面向通道进行选择，且要求通道非阻塞 \n', 'isCorrect': '-1'}, {'optionContent': 'C.NIO中，利用Selector可以实现一对多的连接 \n', 'isCorrect': '-1'}, {'optionContent': 'D.NIO中的Selector适用于长任务场景 \n', 'isCorrect': '-1'}]","【答案解析】虽然NIO是同步非阻塞式IO，但是NIO中的Channel默认是阻塞的，需要通过configureBlocking方法来手动设置为非阻塞，所以A错。NIO中要求Selector所选择的通道必须是非阻塞的，不然无法完成选择过程以及一对多的连接过程，所以B，C正确。如果利用NIO来完成长任务，会导致后续的任务等待时间过程从而产生任务积压，因此NIO适合于高并发短任务场景而不是长任务场景，所以D错误。
","【正确答案】A,D
"
"19、下列关于observer的说法错误的是：
","[{'optionContent': 'A.observer的特点是不参与选举不参与投票也不监听结果 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果一个集群中有15个节点，其中有8个observer，则称为leader的节点需要胜过至少3个节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.设置observer可以减少网络对投票结果的影响 \n', 'isCorrect': '-1'}, {'optionContent': 'D.如果一个集群中有21个节点，其中有14个observer，那么如果有12个observer宕机，则集群就不会在对外提供服务 \n', 'isCorrect': '-1'}]","【答案解析】observer的忒但是不参与投票不参与选举，但是会监听投票以及选举结果，根据结果执行对应的操作，所以A错误。在Zookeeper集群中，observer不参与投票和选举，因此observer的存活与否不影响集群是否对外操作，而D选项中因为宕机的是12个observer，所以不影响结果，因此D错误。一个节点想要成为leader，只要在参与投票的节点中胜过一半就可以；所以B选项中实际上只有7个节点参与投票，而leader只要胜过3个节点（加上自己本身是4个几点恰好过半）就可以成功，因此B正确。observer适用于网络状态不好的情况下，能够减少因为网络而带来的问题，所以C选项正确。
","【正确答案】A,D
"
"20、下列各项中是Zookeeper的特点的是：
","[{'optionContent': 'A.Zookeeper本身是一棵树状结构 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在Zookeeper中存在相对路径 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在Zookeeper中任意一个节点都可以挂载子节点 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Zookeeper中的路径是唯一的 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper本身是一棵树状结构，并且所有的路径都是以/作为根路径，不存在相对路径并且路径唯一，所以A、D正确，B错误。在Zookeeper中，任意一个持久节点下可以挂载子节点而临时节点下不能挂载子节点，所以C错误。
","【正确答案】A,D
"
"21、下列各项中，关于Zookeeper的节点信息描述正确的是：
","[{'optionContent': 'A.czxid表示的是节点被修改的事务id \n', 'isCorrect': '-1'}, {'optionContent': 'B.cversion表示的是节点被修改的编号 \n', 'isCorrect': '-1'}, {'optionContent': 'C.dataversion表示的是节点数据的修改次数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ephemeralOwner如果为0，则表示当前节点是临时节点 \n', 'isCorrect': '-1'}]","【答案解析】cZxid：创建该节点所分配的全局事务idctime：创建时间mZxid：更新该节点数据所分配的全局事务idmtime：更新时间pZxid：子节点的最新事务idcversion：子节点版本，表示对子节点的更改次数dataversion：数据版本，数据每发生一次变化，数据版本增加1aclVersion：ACL的更新次数，实际上是权限更新的次数ephemeralOwner：如果不是临时节点，则此值为0；如果是临时节点，则此值是其会话iddataLength：数据的字节个数numChildren：子节点的个数
","【正确答案】C
"
"22、下列关于原子广播的说法错误的是：
","[{'optionContent': 'A.原子广播的主要作用是解决数据的一致性问题 \n', 'isCorrect': '-1'}, {'optionContent': 'B.原子广播是基于2PC算法进行实现 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在原子广播中，只要一个follower返回了no给leader，则leader会命令所有的节点都放弃执行这个操作 \n', 'isCorrect': '-1'}, {'optionContent': 'D.原子广播过程中，能够有效的保证操作提交的顺序性 \n', 'isCorrect': '-1'}]","【答案解析】原子广播能够保证所有节点的操作一致从而保证数据的一致性，所以A正确。原子广播是基于了2PC算法进行实现，但是采取了过半性进行改进，所以B正确，C错误。在原子广播过程中，leader接收到操作之后会将操作放入队列发送给follower，所以能够有效的保证操作接收和提交的顺序性，因此D正确。
","【正确答案】C
"
"23、下列关于BlockingQueue的说法正确的是：
","[{'optionContent': 'A.LinkedBlockingQueue在使用的时候如果不指定容量，则容量可以随意变化是无界的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ArrayBlockingQueue底层是基于链表来存储数据的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.PriorityBlockingQueue在使用的时候，要求所存储的元素对应的类需要实现Comparator接口 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SynchronousQueue的容量默认为1 \n', 'isCorrect': '-1'}]","【答案解析】LinkedBlockingQueue在使用的时候如果不指定容量，则默认容量是Integer.MAX_VALUE，此时依然是有界限的，所以A错误ArrayBlockingQueue底层是基于数组来存储数据，所以B错误PriorityBlockingQueue在使用的时候要求所存储的元素对应的类实现Comparable接口而不是Comparator接口，所以C错误SynchronousQueue的容量默认为1并且只能为1，所以D正确
","【正确答案】D
"
"24、下列关于分布式的阐述错误的是：
","[{'optionContent': 'A.在分布式集群中，需要确定管理集群来保证集群的运行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在分布式的管理集群中，需要考虑数据的一致性问题 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在分布式环境中，不会出现死锁问题 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在分布式集群中，需要确定有效的选举算法来选举主节点 \n', 'isCorrect': '-1'}]","【答案解析】在分布式中，需要引入管理节点，但是单一的管理节点容易存在单点故障，所以需要引入管理集群，所以A正确。因为引入了管理集群，所以如果数据只存在管理集群的某一个节点上，容易导致数据的丢失，因此需要考虑所有节点的数据的一致性问题保证数据不丢失，因此B正确。在分布式环境中，死锁以及活锁都是经常出现的问题，所以C错误。在管理集群中，需要确定一个主节点来对外接受操作以及对内进行统一命令，所以需要确定一套有效的选举算法，因此D正确。
","【正确答案】C
"
"25、下列关于跳跃表的说法正确的是：
","[{'optionContent': 'A.跳跃表适合于查询多而增删少的场景 \n', 'isCorrect': '-1'}, {'optionContent': 'B.跳跃表是一种典型的以时间换空间的产物 \n', 'isCorrect': '-1'}, {'optionContent': 'C.跳跃表中新添加的元素一定要提取到上层的跳跃表 \n', 'isCorrect': '-1'}, {'optionContent': 'D.跳跃表的查询时间复杂度是nlog(n) \n', 'isCorrect': '-1'}]","【答案解析】跳跃表是一种典型的以空间换时间的产物，利用大量的内存来提高查询效率，因此适合于查询多而增删少的场景，因此A正确B错误。在跳跃表中新添加的元素是否提取到上层的跳跃表中要遵循抛硬币原则，所以C错误。跳跃表的查询时间复杂度是log(n)，所以D错误。
","【正确答案】A
"
"26、下列各项特性中，不是Zookeeper特性的是：
","[{'optionContent': 'A.数据一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.实时性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可靠性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.随机性 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper的特性一共有6个：数据一致性、原子性、可靠性、实时性、顺序性以及过半性，所以A、B、C正确，D错误
","【正确答案】D
"
"27、Zookeeper中，每一个节点发送的选举信息不包括的内容是：
","[{'optionContent': 'A.最大事务id \n', 'isCorrect': '-1'}, {'optionContent': 'B.选举id \n', 'isCorrect': '-1'}, {'optionContent': 'C.逻辑时钟值 \n', 'isCorrect': '-1'}, {'optionContent': 'D.节点IP \n', 'isCorrect': '-1'}]","【答案解析】选举信息包括：最大事务id，myid（即选举id），逻辑时钟值。
","【正确答案】D
"
"28、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
","[{'optionContent': 'A.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？ \n', 'isCorrect': '-1'}, {'optionContent': 'B.直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.调用run()方法会导致Java虚拟机抛出异常。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.调用run()方法是，会造成线程阻塞，导致程序无法运行。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A,B
"
"29、下列关于Zookeeper的说法正确的是：
","[{'optionContent': 'A.Zookeeper的节点个数一般为奇数个 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在Zookeeper集群中，如果新添加的节点的myid比leader的myid要大，那么新添加的节点会称为leader \n', 'isCorrect': '-1'}, {'optionContent': 'C.Zookeeper中的过半性能够有效防止脑裂 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在Zookeeper中，每一个leader都会产生一个递增的编号 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper的节点个数一般为奇数个，目的是为了使Zookeeper集群在操作过程中容易满足过半性，所以A正确。在Zookeeper集群中，一旦选举出来leader，那么后续添加的节点的事务id以及myid无论是多少，都会称为follower，所以B错误。如果集群产生了分裂，而集群中剩余节点个数不过半数的时候，那么这些节点不选举也不服务，能够有效的防止脑裂，所以C正确。每一个leader产生之后都会分配一个递增的编号，称之为epochid，所以D正确。
","【正确答案】A,C,D
"
"30、ZAB协议包括以下：
","[{'optionContent': 'A.原子广播 \n', 'isCorrect': '-1'}, {'optionContent': 'B.轮询调度 \n', 'isCorrect': '-1'}, {'optionContent': 'C.崩溃恢复 \n', 'isCorrect': '-1'}, {'optionContent': 'D.实时监控 \n', 'isCorrect': '-1'}]","【答案解析】ZAB协议是针对Zookeeper所专门设计的一套用于原子广播和崩溃恢复的协议
","【正确答案】A,C
"
"31、关于Zookeeper的选举机制，说法错误的是：
","[{'optionContent': 'A.所有的Zookeeper节点在选举刚开始的时候会选举自己成为leader \n', 'isCorrect': '-1'}, {'optionContent': 'B.选举过程中会先比较最大事务id，如果最大事务id一致再比较myid \n', 'isCorrect': '-1'}, {'optionContent': 'C.在刚开始选举的时候，所有的节点都是follower状态 \n', 'isCorrect': '-1'}, {'optionContent': 'D.如果一个节点想要成为leader，则这个节点需要胜过至少一半的节点才能选举成功 \n', 'isCorrect': '-1'}]","【答案解析】在Zookeeper中，每一个节点刚开始都会选举自己称为leader并且发送自己的选举信息，而此时所有的节点都处于looking/voting状态，在收到选举信息之后会进行比较，先比较最大事务id，最大事务id一致则比较myid，而最后称为leader的节点需要满足过半性，因此A，B，D正确，C错误。
","【正确答案】C
"
"32、假设数据量为n，则红黑树的各种操作的时间复杂度是多少？
","[{'optionContent': 'A.O(n) \n', 'isCorrect': '-1'}, {'optionContent': 'B.O(lgn) \n', 'isCorrect': '-1'}, {'optionContent': 'C.O(n^2) \n', 'isCorrect': '-1'}, {'optionContent': 'D.O(nlg(n)) \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"33、如果一个Zookeeper集群中，现在的事务id为0x2，此时发生了如下操作：
create /news ‘’
create /news/n01 ‘’
create /log ‘’
set /news ‘’
delete /news/n01
get /news
则news节点的mZxid是：
","[{'optionContent': 'A.0x5 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0x6 \n', 'isCorrect': '-1'}, {'optionContent': 'C.0x7 \n', 'isCorrect': '-1'}, {'optionContent': 'D.0x8 \n', 'isCorrect': '-1'}]","【答案解析】在Zookeeper中，事务id是用于记录全局写操作发生的事务id。而本题中，起始id为2，mZxid表示的是节点数据被修改的事务id，而news节点的数据被修改操作是set /news ‘’，是全局第6个操作，所以事务id为0x6，因此B正确
","【正确答案】B
"
"34、下列各项中，关于崩溃恢复的说法错误的是：
","[{'optionContent': 'A.崩溃恢复包含leader丢失之后会选举出新的leader从而保证集群的正常运行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.崩溃恢复包含节点宕机重启之后能够找回数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.崩溃恢复能够有效的保证集群的可用性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.崩溃恢复中依然存在单点故障 \n', 'isCorrect': '-1'}]","【答案解析】崩溃恢复主要包含两个方面的内容：leader丢失之后的再选举以及数据的找回，所以A、B正确。因为崩溃恢复保证leader丢失之后会再选举出一个新的leader，所以不会因为一个leader丢失就导致集群无法服务，有效的避免了单点故障，保证了集群的可用性，所以C正确，D错误。
","【正确答案】D
"
"35、下列关于Zookeeper的过半性，说法正确的是：
","[{'optionContent': 'A.在选举过程中，只有一个节点胜过半数及以上的节点的时候才会称为leader \n', 'isCorrect': '-1'}, {'optionContent': 'B.在Zookeeper集群中，只有有一半以上的节点存活的时候才能对外提供服务 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在原子广播过程中，只有半数以上的follower返回yes才能执行操作 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在Zookeeper集群中，只有有一半及以上的节点存活的时候才能进行选举 \n', 'isCorrect': '-1'}]","【答案解析】Zookeeper的过半性包括过半选举、过半服务以及过半操作
","【正确答案】A,B,C,D
"
"36、下列关于Buffer的阐述正确的是：
","[{'optionContent': 'A.Buffer本质上是利用数组完成数据的存储且针对八种基本类型提供了对应的子类 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Buffer中有四个重要的位置：position，capacity，mark，limit，其中大小关系为mark<=position<=limit<=capacity \n', 'isCorrect': '-1'}, {'optionContent': 'C.Buffer在创建好之后可以随着数据的大小而动态改变 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Buffer中的flip操作表示重绕缓冲区 \n', 'isCorrect': '-1'}]","【答案解析】Buffer底层是利用了数组进行存储，但是针对八种基本类型只提供了七种子类，其中没有针对boolean类型提供子类，所以A错误。在Buffer，mark是标记位，用于标记已经操作的位置，所以不能超过操作位；position是操作位，用于指向要操作的位置，而limit是限制位，用于限定position所能达到的最大位置，所以position<=limit，而capacity是容量位，用于指定容量，在缓冲区创建之初，limit指向容量位，所以B正确。Buffer底层的数组使用final修饰的，所以在Buffer创建好之后容量就不能动态改变了，因此C错误。Buffer中flip表示翻转缓冲区，而重绕缓冲区是rewind操作，所以D错误。
","【正确答案】B
"
"37、下列关于NIO与BIO的叙述中，说法错误的是：
","[{'optionContent': 'A.NIO是非阻塞式IO，BIO是阻塞式IO \n', 'isCorrect': '-1'}, {'optionContent': 'B.NIO和BIO一样，都是一对一的连接方式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.NIO基于Channel可以实现双向传输，而BIO是单向传输的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.NIO适合于高并发短任务场景，而BIO适合于连接少长任务场景 \n', 'isCorrect': '-1'}]","【答案解析】NIO是JDK1.4提供的一种同步式非阻塞式IO，BIO是Java提供的一种同步式阻塞式IO，所以A正确。与BIO不同的一点在于，NIO利用Selector进行选择，使用一个或者少量线程处理大量请求，所以NIO是一种一对多的连接方式，所以B错误。NIO中Channel可以实现双向传输，而BIO因为要区分方向来确定是使用输入流还是输出流，所以是单向传输，所以C正确。因为NIO是利用一对多的方式来处理数据，所以如果是长任务场景，则会导致靠后的任务需要等待的事件比较长，所以NIO适合于高并发短任务场景；而因为BIO是一对一的连接，所以如果是高并发场景会导致在服务器端产生的线程量比较多从而加剧服务器的并发压力，所以BIO适合于连接少的长任务场景，所以D正确。
","【正确答案】B
"
"38、关于server.x=IP:2888:3888的表述，错误的是：
","[{'optionContent': 'A.x表示的是myid \n', 'isCorrect': '-1'}, {'optionContent': 'B.x可以一致 \n', 'isCorrect': '-1'}, {'optionContent': 'C.2888表示的原子广播端口 \n', 'isCorrect': '-1'}, {'optionContent': 'D.3888表示的是选举端口 \n', 'isCorrect': '-1'}]","【答案解析】因为x表示myid，在选举过程中需要进行比较，所以不能配置的一样，因此B错误。
","【正确答案】B
"
"39、ZooKeeper的每个节点的存放数据上限为：
","[{'optionContent': 'A.256KB \n', 'isCorrect': '-1'}, {'optionContent': 'B.512KB \n', 'isCorrect': '-1'}, {'optionContent': 'C.1MB \n', 'isCorrect': '-1'}, {'optionContent': 'D.2MB \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"


EASYMALL电商项目
1、
拆分子系统，子系统之间可以使用下面那个类来进行http协议通信
","[{'optionContent': 'A.RestTemplate \n', 'isCorrect': '-1'}, {'optionContent': 'B.HttpTemplate \n', 'isCorrect': '-1'}, {'optionContent': 'C.TCPTemplate \n', 'isCorrect': '-1'}, {'optionContent': 'D.UDPTemplate \n', 'isCorrect': '-1'}]","【答案解析】RestTemplate是springmvc的对象,支持REST风格的http协议封装
","【正确答案】A
"
"
多选题 （共计 2 题，总计 4分）
2、
在easymall中redis的作用有哪些
","[{'optionContent': 'A.实现了商品的缓存功能 \n', 'isCorrect': '-1'}, {'optionContent': 'B.实现了发送验证码的存储功能 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实现了用户登录逻辑的用户状态存储 \n', 'isCorrect': '-1'}, {'optionContent': 'D.实现了内存的锁机制解决商品更新和查询高并发下数据不一致问题 \n', 'isCorrect': '-1'}]","【答案解析】见题干描述
","【正确答案】A,C,D
"
"
3、
秒杀逻辑描述正确的是
","[{'optionContent': 'A.将请求封装成消息放到消息队列 \n', 'isCorrect': '-1'}, {'optionContent': 'B.后端消费者接收消息写入数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用redis的list类型数据,对请求判断可以发送消息的权限,防止高并发导致超卖 \n', 'isCorrect': '-1'}, {'optionContent': 'D.必须遵循先到先得的规则 \n', 'isCorrect': '-1'}]","【答案解析】秒杀为了突出处理速度,可以忽略各种问题,防止导致秒杀功能瘫痪
","【正确答案】A,B,C
"
"


全文检索Elasticsearch
1、
(单选题)关于ES配置说法错误的是（）
","[{'optionContent': 'A.http.port是设置对外服务的HTTP端口，默认9200 \n', 'isCorrect': '-1'}, {'optionContent': 'B.index.number_of_shards是设置索引分片个数，默认值为3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.index.number_of_replicas是设置索引的副本个数，默认值为1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.discovery.zen.minimum_master_nodes集群中最小master节点个数，默认是1 \n', 'isCorrect': '-1'}]","【答案解析】分片默认值为5
","【正确答案】B
"
"
2、
(单选题)关于ES配置文件说法错误的是
","[{'optionContent': 'A.配置cluster.name:是用来配置ES的集群名称 \n', 'isCorrect': '-1'}, {'optionContent': 'B.node.name是配置ES的节点名 \n', 'isCorrect': '-1'}, {'optionContent': 'C.node.data是指定该节点是否存储索引数据，默认是false \n', 'isCorrect': '-1'}, {'optionContent': 'D.path.data是设置索引数据的存储路径，默认是在ES根目录下的data下 \n', 'isCorrect': '-1'}]","【答案解析】Master,data,ingest的角色配置默认全是true
","【正确答案】C
"
"
3、
对elasicsearch启动集群时的master选举逻辑描述错误的是
","[{'optionContent': 'A.每个具备master角色的节点启动后都需要连通协调器获取集群信息 \n', 'isCorrect': '-1'}, {'optionContent': 'B.activeMaster中存储的就是最终的选举master \n', 'isCorrect': '-1'}, {'optionContent': 'C.选举发生时需要判断master的数量是否满足脑裂配置的过半 \n', 'isCorrect': '-1'}, {'optionContent': 'D.选举算法为bully算法(选取集群id最大或最小节点) \n', 'isCorrect': '-1'}]","【答案解析】activeMaster中的master在选举过程中仅仅是暂定master,最后一个节点启动选举结束之前,不能称activeMaster中的节点为最终master
","【正确答案】B
"
"
4、
elasticsearch防止脑裂的做法是什么
","[{'optionContent': 'A.开启二进制日志文件防止数据同步错误 \n', 'isCorrect': '-1'}, {'optionContent': 'B.配置一个集群最小有效数量 \n', 'isCorrect': '-1'}, {'optionContent': 'C.配置过半的master节点角色数量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.配置大量协调器 \n', 'isCorrect': '-1'}]","【答案解析】过半master有效数量会防止es出现脑裂,集群中至多只有一个master有效集体有效果,其他都不满足最小master条件
","【正确答案】C
"
"
5、
对elasticsearch和lucene的关系描述正确的是
","[{'optionContent': 'A.Elasticsearch完全脱离lucene单独开发的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Elasticsearch仅仅在lucene的基础上实现了分布式存储 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Elasticsearch是基于lucene的搜索服务软件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Elasticsearch的使用需要提前安装lucene的环境 \n', 'isCorrect': '-1'}]","【答案解析】Lucene是工具包,不存在安装环境的概念,es是基于lucene实现了分布式存储,自动发现节点,索引,文档,搜索功能的包装的独立运行的进程
","【正确答案】C
"
"
6、
以下描述REST风格错误的是
","[{'optionContent': 'A.Easymall的开发,是不遵循REST风格的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring mvc框架支持REST风格 \n', 'isCorrect': '-1'}, {'optionContent': 'C.URL在REST风格使用中定义的资源 \n', 'isCorrect': '-1'}, {'optionContent': 'D.POST只能在REST风格中定义为新增数据 \n', 'isCorrect': '-1'}]","【答案解析】url定义资源,操作方式由请求方式定义,put新增,post更新,get查询,delte删除,但是有时候post也可以定义新增
","【正确答案】D
"
"
7、
(单选题)关于ES的Mapping说法错误的是（）
","[{'optionContent': 'A.ES的Mapping用来定义一个文档以及其包含的字段如何被存储和索引的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ES的Mapping分为动态映射和静态映射 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Mapping在索引文件创建后就立即出现,并且定义了大量常用字段的类型和分词器内容,其中默认分词器为IK分词器 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Mapping中可以通过dynamic设置来控制是否自动新增字段 \n', 'isCorrect': '-1'}]","【答案解析】动态mapping默认是空的,等到有数据产生才出现
","【正确答案】C
"
"
8、
描述elasticsearch选举逻辑正确的是
","[{'optionContent': 'A.选举逻辑有全部角色参与 \n', 'isCorrect': '-1'}, {'optionContent': 'B.霸道选举算法,从后备list中选择id最大或最小的节点作为临时主节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Master启动后随机选举 \n', 'isCorrect': '-1'}, {'optionContent': 'D.启动顺序无论如何变化,现役master都是同一个 \n', 'isCorrect': '-1'}]","【答案解析】1.主节点角色启动,连接协调器获取集群信息2.判断节点记录的activeMaster是否为空3.不为空,选举逻辑结束4.为空说明当前集群没有现役master,先将获取到的所有集群主节点橘色节点存放到后被list candidate中5.判断candidate中数量是否满足最小master数量,不满足返回第一步重新执行6.满足最小master数量,执行bully算法获取id最小值节点放入activeMaster作为暂定现役master
","【正确答案】B
"
"
9、
对lucene中的document描述错误的是
","[{'optionContent': 'A.可以存储网页的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以存储数据库中一行数据信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Document是索引文件中的最小数据结构,不可拆分 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Document在索引文件中是海量的 \n', 'isCorrect': '-1'}]","【答案解析】Document是一个整体数据的最小单位,在索引中的最小数据结构可以看成是每个document的属性field
","【正确答案】C
"
"
多选题 （共计 6 题，总计 12分）
10、
(多选题)哪些是Lucene创建索引过程的核心类?
","[{'optionContent': 'A.IndexWriter \n', 'isCorrect': '-1'}, {'optionContent': 'B.Field \n', 'isCorrect': '-1'}, {'optionContent': 'C.Document \n', 'isCorrect': '-1'}, {'optionContent': 'D.IndexSearcher \n', 'isCorrect': '-1'}]","【答案解析】indexSearcher是lucene搜索过程的核心类
","【正确答案】A,B,C
"
"
11、
(多选题)lucene的特点是？
","[{'optionContent': 'A.稳定,索引性能高 \n', 'isCorrect': '-1'}, {'optionContent': 'B.支持非常多的查询方式:多项查询,布尔查询等 \n', 'isCorrect': '-1'}, {'optionContent': 'C.基于java开发的,对内存要求非常小 \n', 'isCorrect': '-1'}, {'optionContent': 'D.索引的大小,约占索引文件的20% \n', 'isCorrect': '-1'}]","【答案解析】稳定,栈内存占用小,索引结构紧凑
","【正确答案】A,B,C,D
"
"
12、
(多选题)以下说法错误的是？
","[{'optionContent': 'A.Lucene支持多种查询方式，例如多域查询、布尔查询 \n', 'isCorrect': '-1'}, {'optionContent': 'B.IK分词器的版本和lucene是没有版本匹配的要求 \n', 'isCorrect': '-1'}, {'optionContent': 'C.IK分词器是一个开源的全文检索引擎工具包 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Lucene可以简化开发计算索引的过程、以及搜索索引的过程 \n', 'isCorrect': '-1'}]","【答案解析】Ik分词器和lucene大版本需要匹配,lucene是全文检索引擎工具包,IK是分词器工具
","【正确答案】B,C
"
"
13、
对rabbitmq交换机属性描述正确的是
","[{'optionContent': 'A.可以设置转发逻辑,转发给备用交换机 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以设置持久化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以设置类型 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以设置交换机底层使用的并发语言 \n', 'isCorrect': '-1'}]","【答案解析】见答案
","【正确答案】A,B,C
"
"
14、
对全文检索数据库描述正确的是
","[{'optionContent': 'A.是全文检索技术的核心内容 \n', 'isCorrect': '-1'}, {'optionContent': 'B.保存了搜索需要的所有数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.保存了对词,字,句,段落处理的计算机可识别的编辑内容 \n', 'isCorrect': '-1'}, {'optionContent': 'D.是海量数据的集合 \n', 'isCorrect': '-1'}]","【答案解析】全文数据库是全文检索系统的主要构成部分。所谓全文数据库是将一个完整的信息源的全部内容转化为计算机可以识别、处理的信息单元而形成的数据集合。全文数据库不仅存储了信息，而且还有对全文数据进行词、字、段落等更深层次的编辑、加工的功能，而且所有全文数据库无一不是海量信息数据库。
","【正确答案】A,B,C,D
"
"
15、
(多选题)对ELASTICSEARCH描述正确的是?
","[{'optionContent': 'A.Elasticsearch 完全支持 Apache Lucene \n', 'isCorrect': '-1'}, {'optionContent': 'B.Elasticsearch 采用 Gateway 的概念，使得备份更加简单 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Elasticsearch是分布式的。不需要其他组件，分发是实时的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Elasticsearch可以实现主从分片处理逻辑时的脑裂问题 \n', 'isCorrect': '-1'}]","【答案解析】支持lucene,基于lucene实现的elasticsearch,gateway处理数据灵活可以存储本地也可以存储输出到hdfs,可以通过发现组件进行分布式集群的搭建,通过配置脑裂的最小有效主节点数量解决脑裂的出现
","【正确答案】A,B,C,D
"
"

消息队列Rabbimq
1、
消息队列rabbitmq的确认机制,描述正确的是
","[{'optionContent': 'A.确认机制是为了防止消费者获取消息,执行消费逻辑失败后消息丢失而出现的功能 \n', 'isCorrect': '-1'}, {'optionContent': 'B.所有消费逻辑都需要在执行成功后执行确认逻辑 \n', 'isCorrect': '-1'}, {'optionContent': 'C.未确认的消息会以acted的状态存储在rabbitmq的队列中 \n', 'isCorrect': '-1'}, {'optionContent': 'D.未确认的消息将会丢失 \n', 'isCorrect': '-1'}]","【答案解析】B,自动确认就是获取消息直接确认,不需要在执行消费逻辑后确认,强调的是快速消费C unackedD 不会丢失
","【正确答案】A
"
"
2、
rabbitmq在哪些阶段会丢失数据
","[{'optionContent': 'A.生产端发送数据失败,丢失数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.队列技术没有配置持久化,宕机内存消息数据丢失 \n', 'isCorrect': '-1'}, {'optionContent': 'C.消费端确认机制逻辑错误,消费失败导致消息丢失 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都是 \n', 'isCorrect': '-1'}]","【答案解析】发送消息(生产端),存储消息(rabbitmq),消费消息(消费端),都会导致数据丢失
","【正确答案】D
"
"
3、
以下那些场景不应该使用rabbitMQ
","[{'optionContent': 'A.服务间异步通信 \n', 'isCorrect': '-1'}, {'optionContent': 'B.请求削峰 \n', 'isCorrect': '-1'}, {'optionContent': 'C.定时任务 \n', 'isCorrect': '-1'}, {'optionContent': 'D.高可用 \n', 'isCorrect': '-1'}]","【答案解析】使用rabbitmq的场景1.服务间异步通信2.顺序消费3.定时任务4.请求削峰
","【正确答案】D
"
"
4、
(单选题)以下不是RabbitMQ的工作模式的是?
","[{'optionContent': 'A.RPC模式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.工厂模式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.争抢模式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.发布订阅模式 \n', 'isCorrect': '-1'}]","【答案解析】6种工作模式 简单,工作(争抢),发布订阅,路由,主题,rpc
","【正确答案】B
"
"
5、
对消息队列rabbitmq描述错误的是
","[{'optionContent': 'A.可以解决高并发下的请求拒绝的缓存逻辑 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以在代码中实现异步通信,降低同步执行过程出现问题的处理难度 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以将内存数据持久化到磁盘 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以代替redis工作 \n', 'isCorrect': '-1'}]","【答案解析】基本上rabbitmq就两个功能,一个是削峰限流,一个是通信解耦异步通信
","【正确答案】D
"
"
6、
以下选项不属于RabbitMQ中组成内容的是？
","[{'optionContent': 'A.交换机 \n', 'isCorrect': '-1'}, {'optionContent': 'B.队列 \n', 'isCorrect': '-1'}, {'optionContent': 'C.连接对象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.路由器 \n', 'isCorrect': '-1'}]","【答案解析】Rabbitmq客户端由长连接,短连接连通rabbitmq,可以访问交换机和队列进行生产者和消费者的逻辑
","【正确答案】D
"
"
多选题 （共计 5 题，总计 10分）
7、
对rabbitmq队列属性描述正确的是
","[{'optionContent': 'A.可以设置最大存储消息个数 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以设置超时时间 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以设置消息的长度 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以设置持久化 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】A,B,C,D
"
"
8、
对消息的属性描述正确的是
","[{'optionContent': 'A.可以设置消息的超时时间 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以设置消息的优先级值 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以设置消息的字符集 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以设置消息的语言 \n', 'isCorrect': '-1'}]","【答案解析】没有设置语言的属性,只有字符集
","【正确答案】A,B,C
"
"
9、
避免rabbitmq丢失消息可以如何做?
","[{'optionContent': 'A.发送端丢失可以通过发送的api逻辑实现消息发送确认 \n', 'isCorrect': '-1'}, {'optionContent': 'B.队列丢失数据可以使用队列和消息持久化的配置 \n', 'isCorrect': '-1'}, {'optionContent': 'C.消费端消息丢失可以通过确认机制不返回处理ack,下次依然继续处理未删除的消息 \n', 'isCorrect': '-1'}, {'optionContent': 'D.无法避免 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】A,B,C
"
"
10、
对rabbitmq五种工作模式场景描述正确的是
","[{'optionContent': 'A.简单模式强调的是单个消费者单独连接监听队列的结构 \n', 'isCorrect': '-1'}, {'optionContent': 'B.工作模式强调的是多个消费者同时连接监听队列的结构 \n', 'isCorrect': '-1'}, {'optionContent': 'C.发布订阅模式的常见应用是消息群发,邮件群发 \n', 'isCorrect': '-1'}, {'optionContent': 'D.路由模式可以实现系统错误消息的自动捕捉 \n', 'isCorrect': '-1'}]","【答案解析】见题目描述
","【正确答案】A,B,C,D
"
"
11、
对rabbitmq连接逻辑描述正确的是
","[{'optionContent': 'A.所有客户端都需要获取连接对象才能操作rabbitmq \n', 'isCorrect': '-1'}, {'optionContent': 'B.连接分为长连接和短连接 \n', 'isCorrect': '-1'}, {'optionContent': 'C.短连接基于长链接创建,但是不能频繁销毁 \n', 'isCorrect': '-1'}, {'optionContent': 'D.长连接可以频繁销毁和创建 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】A,B
"
"

数据库集群Mycat
1、
关于Mycat数据拆分原则说法不正确的是
","[{'optionContent': 'A.Mycat可以管理大量的后端数据库集群 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一张1000万的大表可以由mycat拆分给多个不同数据库分片 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Mycat在没有schema.xml支持时也可以执行create table的建表语句 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Mycat可以配合haproxy搭建高可用 \n', 'isCorrect': '-1'}]","【答案解析】没有schema.xml支持,mycat不能执行create table语句
","【正确答案】C
"
"
2、
对mycat配置读写分离逻辑描述错误的是
","[{'optionContent': 'A.writeType是dataHose标签一个控制写逻辑的属性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Balance是dataHost标签一个控制读逻辑的属性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.writeType=0时会覆盖掉balance的读逻辑,进行随机读取 \n', 'isCorrect': '-1'}, {'optionContent': 'D.1.5版本后的mycat不推荐配置writeType=1 \n', 'isCorrect': '-1'}]","【答案解析】writeType=1会在所有writeType随机读数据,balance读逻辑失效,不推荐配置
","【正确答案】C
"
"
3、
mycat常用的读写分离配置,writeType和balance的配置是多少
","[{'optionContent': 'A.writeType=1 balance=0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.writeType=1 balance=1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.writeType=0 balance=2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.writeType=0 balance=1 \n', 'isCorrect': '-1'}]","【答案解析】writeType=1会屏蔽balance效果,=0表示只在第一个writeHost写数据,balance=2会随机在所有节点进行读,一旦第一个writeHost写压力过大这种方式就不合理,balance=1会在除了第一个writeHost其他所有节点进行读的分离操作,只有并发过高时,第一个才参与读逻辑,所以答案是D
","【正确答案】D
"
"
4、
对数据库中间件假死现象描述正确的是
","[{'optionContent': 'A.假死是由于后端数据库真实节点宕机引起的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.假死是由于中间件的后端连接技术使用了非阻塞线程引起的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.假死不会影响中间件的使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.假死是由于中间件后端连接使用了阻塞线程引起的 \n', 'isCorrect': '-1'}]","【答案解析】假死是后端连接使用BIO导致并发过大时,线程沾满,错误判断后端数据库宕机导致的
","【正确答案】D
"
"
5、
(单选题) Mycat配置文件Schema.xml 中，dataHost 标签在 mycat 逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。下列关于switchType 属性说法不正确的是（）
","[{'optionContent': 'A.-1 表示不自动切换 默认值 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1 默认值，自动切换 \n', 'isCorrect': '-1'}, {'optionContent': 'C.等于1时,会在多个writeHost之间进行切换 \n', 'isCorrect': '-1'}, {'optionContent': 'D.等于-1是,不会在多个writeHost之间进行切换 \n', 'isCorrect': '-1'}]","【答案解析】switchType表示一个分片对应的数据库主从集群是否执行故障转移,1表示执行,会在多个writeHost之间按照顺序从大index切换到小index,-1表示不执行故障转移
","【正确答案】A
"
"
6、
(单选题)MYSQL主从复制时,开启从的进程时,主要有哪几个线程启动
","[{'optionContent': 'A.IO/DUMP \n', 'isCorrect': '-1'}, {'optionContent': 'B.IO/SQL \n', 'isCorrect': '-1'}, {'optionContent': 'C.SLAVE/IO \n', 'isCorrect': '-1'}, {'optionContent': 'D.SLAVE/SQL \n', 'isCorrect': '-1'}]","【答案解析】2个线程 io和sql线程
","【正确答案】B
"
"
7、
(单选题)mycat的特性描述错误的是?
","[{'optionContent': 'A.遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.后端连接基于BIO,没有解决高并发假死问题 \n', 'isCorrect': '-1'}, {'optionContent': 'C.支持通过全局表，ER关系的分片策略，实现了高效的多表join查询 \n', 'isCorrect': '-1'}, {'optionContent': 'D.大表水平计算,千亿以下可以实现分布式集群管理 \n', 'isCorrect': '-1'}]","【答案解析】实现NIO后端连接,提升并发上限,解决假死问题
","【正确答案】B
"
"
多选题 （共计 6 题，总计 12分）
8、
(多选题)mysql主从复制的作用是？
","[{'optionContent': 'A.做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失 \n', 'isCorrect': '-1'}, {'optionContent': 'B.架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能 \n', 'isCorrect': '-1'}, {'optionContent': 'C.读写分离，使数据库能支撑更大的并发。在报表中尤其重要 \n', 'isCorrect': '-1'}, {'optionContent': 'D.由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度 \n', 'isCorrect': '-1'}]","【答案解析】主要集中在提升并发读写分离,提供可靠数据故障转移
","【正确答案】A,B,C,D
"
"
9、
对主从数据库复制描述正确的是
","[{'optionContent': 'A.从节点需要具备登录主节点的权限,监听主节点开启的二进制文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.从节点的IO线程一旦开启将会把主节点的二进制文件所有内容抓取过来 \n', 'isCorrect': '-1'}, {'optionContent': 'C.从节点需要使用中继日志存储从主节点获取的sql语句更新内容 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SQL线程是从节点在启动时开启的一个重要线程 \n', 'isCorrect': '-1'}]","【答案解析】主节点开启二进制日志文件,从节点开启io sql线程,生成中继日志,线程抓取数据需要判断更新内容,是通过position的值变化完成判断的
","【正确答案】A,C,D
"
"
10、
(多选题)mycat的schema.xml中的属性中,对balance值描述正确的是？
","[{'optionContent': 'A.0:不开启读写分离,所有读都在第一个writeHost实现 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1:开启读写分离,在高并发时第一个writeHost参与部分读,其他Host都参与读 \n', 'isCorrect': '-1'}, {'optionContent': 'C.2:所有的节点都随机的进行读操作,除了第一个writeHost \n', 'isCorrect': '-1'}, {'optionContent': 'D.3:所有的readHost都参与读,如果没有配置readHost就只在第一个writeHost进行读,其他writeHost不参与 \n', 'isCorrect': '-1'}]","【答案解析】2:所有的host都参与随机读,包括第一个writeHost
","【正确答案】A,B,D
"
"
11、
(多选题)mysql主从部署必要条件？
","[{'optionContent': 'A.主节点开启二进制日志文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主从集群配置server-id,值不能相同 \n', 'isCorrect': '-1'}, {'optionContent': 'C.主从节点都是mysql \n', 'isCorrect': '-1'}, {'optionContent': 'D.从节点开启二进制日志文件 \n', 'isCorrect': '-1'}]","【答案解析】主节点配置二进制,配置server-id,从节点配置server-id,挂接后启动从进程,不需要开启从节点二进制日志文件
","【正确答案】A,B,C
"
"
12、
(多选题)mysql主从复制的原理描述正确的是?
","[{'optionContent': 'A.主节点数据库有个bin-log二进制文件，记录了所有sql语句 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主节点开启IO线程将数据同步输出给从节点 \n', 'isCorrect': '-1'}, {'optionContent': 'C.从节点IO线程开启,登录主节点,将二进制文件数据同步到从节点 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Relay-log是中继日志,作用是记录IO线程的同步数据 \n', 'isCorrect': '-1'}]","【答案解析】主节点只需要开启二进制,从节点进行Io sql线程开启同步过程
","【正确答案】A,C,D
"
"
13、
(多选题)以下关于MyCat配置文件的说法正确的是？
","[{'optionContent': 'A.server.xml和schema.xml位于MyCat根目录下的conf文件夹下 \n', 'isCorrect': '-1'}, {'optionContent': 'B.server.xml可以配置登录mycat的user信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.server.xml设定当前启动在系统中的MyCat进程对系统资源占用的内容 \n', 'isCorrect': '-1'}, {'optionContent': 'D.schema.xml设定当前MyCat中的逻辑库，逻辑表，分片计算规则，映射的实际数据库配置 \n', 'isCorrect': '-1'}]","【答案解析】Server.xml管理mycat启动运行时占用的各种逻辑和资源,schema配置逻辑库,逻辑表等内容
","【正确答案】A,B,C,D
"
"


Redis
1、
Redis回收使用的是什么算法？
","[{'optionContent': 'A.LRU算法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.OPT算法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.FIFO算法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.LFU算法 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"2
、
以下不是Redis事务相关的命令的是？
","[{'optionContent': 'A.MULTI \n', 'isCorrect': '-1'}, {'optionContent': 'B.EXEC \n', 'isCorrect': '-1'}, {'optionContent': 'C.DISCARD \n', 'isCorrect': '-1'}, {'optionContent': 'D.GUARD \n', 'isCorrect': '-1'}]","【答案解析】MULTI、EXEC、DISCARD、WATCH
","【正确答案】D
"
"3
、
(单选题)有关Redis说法正确的是?
","[{'optionContent': 'A.Redis是一个典型的关系型数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Redis是基于C语言编写的一个高性能数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Redis的主从关系直接实现故障转移 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Redis不能存储 set类型的数据 \n', 'isCorrect': '-1'}]","【答案解析】Redis是非关系型数据库,可以通过哨兵实现故障转移,可以存储string hash set zset list五种数据类型
","【正确答案】B
"
"
4、
对redis的set命令描述错误的是
","[{'optionContent': 'A.NX的选项,是set写入数据必须在当前redis没有该key值时才可以写入成功 \n', 'isCorrect': '-1'}, {'optionContent': 'B.XX的选项,是set写入数据必须在当前redis已有该key值时才可以写入成功 \n', 'isCorrect': '-1'}, {'optionContent': 'C.EXPIRE的选项,可以直接设置写入的数据超时时间的毫秒数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Set只能操作String类型的数据写入 \n', 'isCorrect': '-1'}]","【答案解析】EXPIRE是设置秒为单位的超时时间
","【正确答案】C
"
"
5、
秒杀机制中,redis的作用描述正确的是
","[{'optionContent': 'A.做秒杀数据商品的缓存 \n', 'isCorrect': '-1'}, {'optionContent': 'B.利用redis的数据结构,实现对高并发请求客户端的秒杀权限判断,减少数据库计算压力 \n', 'isCorrect': '-1'}, {'optionContent': 'C.List作为消息队列实现秒杀逻辑 \n', 'isCorrect': '-1'}, {'optionContent': 'D.高并发消费消息,实现用户秒杀的入库操作 \n', 'isCorrect': '-1'}]","【答案解析】Redis中的list数据结构,调用pop方法,高并发访问下只有list元素个数个客户端才能成功pop数据,一次判断海量请求中可以访问数据库执行秒杀入库逻辑的权限,减少通过数据库处理计算海量请求的压力
","【正确答案】B
"
"6
、
如何在数据库数据庞大时,保障在redis内存有限时存储热点数据
","[{'optionContent': 'A.设置超时 \n', 'isCorrect': '-1'}, {'optionContent': 'B.设置最大存储内存上限和淘汰策略 \n', 'isCorrect': '-1'}, {'optionContent': 'C.设置内存使用上限,和使用lru作为淘汰策略 \n', 'isCorrect': '-1'}, {'optionContent': 'D.扩大内存容量 \n', 'isCorrect': '-1'}]","【答案解析】1.当数据库数据容量大于redis内存容量需要使用淘汰策略实现热点数据的使用2.使用redis提供的最近最久未使用策略,只要满足这个策略的数据,基本都是冷点数据,都会在redis内存容量上限到达时优先删除,保证剩余数据都是长期频繁访问的热点数据3.allkeys-lru 所有数据执行最近最久未使用淘汰策略4.volitle-lur 所有设置了超时的数据执行最近最久未使用淘汰策略
","【正确答案】C
"
"
7、
redis集群的hash槽描述错误的是
","[{'optionContent': 'A.Hash slot的个数是16384,从下标0开始到16383结束 \n', 'isCorrect': '-1'}, {'optionContent': 'B.槽道的引入彻底解决了key值数据和节点node间的对应强耦合 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Hash槽道数字是[0-16383],每一个key值都会使用hash一致性计算出槽道的号码 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hash槽道原理是由一个位序列和数组实现的 \n', 'isCorrect': '-1'}]","【答案解析】Hash一致性在redis-cluster中不使用,redis-cluster中使用hash槽道
","【正确答案】C
"
"
8、
(单选题)哪个不是Redis的value数据结构?
","[{'optionContent': 'A.String \n', 'isCorrect': '-1'}, {'optionContent': 'B.Hash \n', 'isCorrect': '-1'}, {'optionContent': 'C.list \n', 'isCorrect': '-1'}, {'optionContent': 'D.map \n', 'isCorrect': '-1'}]","【答案解析】五种数据结构string hash list set zset 
","【正确答案】D
"
"
9、
Redis中一个字符串类型的值能存储最大容量是多少？
","[{'optionContent': 'A.256MB \n', 'isCorrect': '-1'}, {'optionContent': 'B.512MB \n', 'isCorrect': '-1'}, {'optionContent': 'C.1GB \n', 'isCorrect': '-1'}, {'optionContent': 'D.2GB \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"
10、
redis主从描述正确的是
","[{'optionContent': 'A.支持多级主从,一主多从 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主从可以实现分布式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.主从是搭建分布式的基础,没有主从,分布式无法实现 \n', 'isCorrect': '-1'}, {'optionContent': 'D.主节点抓取从节点实现主从 \n', 'isCorrect': '-1'}]","【答案解析】主从无法实现分布式,数据都是一致的,没有主从可以实现分布式,但是没有高可用,从节点挂接主节点
","【正确答案】A
"
"

11、
对rdb的redis持久化方式描述正确的是
","[{'optionContent': 'A.默认存储在dump.rdb中 \n', 'isCorrect': '-1'}, {'optionContent': 'B.没有持久化数据时持久化文件大小是0字节 \n', 'isCorrect': '-1'}, {'optionContent': 'C.默认存储在appendonly.aof中 \n', 'isCorrect': '-1'}, {'optionContent': 'D.默认存储命令日志 \n', 'isCorrect': '-1'}]","【答案解析】默认结构77字节,appendonly是aof模式,存储key-value数据不是日志
","【正确答案】A
"
"

12、
(单选题)Redis默认使用的端口是?
","[{'optionContent': 'A.6379 \n', 'isCorrect': '-1'}, {'optionContent': 'B.6380 \n', 'isCorrect': '-1'}, {'optionContent': 'C.6381 \n', 'isCorrect': '-1'}, {'optionContent': 'D.8000 \n', 'isCorrect': '-1'}]","【答案解析】redis默认6379,哨兵默认26379
","【正确答案】A
"
"

13、
那些数据类型不被Redis所支持？
","[{'optionContent': 'A.set \n', 'isCorrect': '-1'}, {'optionContent': 'B.list \n', 'isCorrect': '-1'}, {'optionContent': 'C.string \n', 'isCorrect': '-1'}, {'optionContent': 'D.map \n', 'isCorrect': '-1'}]","【答案解析】Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
","【正确答案】D
"
"
4、缓存雪崩描述正确的是
","[{'optionContent': 'A.海量请求高并发访问导致缓存丢失叫雪崩 \n', 'isCorrect': '-1'}, {'optionContent': 'B.数据库宕机缓存数据没法更新叫雪崩 \n', 'isCorrect': '-1'}, {'optionContent': 'C.海量请求高并发访问,由于缓存数据失效过多导致压力集中访问后端数据来源导致系统的不可用叫做缓存雪崩 \n', 'isCorrect': '-1'}, {'optionContent': 'D.只要缓存丢失数据就会发生雪崩 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】C
"
"
多选题 （共计 10 题，总计 20分）
12、(多选题)Redis有哪些适合的场景
","[{'optionContent': 'A.缓存 \n', 'isCorrect': '-1'}, {'optionContent': 'B.消息队列 \n', 'isCorrect': '-1'}, {'optionContent': 'C.兴趣标签 \n', 'isCorrect': '-1'}, {'optionContent': 'D.内存锁 \n', 'isCorrect': '-1'}]","【答案解析】String hash做缓存,list做消息队列,set做标签,zset做排序榜
","【正确答案】A,B,C,D
"
"
14、
(多选题)Redis相比memorycache有哪些优势？
","[{'optionContent': 'A.Redis的数据类型更丰富 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Redis的速度比memorycache更快 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Redis支持持久化 memorycache不支持 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Redis应用场景比memorycache更丰富 \n', 'isCorrect': '-1'}]","【答案解析】Redis类型丰富,支持场景更多,支持持久化容灾,memoryCache是多线程,在数据量较大时性能速度高于redis,但是瓶颈不会限制在技术端而是数据传输途径
","【正确答案】A,C,D
"
"
15、(多选题)下面关于redis和mysql的说法正确的是？
","[{'optionContent': 'A.总有一天redis会代替数据库而存在 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Redis不能代替数据,两者的性质不同 \n', 'isCorrect': '-1'}, {'optionContent': 'C.redis是内存数据库，数据保存在内存，所以速度快 \n', 'isCorrect': '-1'}, {'optionContent': 'D.mysql是关系型数据库，存放在磁盘，检索涉及到一定的IO，所以数据访问也就慢 \n', 'isCorrect': '-1'}]","【答案解析】Redis目前还不能代替数据库存在,数据库是数据最后一道关卡,redis提供了其他丰富处理数据的功能
","【正确答案】B,C,D
"
"
15、
对redis的set数据类型的命令描述正确的是
","[{'optionContent': 'A.Sadd添加一个元素到集合中 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Scard查看集合元素个数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Lpush在集合中删除一个元素 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Rpop从集合中随机查看一个元素值 \n', 'isCorrect': '-1'}]","【答案解析】Lpush,rpop操作list类型数据
","【正确答案】A,B
"
"
16、
(多选题)为什么要做Redis分片？
","[{'optionContent': 'A.分片可以让Redis管理更大的内存，Redis将可以使用所有机器的内存 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果没有分片，你最多只能使用一台机器的内存 \n', 'isCorrect': '-1'}, {'optionContent': 'C.分片使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Redis消耗机器内存，所以做分片可以减少机器的压力，从而提高性能 \n', 'isCorrect': '-1'}]","【答案解析】分片时实现数据层分布式的基础概念.引入分片计算后才可以实现集群的分布式管理,一旦启用集群分布式,整体redis的性能,容量都会随之线性增长
","【正确答案】A,B,C,D
"
"
17、
redis速度快的原因是?
","[{'optionContent': 'A.基于内存,读写时缺少了磁盘IO的步骤 \n', 'isCorrect': '-1'}, {'optionContent': 'B.内存数据结构简单,是hashmap复杂度低 \n', 'isCorrect': '-1'}, {'optionContent': 'C.单进程,单线程技术,减少了cpu切换资源的浪费,和线程冲突产生的时间 \n', 'isCorrect': '-1'}, {'optionContent': 'D.采用非阻塞IO多路复用,是的线程处理性能大大提升 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】A,B,C,D
"
"
18、
(多选题)下列关于redis集群(redis-cluster)的说法正确的是？
","[{'optionContent': 'A.Redis 集群的分片特征在于将键空间分拆了16384(2^14)个槽位，每一个节点负责其中一些槽位 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Redis提供一定程度的可用性,可以在某个节点宕机或者不可达的情况下继续处理命令 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability） \n', 'isCorrect': '-1'}, {'optionContent': 'D.自动将节点分成主从，形成主从复制，数据备份容灾，同时实现读写分离 \n', 'isCorrect': '-1'}]","【答案解析】Redis利用槽道解耦key与节点,利用两两互联实现线性扩展方便,动态添加节点,主从关系实现高可用
","【正确答案】A,B,C,D
"
"
19、
对Redis 主从复制、哨兵和集群这三个描述正确的是？
","[{'optionContent': 'A.主从复制是高可用集群的基础,故障转移所替换上来的从节点必须保证和原有宕机的主节点数据一致 \n', 'isCorrect': '-1'}, {'optionContent': 'B.哨兵是redis提供的监听主从实现故障转移投票的特殊redis进程 \n', 'isCorrect': '-1'}, {'optionContent': 'C.redis集群是高可用分布式的redis集群,内部维护计算分片的算法hash槽,是redis目前最新的结构 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在redis的哨兵集群中实现分布式可以通过hash一致性算法完成 \n', 'isCorrect': '-1'}]","【答案解析】见选项
","【正确答案】A,B,C,D
"
"
20、
(多选题)redis将数据放到内存描述正确的是?
","[{'optionContent': 'A.Redis为了达到最快的读写速度将数据都读到内存中 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能 \n', 'isCorrect': '-1'}, {'optionContent': 'C.redis具有快速和数据持久化的特征 \n', 'isCorrect': '-1'}, {'optionContent': 'D.如果设置了最大使用的内存，则一定会数据已有记录数达到内存限值后不能继续插入新值 \n', 'isCorrect': '-1'}]","【答案解析】D迷惑选项,根据淘汰策略,达到最大值后,删除旧数据,新增新数据,不会拒绝
","【正确答案】A,B,C
"
"21
、
(多选题)关于redis描述正确的是
","[{'optionContent': 'A.Redis难以保持和数据库的强一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.缓存雪崩，击穿问题和缓存并发问题都可能出现在redis应用逻辑中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.单线程操作，避免了频繁的上下文切换 \n', 'isCorrect': '-1'}, {'optionContent': 'D.采用了阻塞式io流 \n', 'isCorrect': '-1'}]","【答案解析】Redis不能保证强一致性,包括自身的强一致性,但是可以保持最终一致性,缓存雪崩,击穿,并发需要从系统代码考虑解决,redis采用单进程单线程结构,实现非阻塞线程的io多路复用模式,提升了软件的性能.但是性能一般瓶颈会出现在网络带宽上
","【正确答案】A,B,C
"
"
22、
(多选题) Redis持久化的方式是？
","[{'optionContent': 'A.Appendonly \n', 'isCorrect': '-1'}, {'optionContent': 'B.Rdb \n', 'isCorrect': '-1'}, {'optionContent': 'C.Aof \n', 'isCorrect': '-1'}, {'optionContent': 'D.App \n', 'isCorrect': '-1'}]","【答案解析】Rdb,aof是redis可以实现持久化的2种方式,rdb的可靠性没有aof高,因为aof的每秒同步,但是aof同步日志数据量过大
","【正确答案】B,C
"
"
23、
对缓存雪崩描述正确的是
","[{'optionContent': 'A.海量请求时,缓存大量未命中,导致系统崩溃就是雪崩 \n', 'isCorrect': '-1'}, {'optionContent': 'B.雪崩的出现,一般采用紧急停止系统,恢复数据作为解决方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.不支持持久化的缓存技术预防雪崩,就是尽量想办法将集群高可用实现的更好 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Redis根本不需要考虑雪崩的情况 \n', 'isCorrect': '-1'}]","【答案解析】迷惑选项D,redis支持持久化,数据恢复速度快,雪崩解决方便,但是不表示根本不考虑
","【正确答案】A,B,C
"
"

24、
对redis集群hash槽原理描述正确的是
","[{'optionContent': 'A.散列算法使用的是CRC16,得到的整数对16384取模最终获取槽道号 \n', 'isCorrect': '-1'}, {'optionContent': 'B.槽道原理的二进制是byte数组 2048个元素,整体形成16384位的二进制,描述槽道号的管理范围和权限 \n', 'isCorrect': '-1'}, {'optionContent': 'C.槽道原理的索引数组是16384个元素 \n', 'isCorrect': '-1'}, {'optionContent': 'D.判断完管理权的节点如果所属权为false可以通过索引数组元素中记录的变量获取正确管理节点的详细信息 \n', 'isCorrect': '-1'}]","【答案解析】二进制维护槽道管理权判断逻辑,根据位移计算获取槽道下标对应二进制,1位管理所属,0为管理不所属,数组保存内容主要是所有节点的信息管理对象,所以可以通过数组槽道号下标找到槽道正确管理者的节点信息对象从而做重定向处理
","【正确答案】A,B,C,D
"
"
28、以下哪些命令是redis的String类型数据的命令
","[{'optionContent': 'A.Flushall \n', 'isCorrect': '-1'}, {'optionContent': 'B.Save \n', 'isCorrect': '-1'}, {'optionContent': 'C.Set \n', 'isCorrect': '-1'}, {'optionContent': 'D.Append \n', 'isCorrect': '-1'}]","【答案解析】Flushall清空内存和持久化数据,save存储内存数据到rdb文件,set写String数据,append追加数据到string类型
","【正确答案】C,D
"
"


微服务SpringCloud
1、
对eureka组件描述错误的是
","[{'optionContent': 'A.是springcloud微服务框架的核心组件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Eureka注册中心可以将自己作为服务提供者注册在其他注册中心 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Eureka组件的客户端可以调用注册中心中所有的微服务 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Eureka中存在三种角色,分别是注册中心,服务提供者,服务调用者 \n', 'isCorrect': '-1'}]","【答案解析】Eureka客户端需要配合负载均衡调用的组件ribbon或者feign才能实现调用服务的功能
","【正确答案】C
"
"
2、
下列选项对于路径http://localhost:9005/api-a/c/d/hi?name=wanglaoshi zuul网关路由配置能够正确拦截并且转发给service01的是()
","[{'optionContent': 'A.zuul.routes.api-a.path=/api-a/* zuul.routes.api-b.serviceId=service01 \n', 'isCorrect': '-1'}, {'optionContent': 'B.zuul.routes.api-a.path=/api-b/** zuul.routes.api-b.serviceId= service01 \n', 'isCorrect': '-1'}, {'optionContent': 'C.zuul.routes.api-a.path=/api-a/** zuul.routes.api-a.serviceId= service01 \n', 'isCorrect': '-1'}, {'optionContent': 'D.zuul.routes.api-a.path=/api-b/* zuul.routes.api-a.serviceId= service01 \n', 'isCorrect': '-1'}]","【答案解析】拦截规则**拦截多级url路径,使用同一个路由名称匹配一对路由规则
","【正确答案】C
"
"
3、
Spring Cloud Ribbon是什么？
","[{'optionContent': 'A.Spring Cloud Ribbon用以实现客户端负载均衡 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring Cloud Ribbon是一个声明式的WebService客户端 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring Cloud Ribbon提供应对雪崩效应的熔断机制。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring Cloud Ribbon用以实现对请求的路由和过滤。 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
多选题 （共计 10 题，总计 20分）
4、
对微服务概念描述正确的是
","[{'optionContent': 'A.微服务就是功能超级简单的单体系统应用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.服务体现的是功能的被调用逻辑 \n', 'isCorrect': '-1'}, {'optionContent': 'C.微体现的是一个整体系统经过纵向拆分后的独立应用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.微服务的最大特点就是多个应用的独立运行 \n', 'isCorrect': '-1'}]","【答案解析】单体项目存在功能强耦合,并发集中的问题,需要通过纵向拆分解决,拆分之后的每个系统都独立运行,相互间可以存在调用关系,相比于之前集中的项目,每个独立运行的系统的工程都被缩小了
","【正确答案】B,C,D
"
"
5、
对hystrix熔断器描述正确的是
","[{'optionContent': 'A.大量微服务存在复杂的相互依赖调用的关系,一旦某些服务提供者在一段时间内不可达时,会造成调用的压力积压,长时间不解决容易产生一整条调用链路的瘫痪最终导致微服务集群的瘫痪,需要引入断路器解决这个问题 \n', 'isCorrect': '-1'}, {'optionContent': 'B.断路器,是熔断机制中一个组件,他会根据每次调用下层服务的响应状态来判断是否开启断路器,一旦后端服务响应延迟或者失效,断路器打开一段时间,过段时间尝试半开,发现服务可达,则彻底关闭 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在断路器打开时,对这个服务提供者调用就彻底断开,需要提供服务降级机制,采取退而求其次的响应结果给调用者返回数据,以防返回时间过长或数据无效导致调用者的逻辑失败 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都正确 \n', 'isCorrect': '-1'}]","【答案解析】见答案
","【正确答案】A,B,C,D
"
"
6、
对微服务概念描述正确的是
","[{'optionContent': 'A.微服务都是独立运行的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.微是因为拆分了功能 \n', 'isCorrect': '-1'}, {'optionContent': 'C.服务是因为功能被调用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.控制层,业务层,持久层单独拆分后就行程了微服务集群 \n', 'isCorrect': '-1'}]","【答案解析】微服务概念比较庞杂,简单理解如下:1.庞大的独立运行的单系统组成的一个功能的集群2.集群中每一个能够独立运行由相互有关联的单系统就可以成为微服务3.单体项目经过纵向拆分切分的每个独立系统相比之前的系统都形成了”微”4.服务的意思是所有独立运行的功能都可能被客户端直接或者其他微服务调用
","【正确答案】A,B,C
"
"
7、
对ribbon和feign描述正确的是
","[{'optionContent': 'A.Ribbon是feign封装的底层逻辑 \n', 'isCorrect': '-1'}, {'optionContent': 'B.两者使用的场景有所不同 \n', 'isCorrect': '-1'}, {'optionContent': 'C.两者可以相互代替使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.没有人使用feign的组件 \n', 'isCorrect': '-1'}]","【答案解析】1.共同点是ribbon和feign都可以是spring cloud微服务框架中的负载均衡客户端调用组件,feign是基于ribbon+restTemplate实现的声明式客户端组件2.区别在于两者的使用方式不同,ribbon需要自定义restTemplate的调用api和参数逻辑,可以在业务层包装使用,feign是声明式使用,调用的底层代码是根据我们在接口抽象方法上实现的注解自动完成的3.ribbon常用来封装自定义业务逻辑,使得调用的结果直接在业务层使用,feign则用来封装公用的服务调用逻辑
","【正确答案】A,B,C
"
"
8、
对ribbon拦截逻辑描述正确的是
","[{'optionContent': 'A.拦截发生在restTemplate的api调用之后 \n', 'isCorrect': '-1'}, {'optionContent': 'B.拦截器会在拦截后获取url地址中的域名作为服务名称使用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.拦截器判断服务名称如果存在,会随机选择一个服务提供者作为最终调用者使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在ribbon组件所在的系统,任何一个restTemplate对象都会经过拦截器逻辑 \n', 'isCorrect': '-1'}]","【答案解析】AB正确,D有迷惑,不是任何RestTemplate对象都会被ribbon拦截,自己new出来的就不行,一定要使用@LoadBalanced注解生成的才行,C,负载均衡逻辑取决于使用的IRule实现类,默认是轮询,随机需要配置RandomRule对象
","【正确答案】A,B
"
"
9、
对zuul网关组件描述错误的是
","[{'optionContent': 'A.作为微服务集群对外提供的唯一入口使用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以在zuul网关中编写业务逻辑代码 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Springcloud组件中zuul不是一个微服务集群必须的组件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Zuul网关提供过滤器,实现对后端微服务调用的权限校验,安全监测等功能 \n', 'isCorrect': '-1'}]","【答案解析】作为唯一入口调用微服务,所以是必须具备的组件,C错误,zuul网关虽然是一个web应用,但是为了保证网关的能力,不能再zuul中编写业务逻辑,zuul网关的两大功能,路由和过滤,过滤的作用如D描述,是正确的
","【正确答案】B,C
"
"
10、
对config配置中心描述错误的是
","[{'optionContent': 'A.Config配置中心在一个springcloud集群中只能配置一个 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Config配置中心只能有一个config的客户端连接 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Config配置中心可以从gitee github 私有git库中获取自定义的公用配置文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Config配置中心不是springcloud集群必须使用的组件 \n', 'isCorrect': '-1'}]","【答案解析】必须有多个,要实现高可用,客户端就是多个微服务提供者,微服务框架搭建集群时可以不使用config作为公用配置的来源
","【正确答案】A,B
"
"
11、
对CAP理论描述正确的是
","[{'optionContent': 'A.c表示数据一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.a表示系统可用性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.p表示分区和分区容忍度 \n', 'isCorrect': '-1'}, {'optionContent': 'D.cap不可能同时存在,p分区是常态,cp在保证一致性时,牺牲可用性,ap在保证可用性时 \n', 'isCorrect': '-1'}]","【答案解析】1.c表示数据一致性2.a表示系统可用性3.p表示分区和分区容忍度4.cap不可能同时存在,p分区是常态,cp在保证一致性时,牺牲可用性,ap在保证可用性时牺牲一致性
","【正确答案】A,B,C,D
"
"
12、
(多选题)eureka自我保护机制描述正确的是
","[{'optionContent': 'A.Eureka自我保护机制默认开启 \n', 'isCorrect': '-1'}, {'optionContent': 'B.服务提供者每30秒发送心跳,eureka60秒检测一次,超过90秒未发送就剔除服务 \n', 'isCorrect': '-1'}, {'optionContent': 'C.当超过15%服务实例同时需要剔除,判断异常开启保护机制,所有实例在恢复前不剔除,防止网络波动导致大量实例剔除服务集群不可用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.自我保护机制可以关闭 \n', 'isCorrect': '-1'}]","【答案解析】1.eureka是微服务框架spring cloud的服务治理组件2.服务提供者每30秒发送心跳,告诉注册中心当前实例存活3.注册中心每60秒检测一次,超过90秒剔除服务实例4.当超过15%服务实例同时需要剔除,判断异常开启保护机制,所有实例在恢复前不剔除,防止网络波动导致大量实例剔除服务集群不可用
","【正确答案】A,B,C,D
"
"
13、
对eureka注册发现机制描述正确的是
","[{'optionContent': 'A.所有服务提供者通过注册中心接口/eureka注册信息 \n', 'isCorrect': '-1'}, {'optionContent': 'B.注册中心维护双层map结构数据保存注册信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.第一层map的key就是服务名称 \n', 'isCorrect': '-1'}, {'optionContent': 'D.第二层map的key是实例名称,实例名称默认是 系统用户名:服务名称:端口 \n', 'isCorrect': '-1'}]","【答案解析】通过eureka服务治理组件实现注册和发现1.注册中心启动管理所有的服务提供者详细信息2.服务提供者访问注册中心接口发送自身节点详细信息3.注册中心以双层map的内存数据格式保存,第一层map的key为服务名称,value为第二层map对象,第二层map的key为服务实例名称,value为实例的详细信息,其中包括ip id port 时间戳等内容
","【正确答案】A,B,C,D
"
"

Nginx
1、
关于Nginx的配置正确的是()
","[{'optionContent': 'A.系统配置：server，可以配置多个server \n', 'isCorrect': '-1'}, {'optionContent': 'B.转发规则：location路径，root目录，index欢迎页面 \n', 'isCorrect': '-1'}, {'optionContent': 'C.反向代理规则：location拦截路径，proxy_pass转向地址 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都对 \n', 'isCorrect': '-1'}]","【答案解析】Server:虚拟服务器,可以在nginx中配置多个,但是不能同时监听同一个端口和域名Location:url匹配规则可以在同一个server配置多个,按照优先级匹配Root:在location中实现静态资源访问是配置的本地路径Index:静态资源访问时使用来表示默认欢页面Proxy_pass:转发到后端动态资源的地址
","【正确答案】D
"
"
2、
nginx
",[],"【答案解析】正向代理代理的是客户端,反向代理代理的是服务终端
","【正确答案】D
"
"
3、
(单选题)以下对于nginx描述正确的是？
","[{'optionContent': 'A.静态资源管理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.http反向代理服务器 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实现负载均衡访问服务终端 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上三个都正确 \n', 'isCorrect': '-1'}]","【答案解析】负载均衡访问终端服务,可以管理静态资源动静分离,支持http访问的反向代理
","【正确答案】D
"
"
4、
关于Nginx说法错误的是()
","[{'optionContent': 'A.Nginx非常注重效率，能经受高负载的考验 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Nginx支持高可用的结构运行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Nginx是软件技术,并发能力没有硬件的F5高 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Nginx是一个非常高效的正向代理、负载均衡 \n', 'isCorrect': '-1'}]","【答案解析】Nginx负载均衡极限10万左右,可以搭建多个nginx配合keepalive可以实现高可用故障转移,F5是硬件代理,并发在几十万左右,nginx是反向代理不是正向代理.
","【正确答案】D
"
"
5、
以下说法错误的是（）
","[{'optionContent': 'A.Nginx可以实现动静分离,静态资源由nginx维护,动态资源交给后端服务器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.负载均衡主要解决网络拥塞问题，提高服务器响应速度 \n', 'isCorrect': '-1'}, {'optionContent': 'D.反向代理：代理服务器是作用在客户端上的 \n', 'isCorrect': '-1'}]","【答案解析】正向代理代理的是客户端,反向代理代理的是服务终端
","【正确答案】D
"
"
多选题 （共计 2 题，总计 4分）
6、
(多选题)解决Session共享的正确办法是？
","[{'optionContent': 'A.Nginx的ip-hash黏着,永远访问一台终端 \n', 'isCorrect': '-1'}, {'optionContent': 'B.引入redis,使得session数据存放在公用位置 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用cookie解决session共享 \n', 'isCorrect': '-1'}, {'optionContent': 'D.使用框架spring session \n', 'isCorrect': '-1'}]","【答案解析】Nginx提供的hash黏着效果不好,redis有效的使用外界存储空间解决session共享,spring也提供了框架维度的技术spring session解决session共享位置,本质还是将session对象存放在redis等数据库中
","【正确答案】A,B,D
"
"
7、
在easymall项目中nginx的主要作用有哪些
","[{'optionContent': 'A.动静分离 \n', 'isCorrect': '-1'}, {'optionContent': 'B.负载均衡 \n', 'isCorrect': '-1'}, {'optionContent': 'C.主从复制 \n', 'isCorrect': '-1'}, {'optionContent': 'D.分片计算 \n', 'isCorrect': '-1'}]","【答案解析】图片静态分离,集群负载均衡是nginx的作用
","【正确答案】A,B
"
"

框架SpringBoot
1、
以下不是Spring Boot优点的是？
","[{'optionContent': 'A.减少开发，测试时间和努力。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.优化代码，提高程序执行效率。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.避免大量的 Maven 导入和各种版本冲突。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish或其他任何东西。 \n', 'isCorrect': '-1'}]","【答案解析】由于引入了Starter等冗余，使得Spring boot的初始化十分缓慢。
","【正确答案】B
"
"2
、
如果在Spring Boot中集成Mybatis？
","[{'optionContent': 'A.SpringBoot中已经整合Mybatis，故可以直接使用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.需要引入Mybatis提供的Starter包 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring Boot中无MyBatis的支持，故无法使用。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.需要引入Spring Boot提供的Starter包 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"3
、
(单选题)如果在全局配置文件中自定义属性数据，可以通过以下哪个注解注入到对象中？
","[{'optionContent': 'A.@Component \n', 'isCorrect': '-1'}, {'optionContent': 'B.@Value \n', 'isCorrect': '-1'}, {'optionContent': 'C.@Service \n', 'isCorrect': '-1'}, {'optionContent': 'D.@Configuration \n', 'isCorrect': '-1'}]","【答案解析】@Value通过后处理bean方式,利用反射技术将读取的properties属性注入到类的属性中,@ConfigurationProperties也可以实现属性注入,需要getter和setter的提供
","【正确答案】B
"
"4
、
对纵向拆分项目描述正确的是
","[{'optionContent': 'A.任何功能的项目都可以执行纵向拆分 \n', 'isCorrect': '-1'}, {'optionContent': 'B.将controller service mapper拆分成3个工程的过程称为纵向拆分 \n', 'isCorrect': '-1'}, {'optionContent': 'C.所有的web应用都需要纵向拆分 \n', 'isCorrect': '-1'}, {'optionContent': 'D.纵向拆分能够解决单体web项目的功能耦合,和并发集中的问题 \n', 'isCorrect': '-1'}]","【答案解析】纵向拆分是根据业务功能拆分成独立运行的各个微小功能的过程,横向拆分才是根据控制层,业务层,持久层进行拆分,拆分目的是方便分模块开发,最终运行还是一个系统
","【正确答案】D
"
"5
、
(单选题)以下功能不是SpringBoot中application.properties配置文件的作用的是？
","[{'optionContent': 'A.定义访问端口 \n', 'isCorrect': '-1'}, {'optionContent': 'B.定义渲染页面的前缀后缀 \n', 'isCorrect': '-1'}, {'optionContent': 'C.定义数据库访问配置 \n', 'isCorrect': '-1'}, {'optionContent': 'D.定义启动类的位置 \n', 'isCorrect': '-1'}]","【答案解析】启动类需要手动配置,可以在插件中实现main方法的加载位置配置
","【正确答案】D
"
"6
、
测试
","[{'optionContent': 'A.测试1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.测试2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.测试3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.测试4 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"7
、
(单选题)在maven工程中的SpringBoot的全局配置文件一般要存在于哪个目录？
","[{'optionContent': 'A.src/main/resources \n', 'isCorrect': '-1'}, {'optionContent': 'B.src/main/java \n', 'isCorrect': '-1'}, {'optionContent': 'C.src/main/test \n', 'isCorrect': '-1'}, {'optionContent': 'D.项目根目录 \n', 'isCorrect': '-1'}]","【答案解析】配置文件在maven工程中都需要放到src/main/resources,springboot的全局配置文件也是一样
","【正确答案】A
"
"8
、
(单选题)下列对于properties和yml格式的配置文件说法错误的是?
","[{'optionContent': 'A.企业中常见的配置文件都是properties格式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.yml是一种配置文件格式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.yml格式的配置文件更能体现出层级的关系 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在SpringBoot中，全局文件可以使用properties也可以使用yml但是不要同时存在 \n', 'isCorrect': '-1'}]","【答案解析】企业常见的是yml格式,容易配置层级关系
","【正确答案】A
"
"
8、(单选题)JSON描述不正确的是？
","[{'optionContent': 'A.是一种文本数据传输的格式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.只能携带String类型的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以被ajax解析为js代码的对象数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以携带数组,集合类型的数据 \n', 'isCorrect': '-1'}]","【答案解析】Java的对象可以解析成json字符串,所以可以以json格式携带java的类型
","【正确答案】B
"
"
9、
如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？
","[{'optionContent': 'A.在Junit里运行项目 \n', 'isCorrect': '-1'}, {'optionContent': 'B.不需要做任何操作即可实现 \n', 'isCorrect': '-1'}, {'optionContent': 'C.对Tomcat进行设置 \n', 'isCorrect': '-1'}, {'optionContent': 'D.将DevTools依赖集成如Springboot项目 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"
10、
Git中提交的命令是什么？
","[{'optionContent': 'A.git push -a \n', 'isCorrect': '-1'}, {'optionContent': 'B.git submit -a \n', 'isCorrect': '-1'}, {'optionContent': 'C.git publish -a \n', 'isCorrect': '-1'}, {'optionContent': 'D.git commit -a \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】D
"
"

11、
(单选题)以下是组合注解的是？
","[{'optionContent': 'A.@RestController \n', 'isCorrect': '-1'}, {'optionContent': 'B.@RequestMapping \n', 'isCorrect': '-1'}, {'optionContent': 'C.@Component \n', 'isCorrect': '-1'}, {'optionContent': 'D.@ResponseBody \n', 'isCorrect': '-1'}]","【答案解析】RestController组合了ResponseBody和Controller
","【正确答案】A
"
"
12、
以下注解属于springboot的是
","[{'optionContent': 'A.@RestController \n', 'isCorrect': '-1'}, {'optionContent': 'B.@EnableAutoConfiguration \n', 'isCorrect': '-1'}, {'optionContent': 'C.@Configuration \n', 'isCorrect': '-1'}, {'optionContent': 'D.@ComponentScan \n', 'isCorrect': '-1'}]","【答案解析】启动类中@SpringBootApplication的组合核心注解之一,EnableAutoConfiguration,作用是根据依赖读取配置类
","【正确答案】B
"
"

13、
Springboot项目的默认端口号是？
","[{'optionContent': 'A.80 \n', 'isCorrect': '-1'}, {'optionContent': 'B.8080 \n', 'isCorrect': '-1'}, {'optionContent': 'C.443 \n', 'isCorrect': '-1'}, {'optionContent': 'D.3306 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"14、
GIT是用那种语言编写的？
","[{'optionContent': 'A.Java \n', 'isCorrect': '-1'}, {'optionContent': 'B.C \n', 'isCorrect': '-1'}, {'optionContent': 'C.C++ \n', 'isCorrect': '-1'}, {'optionContent': 'D.Erlang \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】B
"
"
15、
SpringBoot程序的主入口，用什么注解以运行？

16、
关于Git和SVN，以下说法错误的是？
","[{'optionContent': 'A.@SpringEntrance \n', 'isCorrect': '-1'}, {'optionContent': 'B.@SpringApplicationEntrance \n', 'isCorrect': '-1'}, {'optionContent': 'C.@SpringBootApplication \n', 'isCorrect': '-1'}, {'optionContent': 'D.@SpringBootEntrance \n', 'isCorrect': '-1'}, {'optionContent': 'A.SVN的push/pull操作更快。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Git可以离线提交，但是SVN只能在线提交。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Git是一个分布式版本控制工具 \n', 'isCorrect': '-1'}, {'optionContent': 'D.SVN是集中式的版本控制工具 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"
17、
注解@Configuration的作用是什么()
","[{'optionContent': 'A.类注解,标识一个类是配置类,可以在其中进行配置相关代码编写 \n', 'isCorrect': '-1'}, {'optionContent': 'B.类注解,扫描当前类所在的包,以及下级包的路径- \n', 'isCorrect': '-1'}, {'optionContent': 'C.类注解,读取properties的属性赋值给当前类的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.方法注解,让方法返回值作为spring ioc容器对象使用 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A
"
"

多选题 （共计 8 题，总计 16分）
18、
(多选题)SpringBoot中@SpringBootApplication注解的作用是？
","[{'optionContent': 'A.自动配置 \n', 'isCorrect': '-1'}, {'optionContent': 'B.依赖配置 \n', 'isCorrect': '-1'}, {'optionContent': 'C.自动扫描 \n', 'isCorrect': '-1'}, {'optionContent': 'D.导入xml \n', 'isCorrect': '-1'}]","【答案解析】配置,扫描,自动根据依赖做相关配置是核心注解的三大作用,需要配合@ImportResource来实现额外的xml导入
","【正确答案】A,B,C
"
"
19、
(多选题)对于下列注解解释正确的是？
","[{'optionContent': 'A.@SpringBootConfiguration:读取springboot的配置文件application.properties \n', 'isCorrect': '-1'}, {'optionContent': 'B.@EnableAutoConfiguration: 根据依赖的jar包将springboot工程需要的其他内容进行自动配置,例如依赖了starter-web,springboot会认为你要开发一个web应用,web.xml;对于没有的配置使用默认管理 \n', 'isCorrect': '-1'}, {'optionContent': 'C.@ComponentScan: 启动类所在的包路径的同级包和下级包中所有spring需要加载,启动的注解一旦存在,将会自动在spring容器启动时,加载到内存中,等待注入,等待使用. \n', 'isCorrect': '-1'}, {'optionContent': 'D.@Controller:只是spring的注解,springmvc不会关心它的存在 \n', 'isCorrect': '-1'}]","【答案解析】springBootApplication的三个核心组合注解,SpringBootConfiguration,EnableAutoConfiguration,ComponentScan各自的作用
","【正确答案】A,B,C
"
"
20、
(多选题)对springboot框架描述正确的是
","[{'optionContent': 'A.独立运行spring容器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.实现java转向静态语言的框架 \n', 'isCorrect': '-1'}, {'optionContent': 'C.快速搭建应用工程 \n', 'isCorrect': '-1'}, {'optionContent': 'D.只是在测试环节使用的框架 \n', 'isCorrect': '-1'}]","【答案解析】Java语言不会因为框架转向静态语言,springboot是企业生产级别的框架,各大公司都在使用
","【正确答案】A,C
"
"
21、
对@ConfigurationProperties注解描述正确的是
","[{'optionContent': 'A.底层实现原理和@Value一样 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以读取配置文件.properties中定义的属性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以通过key值的多级配置在类中实现多级包装读取 \n', 'isCorrect': '-1'}, {'optionContent': 'D.必须在类中实现getter和setter方法才能赋值给属性 \n', 'isCorrect': '-1'}]","【答案解析】A错误,@Value注解可以在没有getter和setter方法时利用底层的反射后处理bean机制对私有属性赋值,但是@ConfigurationProperties注解使通过对象创建后,对属性key做多级计算,使用set方法赋值
","【正确答案】B,C,D
"
"
22、
以下对@Conditional注解描述错误的是
","[{'optionContent': 'A.条件注解 \n', 'isCorrect': '-1'}, {'optionContent': 'B.有一系列的衍生注解,例如ConditionalOnMissingClass \n', 'isCorrect': '-1'}, {'optionContent': 'C.衍生注解ConditionalOnBean的作用是当容器不存在Bean时,条件满足 \n', 'isCorrect': '-1'}, {'optionContent': 'D.衍生注解ConditionalOnMissingClass的作用是当前环境具备某些依赖类时,条件满足 \n', 'isCorrect': '-1'}]","【答案解析】ConditionalOnBean是容器存在对象条件满足,ConditionalOnMissingClass是环境缺少条件的类才满足条件
","【正确答案】C,D
"
"
23、
(多选题)SpringBoot中的@SpringBootApplication注解是一个组合注解，是由以下哪几个注解组合而成？
","[{'optionContent': 'A.ComponentScan \n', 'isCorrect': '-1'}, {'optionContent': 'B.SpringBootConfiguration \n', 'isCorrect': '-1'}, {'optionContent': 'C.EnableAutoConfiguration \n', 'isCorrect': '-1'}, {'optionContent': 'D.Component \n', 'isCorrect': '-1'}]","【答案解析】核心注解有3个注解组合而成ComponentScan SpringBootConfiguration SpringBootConfiguration
","【正确答案】A,B,C
"
"
24、
如果需要用Junit测试Springboot，则那些是必须的？
@Test 
@Test 
@RunWith(SpringRunner.class)
@SpringBootTest 
@RunWith(SpringRunner.class)
@SpringBootTest 
","[{'optionContent': 'A.需要在测试方法上添加注解：\n', 'isCorrect': '-1'}, {'optionContent': 'B.需要在测试类上添加注解：\n', 'isCorrect': '-1'}, {'optionContent': 'C.需要在测试类上添加注解：\n', 'isCorrect': '-1'}, {'optionContent': 'D.需要在测试方法上添加注解：\n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A,C
"
"
25、
(多选题)我们手动搭建	SpringBoot的maven工程时，为什么要在pom文件中添加父级依赖？
","[{'optionContent': 'A.使当前工程成为一个标准的支持SpringBoot的工程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.不用再添加跟SpringBoot相关的其他依赖 \n', 'isCorrect': '-1'}, {'optionContent': 'C.继承springboot的特性,简化依赖无需版本 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以使当前工程满足web应用 \n', 'isCorrect': '-1'}]","【答案解析】Springboot继承仅仅是继承一些特性,具体实现任何功能还需要一一添加对应依赖资源
","【正确答案】A,C
"
"
26、(单选题)利用以下哪个注解可以使SpringBoot工程扫描到Mybatis实现的接口类?
","[{'optionContent': 'A.@ImportResource \n', 'isCorrect': '-1'}, {'optionContent': 'B.@SpringBootConfiguration \n', 'isCorrect': '-1'}, {'optionContent': 'C.@ComponentScan \n', 'isCorrect': '-1'}, {'optionContent': 'D.@MapperScan \n', 'isCorrect': '-1'}]","【答案解析】Mybatis整合springboot提供了专门的依赖资源,实现接口包扫描不需要xml,只需要@MapperScan
","【正确答案】D
"
"

Maven
1、
Maven项目管理时使用的核心配置文件是
","[{'optionContent': 'A.Server.xml \n', 'isCorrect': '-1'}, {'optionContent': 'B.Pom.xml \n', 'isCorrect': '-1'}, {'optionContent': 'C.Application.xml \n', 'isCorrect': '-1'}, {'optionContent': 'D.Parent.xml \n', 'isCorrect': '-1'}]","【答案解析】Pom是maven最核心的项目管理文件
","【正确答案】B
"
"
2、
关于maven说法错误的是（）
","[{'optionContent': 'A.需要配置一个MAVEN_HOME,然后再path中添加对应的bin \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以在maven的配置文件setting.xml中修改本地仓库的位置、更换镜像 \n', 'isCorrect': '-1'}, {'optionContent': 'C.maven不需要依赖JDK \n', 'isCorrect': '-1'}, {'optionContent': 'D.maven根据pom.xml，首先从本地资源库获取依赖资源，如果没有将从默认的Maven中央存储库中查找下载 \n', 'isCorrect': '-1'}]","【答案解析】Maven的启动需要jdk支持
","【正确答案】C
"
"
多选题 （共计 1 题，总计 2分）
3、
(多选题)maven install的作用?
","[{'optionContent': 'A.将工程打包安装，可以放到一个jdk环境中利用命令启动 \n', 'isCorrect': '-1'}, {'optionContent': 'B.将工程打包安装到本地库,支持后续发布操作的前提 \n', 'isCorrect': '-1'}, {'optionContent': 'C.更新当前工程，可以解决一些常见的错误 \n', 'isCorrect': '-1'}, {'optionContent': 'D.包含了package的过程,会在install是将工程包放到本工程的target下 \n', 'isCorrect': '-1'}]","【答案解析】Install包含了package,实现了工程编译,测试,打包,安装到本地库的操作
","【正确答案】A,B,D
"
"

shell脚本
1、
显示一个文件最后几行的命令是：
","[{'optionContent': 'A.cat \n', 'isCorrect': '-1'}, {'optionContent': 'B.tail \n', 'isCorrect': '-1'}, {'optionContent': 'C.ls \n', 'isCorrect': '-1'}, {'optionContent': 'D.last \n', 'isCorrect': '-1'}]","【答案解析】本题中提到的命令只有cat和tail能用来查看文件内容，其中cat命令是将全部的内容进行显示。
","【正确答案】B
"
"
2、
LINUX所有服务的启动脚本都存放在（ ）目录中
","[{'optionContent': 'A./etc/rc.d/init.d \n', 'isCorrect': '-1'}, {'optionContent': 'B./etc/init.d \n', 'isCorrect': '-1'}, {'optionContent': 'C./etc/rc.d/rc \n', 'isCorrect': '-1'}, {'optionContent': 'D./etc/rc.d \n', 'isCorrect': '-1'}]","【答案解析】该目录是固定的存放目录。
","【正确答案】A
"
"
3、
一个bash shell脚本的第一行是？
","[{'optionContent': 'A.#/bin/sh \n', 'isCorrect': '-1'}, {'optionContent': 'B.!#/bin/bash \n', 'isCorrect': '-1'}, {'optionContent': 'C./bin/bash \n', 'isCorrect': '-1'}, {'optionContent': 'D.#!/bin/bash \n', 'isCorrect': '-1'}]","【答案解析】#!和!#的区别
","【正确答案】D
"
"

软件包管理-shell基础
1、
解压缩tar.bz2结尾的包需要用的指令是：
","[{'optionContent': 'A.tar -zxvf *.tar.bz2 \n', 'isCorrect': '-1'}, {'optionContent': 'B.rpm -i *.tar.bz2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.tar –jxvf *.tar.bz2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.scp –r *.tar.bz2 \n', 'isCorrect': '-1'}]","【答案解析】注意tar命令解压时的文件后缀要使用对应的算法。gz结尾使用-z(gzip)，bz2结尾使用-j(bzip2)。
","【正确答案】C
"
"
2、
下面哪个命令是用来定义shell的全局变量
","[{'optionContent': 'A.exportfs \n', 'isCorrect': '-1'}, {'optionContent': 'B.alias \n', 'isCorrect': '-1'}, {'optionContent': 'C.exports \n', 'isCorrect': '-1'}, {'optionContent': 'D.export \n', 'isCorrect': '-1'}]","【答案解析】将普通变量设置为系统变量可以通过export关键字进行。
","【正确答案】D
"
"
3、
安装rpm包需要用到的指令是：
","[{'optionContent': 'A.rpm -b *.rpm \n', 'isCorrect': '-1'}, {'optionContent': 'B.rpm -h *.rpm \n', 'isCorrect': '-1'}, {'optionContent': 'C.rpm -ivh *.rpm \n', 'isCorrect': '-1'}, {'optionContent': 'D.rpm -v *.rpm \n', 'isCorrect': '-1'}]","【答案解析】rpm在安装软件时必须要有-i选项，否则无法进行安装，i表示install。
","【正确答案】C
"
"
4、
若要将当前目录中的 myfile.txt 文件压缩成myfile.txt.tar.gz,则实现的命令为？
","[{'optionContent': 'A.tar -cvf myfile.txt \n', 'isCorrect': '-1'}, {'optionContent': 'B.tar -zcvf myfile.txt myfile.txt.tar.gz \n', 'isCorrect': '-1'}, {'optionContent': 'C.tar -zcvf myfile.txt.tar.gz myfile.txt \n', 'isCorrect': '-1'}, {'optionContent': 'D.tar -cvf myfile.txt.tar.gz myfile.txt \n', 'isCorrect': '-1'}]","【答案解析】需要注意tar命令压缩文件(夹)的格式问题tar 选项 newFileName.tar.gz sourceFileName
","【正确答案】C
"
"
5、
为卸载一个软件包，应使用的命令是？
","[{'optionContent': 'A.rpm -i \n', 'isCorrect': '-1'}, {'optionContent': 'B.rpm -e \n', 'isCorrect': '-1'}, {'optionContent': 'C.rpm -q \n', 'isCorrect': '-1'}, {'optionContent': 'D.rpm -v \n', 'isCorrect': '-1'}]","【答案解析】rpm -i用来安装、-q用来查询软件、-v显示过程、-e是用来卸载。
","【正确答案】B
"
"
进程-监控-vim
1、
当登录Linux时，一个具有唯一进程ID号的shell将被调用，这个ID是什么？
","[{'optionContent': 'A.NID \n', 'isCorrect': '-1'}, {'optionContent': 'B.PID \n', 'isCorrect': '-1'}, {'optionContent': 'C.CID \n', 'isCorrect': '-1'}, {'optionContent': 'D.UID \n', 'isCorrect': '-1'}]","【答案解析】当一个程序被运行时，系统会为其分配一个ID，此ID称之为进程(process)ID，故为PID。
","【正确答案】B
"
"
2、
vim中哪条命令是不保存强制退出
","[{'optionContent': 'A.:wq \n', 'isCorrect': '-1'}, {'optionContent': 'B.:wq! \n', 'isCorrect': '-1'}, {'optionContent': 'C.:Q! \n', 'isCorrect': '-1'}, {'optionContent': 'D.:q! \n', 'isCorrect': '-1'}]","【答案解析】wq为保存退出，wq！为强制保存退出，Q!大写的Q不能被系统识别为命令。所以D选项是正确答案
","【正确答案】D
"
"
3、
在vim编辑器里，命令""dd""用来删除当前的？
","[{'optionContent': 'A.行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.变量 \n', 'isCorrect': '-1'}, {'optionContent': 'C.字符 \n', 'isCorrect': '-1'}, {'optionContent': 'D.所有内容 \n', 'isCorrect': '-1'}]","【答案解析】dd只能用来删除光标当前所在的行。
","【正确答案】A
"
"
4、
以下哪个命令可以终止一个java程序的所有进程
","[{'optionContent': 'A.skillall \n', 'isCorrect': '-1'}, {'optionContent': 'B.skill \n', 'isCorrect': '-1'}, {'optionContent': 'C.kill \n', 'isCorrect': '-1'}, {'optionContent': 'D.killall \n', 'isCorrect': '-1'}]","【答案解析】kill只能结束某一个进程，killall可以结束以某个程序运行的所有程序。
","【正确答案】D
"
"
5、
以下哪个指令是查看进程：
","[{'optionContent': 'A.chmod –R /etc \n', 'isCorrect': '-1'}, {'optionContent': 'B.mv /etc /bin \n', 'isCorrect': '-1'}, {'optionContent': 'C.cp -r /etc \n', 'isCorrect': '-1'}, {'optionContent': 'D.ps –aux  \n', 'isCorrect': '-1'}]","【答案解析】上述命令中除ps外，其他命令与查看进程无关。
","【正确答案】D
"
"
用户-组-权限-文件
1、
改变文件所有者的命令为()
","[{'optionContent': 'A.chown \n', 'isCorrect': '-1'}, {'optionContent': 'B.chgrp \n', 'isCorrect': '-1'}, {'optionContent': 'C.chmod \n', 'isCorrect': '-1'}, {'optionContent': 'D.touch \n', 'isCorrect': '-1'}]","【答案解析】chown命令可改文件或目录的属主和属组
","【正确答案】A
"
"
2、
下面哪个参数可以删除一个用户并同时删除用户的主目录
","[{'optionContent': 'A.rmuser -r \n', 'isCorrect': '-1'}, {'optionContent': 'B.deluser -r \n', 'isCorrect': '-1'}, {'optionContent': 'C.userdel -r \n', 'isCorrect': '-1'}, {'optionContent': 'D.usermgr -r \n', 'isCorrect': '-1'}]","【答案解析】除C选项外，其他的命令都不是Linux系统中的
","【正确答案】C
"
"
3、
Linux系统下，有一个文件为""baidu.txt""，如果想为这个文件的所有者赋予可读和可执行权限,应该用下面那个命令?
","[{'optionContent': 'A.chmod u+wx baidu.txt \n', 'isCorrect': '-1'}, {'optionContent': 'B.chown u+wx baidu.txt \n', 'isCorrect': '-1'}, {'optionContent': 'C.chmod 500 baidu.txt \n', 'isCorrect': '-1'}, {'optionContent': 'D.chown 500 baidu.txt \n', 'isCorrect': '-1'}]","【答案解析】chmod用来改变文件的读、写、执行权限。chown是用来修改文件的属主、属组权限。
","【正确答案】C
"
"
4、
以下不是linux系统支默认持的分区格式的是 ？
","[{'optionContent': 'A.EXT3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.EXT4 \n', 'isCorrect': '-1'}, {'optionContent': 'C.FAT32 \n', 'isCorrect': '-1'}, {'optionContent': 'D.NTFS \n', 'isCorrect': '-1'}]","【答案解析】NTFS是windows(微软)的文件系统格式。Linux不支持此文件系统
","【正确答案】D
"
"
5、
当使用mount进行设备或者文件系统挂载的时候，需要用到的设备名称位于()目录。
","[{'optionContent': 'A./home \n', 'isCorrect': '-1'}, {'optionContent': 'B./bin \n', 'isCorrect': '-1'}, {'optionContent': 'C./etc \n', 'isCorrect': '-1'}, {'optionContent': 'D./dev \n', 'isCorrect': '-1'}]","【答案解析】Linux的所有外部文件都存储在/dev目录下。
","【正确答案】D
"
"
6、
Linux改变文件属组的命令为？
","[{'optionContent': 'A.chmod \n', 'isCorrect': '-1'}, {'optionContent': 'B.touch \n', 'isCorrect': '-1'}, {'optionContent': 'C.chattr \n', 'isCorrect': '-1'}, {'optionContent': 'D.chown \n', 'isCorrect': '-1'}]","【答案解析】此命令既可以修改属主也可以修改属组。
","【正确答案】D
"
"
7、
默认情况下管理员创建了一个用户，就会在( )目录下创建一个用户主目录
","[{'optionContent': 'A./usr \n', 'isCorrect': '-1'}, {'optionContent': 'B./user \n', 'isCorrect': '-1'}, {'optionContent': 'C./root \n', 'isCorrect': '-1'}, {'optionContent': 'D./home \n', 'isCorrect': '-1'}]","【答案解析】linux默认没有user目录。默认情况下所有的普通用户都在/home目录下。
","【正确答案】D
"
"
8、
哪个命令可以将普通用户转换成超级用户( )
","[{'optionContent': 'A.super \n', 'isCorrect': '-1'}, {'optionContent': 'B.passwd \n', 'isCorrect': '-1'}, {'optionContent': 'C.sudo \n', 'isCorrect': '-1'}, {'optionContent': 'D.su \n', 'isCorrect': '-1'}]","【答案解析】super、passwd与超级用户无关，sudo是普通用户执行root权限(需要进行配置)
","【正确答案】D
"
"
9、
以长格式列目录时，若文件test的权限描述为：drwxrw-r--，则文件test的类型及文件属主的权限是
","[{'optionContent': 'A.目录文件、读写执行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.目录文件、读写 \n', 'isCorrect': '-1'}, {'optionContent': 'C.普通文件、读写执行 \n', 'isCorrect': '-1'}, {'optionContent': 'D.普通文件、读写 \n', 'isCorrect': '-1'}]","【答案解析】Linux系统将所有内容都视为“文件”，文件夹被视为“目录文件”，所有文件都具备10个标识位，第一个标识位就是该文件的类型，剩余的9个表示权限、每三个为一组，每一组有三个权限，分别是读、写、执行。其位置不会因为任何原因发生变化。
","【正确答案】A
"
"
10、
在Linux系统中，有一个test文件，它的权限为-rw--wx--x，如果用数字表示权限则是
","[{'optionContent': 'A.641 \n', 'isCorrect': '-1'}, {'optionContent': 'B.742 \n', 'isCorrect': '-1'}, {'optionContent': 'C.652 \n', 'isCorrect': '-1'}, {'optionContent': 'D.631 \n', 'isCorrect': '-1'}]","【答案解析】Linux系统中每个文件都有三组权限，每一组中都具有读、写、执行权限，分别对应的数字为4、2、1。计算时，数字相加即可。
","【正确答案】D
"
"
多选题 （共计 5 题，总计 10分）
11、
虚拟机中机器A想配置在B上的免密登录，配置免密登录操作中说法的正确是？
","[{'optionContent': 'A.机器A把公钥远程传送到机器B上 \n', 'isCorrect': '-1'}, {'optionContent': 'B.机器B向A发送一个经过私钥加密的随机字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'C.机器A用私钥解密机器B发送过来的字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'D.机器A用公钥解密机器B发送过来的字符串 \n', 'isCorrect': '-1'}]","【答案解析】假设机器A已创建好公、私钥，若想实现免密登录，A就需要将自己的公钥发到B进行注册。此后A拥有着私钥即可访问B。
","【正确答案】A,C
"
"
12、
虚拟机中机器A想配置在B上的免密登录，配置免密登录操作中说法的正确是？
","[{'optionContent': 'A.机器A把公钥远程传送到机器B上 \n', 'isCorrect': '-1'}, {'optionContent': 'B.机器B向A发送一个经过私钥加密的随机字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'C.机器A用私钥解密机器B发送过来的字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'D.机器A用公钥解密机器B发送过来的字符串 \n', 'isCorrect': '-1'}]","【答案解析】假设机器A已创建好公、私钥，若想实现免密登录，A就需要将自己的公钥发到B进行注册。此后A拥有着私钥即可访问B。
","【正确答案】A,C
"
"
13、
以下用户和组管理命令描述正确的是？
","[{'optionContent': 'A.useradd 命令可以用来添加用户 \n', 'isCorrect': '-1'}, {'optionContent': 'B.su – 用户名和su 用户名的效果一样 \n', 'isCorrect': '-1'}, {'optionContent': 'C.groupadd命令可以用来创建用户组 \n', 'isCorrect': '-1'}, {'optionContent': 'D.userdel 用户名，可以彻底删除一个用户。 \n', 'isCorrect': '-1'}]","【答案解析】su – 用户名之后会切换到对应用户的环境，su 用户名会停留在前用户的环境。userdel需要使用-r选项才能够彻底删除用户。
","【正确答案】A,C
"
"
14、
对于所有用户都能读的用户权限是？
","[{'optionContent': 'A.777 \n', 'isCorrect': '-1'}, {'optionContent': 'B.444 \n', 'isCorrect': '-1'}, {'optionContent': 'C.644 \n', 'isCorrect': '-1'}, {'optionContent': 'D.555 \n', 'isCorrect': '-1'}]","【答案解析】读、写、执行权限对应的数字分别是4、2、1
","【正确答案】A,B,C,D
"
"
15、
下面关于防火墙的操作正确的是？(系统版本：CentOS6.5)
","[{'optionContent': 'A.service iptables start \n', 'isCorrect': '-1'}, {'optionContent': 'B./etc/init.d/iptables restart \n', 'isCorrect': '-1'}, {'optionContent': 'C.chkconfig iptables off \n', 'isCorrect': '-1'}, {'optionContent': 'D.service iptables stop \n', 'isCorrect': '-1'}]","【答案解析】在CentOS6.5版本中service和/etc/init.d/都可以对防火墙软件进行操作，chkconfig命令可以用来设置防火墙的永久状态。
","【正确答案】A,B,C,D
"
"

Linux入门与基础
1、
假设文件fileA的符号链接为fileB，那么删除fileA后，下面的描述正确的是
","[{'optionContent': 'A.fileB也随之被删除 \n', 'isCorrect': '-1'}, {'optionContent': 'B.fileB仍存在，但是属于无效文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.因为fileB未被删除，所以fileA会被系统自动重新建立 \n', 'isCorrect': '-1'}, {'optionContent': 'D.fileB会随fileA的删除而被系统自动删除 \n', 'isCorrect': '-1'}]","【答案解析】符号链接相当于是windows平台下的快捷键，软件被删除说，快捷键并不会被删除掉
","【正确答案】B
"
"
1、在创建Linux分区时，一定要创建（ ）两个分区
","[{'optionContent': 'A.FAT/NTFS \n', 'isCorrect': '-1'}, {'optionContent': 'B.FAT/SWAP \n', 'isCorrect': '-1'}, {'optionContent': 'C.NTFS/SWAP \n', 'isCorrect': '-1'}, {'optionContent': 'D.SWAP/根分区 \n', 'isCorrect': '-1'}]","【答案解析】根分区一般都是存放文件的。swap是交换分区(虚拟内存)，该分区用来提升系统的性能。
","【正确答案】D
"
"
2、
以下哪个命令，不是Linux命令？
","[{'optionContent': 'A.pwd \n', 'isCorrect': '-1'}, {'optionContent': 'B.cd \n', 'isCorrect': '-1'}, {'optionContent': 'C.ls \n', 'isCorrect': '-1'}, {'optionContent': 'D.ipconfig \n', 'isCorrect': '-1'}]","【答案解析】ipconfig是windows平台下用来查看网络信息的命令，linux平台下使用的是ifconfig
","【正确答案】D
"
"3
、
在LINUX运行的7个级别中，X—WINDOWS图形系统的运行级别为
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.5 \n', 'isCorrect': '-1'}, {'optionContent': 'D.6 \n', 'isCorrect': '-1'}]","【答案解析】1为单用户、3为命令行、5为图形化、6为重启。
","【正确答案】C
"
"
3、关于Linux命令作用下面说法错误的是()
","[{'optionContent': 'A.ps -ef 可以显示所有进程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.cat /proc 可以查看物理内存的大小 \n', 'isCorrect': '-1'}, {'optionContent': 'C.tar 命令可以用来解压xxxx.bz2文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.netstat 可以监控所有进程 \n', 'isCorrect': '-1'}]","【答案解析】netstat只能用来查看和网络相关的、ps查看所有进程需用-aux选项。cat只能查看文件。
","【正确答案】C
"
"
4
、
下面哪个系统目录中包含Linux使用的外部设备
","[{'optionContent': 'A./bin \n', 'isCorrect': '-1'}, {'optionContent': 'B./dev \n', 'isCorrect': '-1'}, {'optionContent': 'C./boot \n', 'isCorrect': '-1'}, {'optionContent': 'D./home \n', 'isCorrect': '-1'}]","【答案解析】Linux系统下，将所有的外部设备都保存在/dev目录下，例如，硬盘，U盘，光盘等。
","【正确答案】B
"
"
5、
如果要列出一个目录下的所有文件需要使用命令行？
","[{'optionContent': 'A.ls -l \n', 'isCorrect': '-1'}, {'optionContent': 'B.ls \n', 'isCorrect': '-1'}, {'optionContent': 'C.ls -a \n', 'isCorrect': '-1'}, {'optionContent': 'D.ls -d \n', 'isCorrect': '-1'}]","【答案解析】ls -l查看相信信息、ls -d 查看指定目录、ls -a可以查看隐藏文件。
","【正确答案】C
"
"6
、
按下哪个键能终止当前运行的命令？
","[{'optionContent': 'A.Ctrl+c \n', 'isCorrect': '-1'}, {'optionContent': 'B.Ctrl+f \n', 'isCorrect': '-1'}, {'optionContent': 'C.Ctrl+b \n', 'isCorrect': '-1'}, {'optionContent': 'D.Ctrl+d \n', 'isCorrect': '-1'}]","【答案解析】Ctrl+c不仅可以用来停止当前的输入，也可以结束当前的程序运行，但严格意义上来说不是所有的程序都可以通过此组合键来结束。
","【正确答案】A
"
"7
、
以下关于/root目录的描述正确的是？
","[{'optionContent': 'A.Linux的根目录 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Linux中普通用户的家目录 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Linux中root用户的家目录 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不是 \n', 'isCorrect': '-1'}]","【答案解析】Linux系统完成安装之后默认创建了root账户，该账户为系统的管理员账户，系统中每个账户都会有一个固定的目录。
","【正确答案】C
"
"
8、
用 ""rm -i"",系统会提示什么来让你确认？
","[{'optionContent': 'A.命令行的每个选项 \n', 'isCorrect': '-1'}, {'optionContent': 'B.是否真的删除 \n', 'isCorrect': '-1'}, {'optionContent': 'C.直接删除，不会有任何的提示。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.文件的位置 \n', 'isCorrect': '-1'}]","【答案解析】命令是Linux系统的是删除命令，可以删除系统级别的文件。-i选项是进行询问是否真的要删除文件，-f是强制删除，不会提示。
","【正确答案】B
"
"
9、
下面关于文件 ""/etc/sysconfig/network-scripts/ifcfg-eth0""的描述哪个是正确的?
","[{'optionContent': 'A.它是一个可运行的系统脚本文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.它是一个可执行的文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.它记录着当前系统的名字 \n', 'isCorrect': '-1'}, {'optionContent': 'D.它指定本机eth0的ip地址、mac、子网等信息。 \n', 'isCorrect': '-1'}]","【答案解析】ifcfg-eth0只是一个配置文件，不可执行，在此记录着网卡的名称、ip地址、mac地址、子网、网关、dns等信息。
","【正确答案】D
"
"

9、统计磁盘空间或文件系统使用情况的命令是？
","[{'optionContent': 'A.df \n', 'isCorrect': '-1'}, {'optionContent': 'B.dd \n', 'isCorrect': '-1'}, {'optionContent': 'C.du \n', 'isCorrect': '-1'}, {'optionContent': 'D.fdisk \n', 'isCorrect': '-1'}]","【答案解析】fdisk用开查看当前系统中的硬盘分区情况。df用来查看文件系统的使用情况。
","【正确答案】A
"
"
10、
哪个目录存放用户密码信息？
","[{'optionContent': 'A./boot \n', 'isCorrect': '-1'}, {'optionContent': 'B./etc \n', 'isCorrect': '-1'}, {'optionContent': 'C./var \n', 'isCorrect': '-1'}, {'optionContent': 'D./dev \n', 'isCorrect': '-1'}]","【答案解析】Linux最初将密码信息存放在/etc/passwd文件下，后续的版本将密码存放在/etc/shadow文件下。
","【正确答案】B
"
"
10、若当前目录为/home,命令ls –l 将显示home目录下的
","[{'optionContent': 'A.所有文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.所有隐含文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.所有非隐含文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.文件的具体信息 \n', 'isCorrect': '-1'}]","【答案解析】ls -l命令是ll命令的缩写，-l选项用来查看文件的具体信息。
","【正确答案】D
"
"

11、
Linux下的/sbin目录通常包括Linux系统中的？
","[{'optionContent': 'A.设备文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.类库 \n', 'isCorrect': '-1'}, {'optionContent': 'C.配置文件 \n', 'isCorrect': '-1'}, {'optionContent': 'D.系统工具 \n', 'isCorrect': '-1'}]","【答案解析】sbin目录用来存放用于管理员使用的存储二进制系统程序文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。
","【正确答案】D
"
"
12、
在Linux系统中，系统默认的()用户对整个系统拥有完全的控制权。
","[{'optionContent': 'A.root \n', 'isCorrect': '-1'}, {'optionContent': 'B.guest \n', 'isCorrect': '-1'}, {'optionContent': 'C.administrator \n', 'isCorrect': '-1'}, {'optionContent': 'D.admin \n', 'isCorrect': '-1'}]","【答案解析】除root外，其他均不是Linux系统中的默认账户。
","【正确答案】A
"
"
13、
若要将鼠标从VM中释放出来，可按 （ ）键来实现
","[{'optionContent': 'A.Ctrl + Alt \n', 'isCorrect': '-1'}, {'optionContent': 'B.Ctrl +Alt +Del \n', 'isCorrect': '-1'}, {'optionContent': 'C.Ctrl +Alt +Enter \n', 'isCorrect': '-1'}, {'optionContent': 'D.Ctrl +Enter \n', 'isCorrect': '-1'}]","【答案解析】ctrl+alt可以让vmware释放鼠标
","【正确答案】A
"
"
13、除非特别指定，cp假定要拷贝的文件在下面哪个目录下？
","[{'optionContent': 'A.用户目录 \n', 'isCorrect': '-1'}, {'optionContent': 'B.home目录 \n', 'isCorrect': '-1'}, {'optionContent': 'C.root目录 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当前目录 \n', 'isCorrect': '-1'}]","【答案解析】如未指定目录的情况下，linux的命令基本上都是在当前目录下进行操作。
","【正确答案】D
"
"
14、
在Linux(Centos6.5)中，一般用（ ）命令来查看网络的状态
","[{'optionContent': 'A.ping \n', 'isCorrect': '-1'}, {'optionContent': 'B.ipconfig \n', 'isCorrect': '-1'}, {'optionContent': 'C.service iptables status \n', 'isCorrect': '-1'}, {'optionContent': 'D.ifconfig \n', 'isCorrect': '-1'}]","【答案解析】ping命令只能用来检查网络是否可通信，ipconfig是windows平台下的命令，service iptables status用来查看防火墙的状态，故，D为正确答案。
","【正确答案】D
"
"
多选题 （共计 1 题，总计 2分）
15、
系统中存在多个网络配置文件，不同的网络属性设置保存在不同的配置文件中，“/etc/sysconfig/network-script/”目录中的ifcfg-eth0文件中可能保存了（）信息
","[{'optionContent': 'A.网络接口eth0的IP地址和 子网掩码 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主机的缺省网关地址 \n', 'isCorrect': '-1'}, {'optionContent': 'C.主机名称 \n', 'isCorrect': '-1'}, {'optionContent': 'D.主机使用的DNS服务器地址 \n', 'isCorrect': '-1'}]","【答案解析】ifcfg-eth0属于机器的网卡配置文件，其中并没有包含了机器的主机名。
","【正确答案】A,B,D
"
"20、运行级定义在
","[{'optionContent': 'A./etc/inittab \n', 'isCorrect': '-1'}, {'optionContent': 'B./etc/runlevels \n', 'isCorrect': '-1'}, {'optionContent': 'C./bin \n', 'isCorrect': '-1'}, {'optionContent': 'D./sbin \n', 'isCorrect': '-1'}]","【答案解析】init是linux系统启动时的第一个进程，默认读取inittab文件中的配置内容
","【正确答案】A
"
"

SSM整合

mybatis
1、
关于mybatis中${}和#{}正确的是
","[{'optionContent': '无\n', 'isCorrect': '-1'}, {'optionContent': 'A.引用字符串类型时${}自动拼接单引号 \n', 'isCorrect': '-1'}, {'optionContent': 'B.引用字符串类型时#{}自动拼接单引号 \n', 'isCorrect': '-1'}, {'optionContent': 'C.引用非字符串类型时${}自动拼接单引号 \n', 'isCorrect': '-1'}, {'optionContent': 'D.引用非字符串类型时#{}自动拼接单引号 \n', 'isCorrect': '-1'}]","【答案解析】#{}和${}在传递非字符串类型时效果相同，都不会拼接引号，但传递字符串值时，#{}会自动拼接单引号，${}则不会
","【正确答案】B
"
"
多选题 （共计 8 题，总计 16分）
2、
当sql查询结果中的列名和要封装的bean的属性名无法对应时可以采用如下那种解决方案解决
","[{'optionContent': 'A.使用sql中的别名 \n', 'isCorrect': '-1'}, {'optionContent': 'B.配置bean的别名 \n', 'isCorrect': '-1'}, {'optionContent': 'C.手动映射结果集 \n', 'isCorrect': '-1'}, {'optionContent': 'D.自动映射结果集 \n', 'isCorrect': '-1'}]","【答案解析】当mybatis中sql查询结果列名和bean的属性名不一致时，可以通过使用sql别名或手动映射结果集解决。
","【正确答案】A,C
"
"
3、
关于mybatis基于接口的程序开发中说法正确的是
","[{'optionContent': 'A.映射文件中声明的名称空间应该为该映射文件对应的处理接口的全路径名称 \n', 'isCorrect': '-1'}, {'optionContent': 'B.接口中应该声明和映射文件中sql对应的id相同名称的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.方法接收的参数应该和sql中接收的参数一致 \n', 'isCorrect': '-1'}, {'optionContent': 'D.方法的返回值应该和sql中声明的返回值类型一致 \n', 'isCorrect': '-1'}]","【答案解析】mybatis可以基于接口进行程序开发，从而大大简化开发过程，以上四个说法都正确。
","【正确答案】A,B,C,D
"
"
4、
mybatis常用类包括
","[{'optionContent': 'A.SqlSessionFactory \n', 'isCorrect': '-1'}, {'optionContent': 'B.SqlSession \n', 'isCorrect': '-1'}, {'optionContent': 'C.ApplicationContext \n', 'isCorrect': '-1'}, {'optionContent': 'D.DispatcherServlet \n', 'isCorrect': '-1'}]","【答案解析】mybatis中SqlSessionFactory为工厂类，用来生产核心类SqlSession对象
","【正确答案】A,B
"
"
5、
下列关于mybatis说法正确的是
","[{'optionContent': 'A.mybatis是一个dao层框架 \n', 'isCorrect': '-1'}, {'optionContent': 'B.mybatis相对于hibernate更加轻量级 \n', 'isCorrect': '-1'}, {'optionContent': 'C.mybatis可以编写sql \n', 'isCorrect': '-1'}, {'optionContent': 'D.mybatis比jdbc执行效率高 \n', 'isCorrect': '-1'}]","【答案解析】mybatis是目前较为流行的dao层框架，相对于jdbc开发更加便捷，相对于hibernate更加轻量级，结合了两者优点，即可以像jdbc一样写sql保证灵活性，又类似hibernate实现的自动的bean封装，提高了开发开发效率，但无论怎样，底层仍然是jdbc，所以效率不可能比jdbc还要高。
","【正确答案】A,B,C
"
"
6、
mybatis缓存机制说法正确的是
","[{'optionContent': 'A.mybatis具有一级缓存、二级缓存两个级别的缓存 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一级缓存默认开启 \n', 'isCorrect': '-1'}, {'optionContent': 'C.二级缓存默认开启 \n', 'isCorrect': '-1'}, {'optionContent': 'D.二级缓存范围更大，可能的危害也更大 \n', 'isCorrect': '-1'}]","【答案解析】mybatis具有两级缓存，其中一级缓存在一个事务内部起作用。二级缓存跨事务起作用。一级缓存默认开启，二级缓存默认关闭，二级缓存作用范围更大，可能造成的危害也更大。
","【正确答案】A,B,D
"
"
7、
mybatis配置文件包括
","[{'optionContent': 'A.sqlMapConfig.xml \n', 'isCorrect': '-1'}, {'optionContent': 'B.xml格式的映射文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.applicationContext.xml \n', 'isCorrect': '-1'}, {'optionContent': 'D.mybatis.xml \n', 'isCorrect': '-1'}]","【答案解析】mybatis核心配置文件为sqlMapConfig.xml,工作中还要用到xml格式的映射文件。
","【正确答案】A,B
"
"
8、
mybatis支持的多表查询有哪几种方式
","[{'optionContent': 'A.一对一 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一对多 \n', 'isCorrect': '-1'}, {'optionContent': 'C.多对多 \n', 'isCorrect': '-1'}, {'optionContent': 'D.多对少 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】A,B,C
"
"
9、
mybatis值传递方式包括
","[{'optionContent': 'A.map传递 \n', 'isCorrect': '-1'}, {'optionContent': 'B.bean传递 \n', 'isCorrect': '-1'}, {'optionContent': 'C.单值传递 \n', 'isCorrect': '-1'}, {'optionContent': 'D.网络传递 \n', 'isCorrect': '-1'}]","【答案解析】mybatis中可以通过map、bean、单值传递方式实现值的传递
","【正确答案】A,B,C
"
"
springmvc
1、
关于springmvc的核心控制器DispatcherServlet的作用，以下说法错误的是？
","[{'optionContent': 'A.它负责处理HTTP请求 \n', 'isCorrect': '-1'}, {'optionContent': 'B.是一个真正的Servlet \n', 'isCorrect': '-1'}, {'optionContent': 'C.负责业务逻辑的处理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.是整个springmvc的中转中心 \n', 'isCorrect': '-1'}]","【答案解析】springmvc的前端控制器为DispatcherServlet,是springmvc中唯一的Servlet，主要负责程序的调度，本身不处理任何业务逻辑。
","【正确答案】C
"
"
2、
springmvc的中心控制Servlet是哪个类？（）
","[{'optionContent': 'A.ActionServlet \n', 'isCorrect': '-1'}, {'optionContent': 'B.DispatcherServlet \n', 'isCorrect': '-1'}, {'optionContent': 'C.AbstractController \n', 'isCorrect': '-1'}, {'optionContent': 'D.FacesServlet \n', 'isCorrect': '-1'}]","【答案解析】springmvc的前端控制器为DispatcherServlet
","【正确答案】B
"
"
3、
当在控制器方法中返回“redirect:/index.jsp”时如下说法正确的是
","[{'optionContent': 'A.返回的是视图名，经过视图解析器处理跳转到视图 \n', 'isCorrect': '-1'}, {'optionContent': 'B.将会触发请求转发到index.jsp \n', 'isCorrect': '-1'}, {'optionContent': 'C.将会触发请求重定向到index.jsp \n', 'isCorrect': '-1'}, {'optionContent': 'D.将会报错，因为路径中没有拼接应用名 \n', 'isCorrect': '-1'}]","【答案解析】springmvc中可以通过返回forward:xxx来实现请求转发，redirect:xxx来实现请求重定向。
","【正确答案】C
"
"
4、
将一个请求url指向一个类的方法的注解是？
","[{'optionContent': 'A.@RequestMapping \n', 'isCorrect': '-1'}, {'optionContent': 'B.@RequestParam \n', 'isCorrect': '-1'}, {'optionContent': 'C.@SessionAttribute \n', 'isCorrect': '-1'}, {'optionContent': 'D.@DispatcherServlet \n', 'isCorrect': '-1'}]","【答案解析】springmvc通过@RequestMapping来将一个方法注解为一个控制器方法
","【正确答案】A
"
"
多选题 （共计 6 题，总计 12分）
5、
关于springmvc获取请求参数的说法正确的是
","[{'optionContent': 'A.可以通过获取request对象获取请求参数 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以直接在控制器方法上接受请求参数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以直接通过一个bean接受请求参数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对于多个同名请求参数必须通过数组来获取 \n', 'isCorrect': '-1'}]","【答案解析】多个同名的请求参数可以通过单值字符串来获取此时获取到的是逗号分隔的值字符串，也可以通过数据来获取，直接得到的就是数组。
","【正确答案】A,B,C
"
"
6、
可以用作控制器方法参数的类型是
","[{'optionContent': 'A.HttpServletRequest \n', 'isCorrect': '-1'}, {'optionContent': 'B.HttpServletResponse \n', 'isCorrect': '-1'}, {'optionContent': 'C.HttpSession \n', 'isCorrect': '-1'}, {'optionContent': 'D.ServletContext \n', 'isCorrect': '-1'}]","【答案解析】ServletContext无法直接在控制器方法参数中获取。
","【正确答案】A,B,C
"
"
7、
可以用作控制器方法返回值类型的是
","[{'optionContent': 'A.ModelAndView \n', 'isCorrect': '-1'}, {'optionContent': 'B.String \n', 'isCorrect': '-1'}, {'optionContent': 'C.void \n', 'isCorrect': '-1'}, {'optionContent': 'D.HttpServletResponse \n', 'isCorrect': '-1'}]","【答案解析】返回ModelAndView封装数据和模型，返回字符串默认为视图名，返回void则默认采用当前控制器名作为视图名。
","【正确答案】A,B,C
"
"
8、
下列哪些是springmvc的组件？
","[{'optionContent': 'A.前端控制器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.处理器映射器 \n', 'isCorrect': '-1'}, {'optionContent': 'C.视图解析器 \n', 'isCorrect': '-1'}, {'optionContent': 'D.处理器适配器 \n', 'isCorrect': '-1'}]","【答案解析】springmvc的核心组件包括前端控制器、处理器映射器、处理器适配器、处理器、视图解析器、视图
","【正确答案】A,B,C,D
"
"
9、
下列哪些是@RequetMapping能够做到的
","[{'optionContent': 'A.使用在方法上 \n', 'isCorrect': '-1'}, {'optionContent': 'B.使用在类上 \n', 'isCorrect': '-1'}, {'optionContent': 'C.将访问路径映射到一个控制器方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.限定控制器方法只处理指定请求方式的请求 \n', 'isCorrect': '-1'}]","【答案解析】以上说法均正确。
","【正确答案】A,B,C,D
"
"
10、
关于springmvc文件上传的说法正确的是
","[{'optionContent': 'A.必须限定文件上传的大小 \n', 'isCorrect': '-1'}, {'optionContent': 'B.文件上传表单必须是post提交 \n', 'isCorrect': '-1'}, {'optionContent': 'C.文件上传表单必须设置enctype=""multipart/form-data"" \n', 'isCorrect': '-1'}, {'optionContent': 'D.文件上传项必须有name属性 \n', 'isCorrect': '-1'}]","【答案解析】文件上传可以设置文件上传大小限制，但不是必须的。
","【正确答案】B,C,D
"
"
Spring JDBC
1
、
Spring声明式事务管理使用的注解是
","[{'optionContent': 'A.@Trans \n', 'isCorrect': '-1'}, {'optionContent': 'B.@Tran \n', 'isCorrect': '-1'}, {'optionContent': 'C.@Transaction \n', 'isCorrect': '-1'}, {'optionContent': 'D.@Transactional \n', 'isCorrect': '-1'}]","【答案解析】Spring JDBC声明式事务处理的注解为@Transactional
","【正确答案】D
"
"多选题 （共计 1 题，总计 2分）
2
、
关于Spring声明式事务管理说法正确的是
","[{'optionContent': 'A.Spring声明式事务处理的基础是AOP \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring声明式事务处理默认只对运行时异常起作用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring声明式事务处理需要事务管理器的支持 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring声明式事务处理的注解需要配置在Dao的方法上 \n', 'isCorrect': '-1'}]","【答案解析】Spring JDBC声明式事务处理底层实际通过Spring的AOP来实现的，默认只对运行时异常有效，可以通过配置实现对额外的异常有效或无效，其底层是通过事务管理器集中的实现了事务管理，@Transactional注解要配置在Service层的方法上。
","【正确答案】A,B,C
"
"
Spring AOP
多选题 （共计 5 题，总计 10分）
1、
下列哪些不是AOP的通知类型
","[{'optionContent': 'A.前置通知 \n', 'isCorrect': '-1'}, {'optionContent': 'B.环绕前通知 \n', 'isCorrect': '-1'}, {'optionContent': 'C.异常前通知 \n', 'isCorrect': '-1'}, {'optionContent': 'D.目标通知 \n', 'isCorrect': '-1'}]","【答案解析】五大通知分别为前置通知，后置通知，环绕通知，异常通知，最终通知。
","【正确答案】B,C,D
"
"
2、
下列关于AOP说法正确的是
","[{'optionContent': 'A.within表达式是一种细粒度的切入点表达式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.execution表达式是一种细粒度的切入点表达式 \n', 'isCorrect': '-1'}, {'optionContent': 'C.within表达式可以精确到目标方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.通过使用通配符可以更灵活的配置切入点表达式 \n', 'isCorrect': '-1'}]","【答案解析】切入点表达式有within和execution两种，其中execution相对是一种更细粒度的切入点表达式，可以精确到方法。而灵活运用通配符可以更灵活配置切入点表达式。
","【正确答案】B,D
"
"
3、
下列关于Spring AOP说法正确的是
","[{'optionContent': 'A.连接点是一个对目标方法的调用过程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.切入点是基于切入点规则对连接的点的筛选结果 \n', 'isCorrect': '-1'}, {'optionContent': 'C.切面的本质是一个处理类 \n', 'isCorrect': '-1'}, {'optionContent': 'D.通知的本质是一个处理方法 \n', 'isCorrect': '-1'}]","【答案解析】连接点基于切入点规则筛选出切入点，之后基于动态代理实现代理，交由切面类中的通知方法进行处理
","【正确答案】A,B,C,D
"
"
4、
下列关于AOP说法正确的是
","[{'optionContent': 'A.共有五种通知类型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.所有类型的通知都可以控制目标方法是否执行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个切面中不可以配置多个通知 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个程序可以配置多个切面，按照配置顺序依次执行 \n', 'isCorrect': '-1'}]","【答案解析】共有五种通知类型，分别为前置通知，后置通知，环绕通知，异常通知，最终通知。只有环绕通知可以控制目标方法是否执行，一个切面中可以配置多个通知，一个程序中也可以配置多个切面，切面采用责任链模式按照配置顺序依次执行。
","【正确答案】A,D
"
"
5、
下列哪些不是Spring AOP常用注解
","[{'optionContent': 'A.@Aspect \n', 'isCorrect': '-1'}, {'optionContent': 'B.@BeforeRun \n', 'isCorrect': '-1'}, {'optionContent': 'C.@AfterException \n', 'isCorrect': '-1'}, {'optionContent': 'D.@Around \n', 'isCorrect': '-1'}]","【答案解析】注解方式aop常用注解有@Aspect @Before @AfterReturing @Around @AfterThrowing @After
","【正确答案】B,C
"
"
Spring IOC
1、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.当通过注解方式注册bean时，PErson类的id默认为PERSON \n', 'isCorrect': '-1'}, {'optionContent': 'B.当通过注解方式注册bean时，PErson类的id默认为person \n', 'isCorrect': '-1'}, {'optionContent': 'C.当通过注解方式注册bean时，PErson类的id默认为pErson \n', 'isCorrect': '-1'}, {'optionContent': 'D.当通过注解方式注册bean时，PErson类的id默认为PErson \n', 'isCorrect': '-1'}]","【答案解析】当通过注解方式配置bean时，生成的id默认看目标类名的第二个字母，第二个字母为小写，则首字母小写，第二个字母为大写，则首字母保持不变。
","【正确答案】D
"
"
2、
下面哪种类型不是Spring所支持的依赖注入类型？
","[{'optionContent': 'A.构造函数注入 \n', 'isCorrect': '-1'}, {'optionContent': 'B.通过任何方法参数注入 \n', 'isCorrect': '-1'}, {'optionContent': 'C.通过set方法注入属性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.基于注解的注入 \n', 'isCorrect': '-1'}]","【答案解析】依赖注入可以通过构造方法、set方法和注解方式来实现。
","【正确答案】B
"
"
多选题 （共计 10 题，总计 20分）
3、
关于依赖注入，下列选项中说法错误的是
","[{'optionContent': 'A.依赖注入是面向切面编程中的功能 \n', 'isCorrect': '-1'}, {'optionContent': 'B.依赖注入简称DI \n', 'isCorrect': '-1'}, {'optionContent': 'C.依赖注入只能通过构造方法实现 \n', 'isCorrect': '-1'}, {'optionContent': 'D.依赖注入提倡通过接口进行编程 \n', 'isCorrect': '-1'}]","【答案解析】依赖注入是Spring IOC中的核心功能之一。简称DI，可以通过构造方法、setter方法和注解方式实现。通常推荐使用接口进行编程。
","【正确答案】A,C
"
"4
、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.注解方式实现IOC,目标类所在包必须加入包扫描 \n', 'isCorrect': '-1'}, {'optionContent': 'B.只有@Component注解能够实现注解方式配置bean \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以通过@Value实现注解方式注入 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过@Autowired实现自定义bean的自动注入 \n', 'isCorrect': '-1'}]","【答案解析】注解方式实现IOC必须在配置文件中配置包扫描，之后该包下的类配置的IOC相关注解才有效。可以通过@Component、@Controller、@Service、@Repository来实现bean的配置。可以通过@Value进行注入，可以通过@Autowired实现自动装配。
","【正确答案】A,C,D
"
"
5、
下面关于在Spring中配置Bean的id属性的说法正确的是
","[{'optionContent': 'A.id属性是必须的，没有id属性就会报错 \n', 'isCorrect': '-1'}, {'optionContent': 'B.id属性不是必须的，可以没有 \n', 'isCorrect': '-1'}, {'optionContent': 'C.id属性的值可以重复 \n', 'isCorrect': '-1'}, {'optionContent': 'D.id属性的值不可以重复 \n', 'isCorrect': '-1'}]","【答案解析】Spring IOC中配置bean时，id可以没有，但是一旦有了必须唯一。
","【正确答案】B,D
"
"
6、
下面是IOC自定义bean类型的自动装配方式的是？
","[{'optionContent': 'A.by Name \n', 'isCorrect': '-1'}, {'optionContent': 'B.by Type \n', 'isCorrect': '-1'}, {'optionContent': 'C.by Method \n', 'isCorrect': '-1'}, {'optionContent': 'D.by Class \n', 'isCorrect': '-1'}]","【答案解析】自动装配可以通过类型或名称实现
","【正确答案】A,B
"
"
7、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.Spring默认创建bean采用单例模式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring中可以配置多个id相同的bean \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring中可以配置多个id不同但class相同的bean \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring默认会在第一次使用到一个bean时创建bean的对象 \n', 'isCorrect': '-1'}]","【答案解析】Spring IOC创建bean默认采用单例模式，会在容器初始化时创建bean，bean的id不可以重复，但可以配置多个id不同class相同的bean。
","【正确答案】A,C
"
"
8、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.Spring懒加载模式默认是开启的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring懒加载机制可以提升程序启动速度 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring懒加载机制可以提高内存使用效率 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring懒加载是多例的一种形式 \n', 'isCorrect': '-1'}]","【答案解析】Spring IOC默认没有懒加载,需要手动开启。通过启用懒加载可以将对象创建过程延后到第一次使用对象时，从而可以提升程序启动速度，优化内存使用，懒加载只是延后了对象的创建过程，本质仍然是单例，配置多例的懒加载没有意义。
","【正确答案】B,C
"
"
9、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.Spring IOC默认通过反射创建对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring IOC默认的创建对象方式要求类必须有无参构造方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring IOC可以通过自定义工厂创建对象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring IOC没有办法创建有多个构造方法的类的对象 \n', 'isCorrect': '-1'}]","【答案解析】Spring IOC默认通过反射方式创建对象，这就要求目标类必须有无参构造方法，如果没有无参构造方法也可以通过提供工厂来创建对象。
","【正确答案】A,B,C
"
"10
、
下列哪个注解可以注册Spring的bean
","[{'optionContent': 'A.@Service \n', 'isCorrect': '-1'}, {'optionContent': 'B.@Controller \n', 'isCorrect': '-1'}, {'optionContent': 'C.@Component \n', 'isCorrect': '-1'}, {'optionContent': 'D.@Repository \n', 'isCorrect': '-1'}]","【答案解析】以上四个注解都可以用来注册Spring的bean，功能是一样的。
","【正确答案】A,B,C,D
"
"
11、
下列关于Spring IOC说法正确的是
","[{'optionContent': 'A.Spring创建对象默认为单例 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Spring创建对象默认为多例 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Spring创建的单例对象默认在容器初始化时创建 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Spring创建的多例对象默认在容器初始化时创建 \n', 'isCorrect': '-1'}]","【答案解析】Spring IOC默认通过单例方式管理对象。可以通过配置将对象转为多例方式。单例对象在容器初始化时创建，多例对象在每次使用时创建。
","【正确答案】A,C
"
"
12、
下列有关通知方法说法正确的是（）
","[{'optionContent': 'A.前置通知在目标方法执行之前执行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.后置通知无论如何都会执行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.异常通知执行后不会再执行后置通知 \n', 'isCorrect': '-1'}, {'optionContent': 'D.环绕通知默认会自动调用目标方法 \n', 'isCorrect': '-1'}]","【答案解析】Spring AOP有五大通知类型，各有特点。其中前置通知是在目标方法执行之前执行的通知，后置通知和异常通知分别在目标方法正常返回和抛出异常后执行，环绕通知中需要手动调用目标方法，目标方法才会执行。
","【正确答案】A,C
"
"
13、
Spring的AOP的动态代理机制都有哪些？
","[{'optionContent': 'A.Java动态代理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Cglib动态代理 \n', 'isCorrect': '-1'}, {'optionContent': 'C.C3P0动态代理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.MySql动态代理 \n', 'isCorrect': '-1'}]","【答案解析】主流的动态代理主要有java的动态代理和cglib动态代理,Spring都支持。
","【正确答案】A,B
"
"
14、
在java动态代理中， 关于invoke(Object proxy，Method method，Object[] args)方法，下列说法正确的是？
","[{'optionContent': 'A.第一个参数是目标对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.第二个参数是目标方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.第三个参数是目标方法调用的参数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当程序调用代理的方法时，会最终调用到此invoke方法 \n', 'isCorrect': '-1'}]","【答案解析】Java动态代理的三个参数分别为代理对象、目标方法、目标方法参数，当调用代理对象的方法时会自动执行此invoke方法
","【正确答案】B,C,D
"
"



事务
1、
事务有多个性质，其中不包括？
","[{'optionContent': 'A.一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.唯一性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.原子性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.隔离性 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是事务四大特性 原子性 一致性 隔离性 持久性，没有唯一性，所以选择B选项。
","【正确答案】C
"
"
2、
一个事务成功完成后，它对数据库的改变是永久的，这一特性称为事务的
","[{'optionContent': 'A.原子性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.隔离性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.持久性 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是事务的特性。事务的的持久性表示一旦事务提交，则为数据会发生真实改变，这个过程永远不可逆，无法修改。
","【正确答案】D
"
"
3、
以下关于数据库隔离级别的说法错误的是?
","[{'optionContent': 'A.Read uncommitted隔离级别数据库不保证任何事务特性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Read committed 隔离级别可以防止脏读和不可重复读 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Repeatable read 隔离级别可能会出现虚读现象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Serializable保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是数据库的隔离级别，Read committed隔离级别只可以防止脏读。所以选择B选项。
","【正确答案】B
"
"
4、
下列哪些选项不是事务的四大特性？
","[{'optionContent': 'A.原子性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一致性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.离散性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.持久性 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是事务的特性。事务四个特性为原子性，一致性，隔离性，持久性。并不包含离散性，所以选择C选项。
","【正确答案】C
"
"
5、
(单选题)下列哪个不属于事务的特征的（）
","[{'optionContent': 'A.原子性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.并发性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.隔离性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.持久性 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是事务的四个特性。事务四个特性为：原子性，一致性，隔离性和持久性。并没有并发性，所以选择B选项。
","【正确答案】B
"
"
6、
(单选题)以下关于数据库隔离级别的说法错误的是?
","[{'optionContent': 'A.Read uncommitted隔离级别数据库不保证任何事务特性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Read committed 隔离级别可以防止脏读和不可重复读 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Repeatable read 隔离级别可能会出现虚读现象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Serializable保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是数据库的隔离级别，Read committed隔离级别只可以防止脏读。所以选择B选项。
","【正确答案】B
"
"多选题 （共计 1 题，总计 2分）

7、
(多选题)下面关于事务的说法正确的是：
","[{'optionContent': 'A.事务具备ACID四个基本特性，即A（Atomicity）—一原子性、C（Consistency）—一致性、I（Isolation）—一隔离性、D（Durability）—一持久性。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.事务的提交（Commit）指将事务中所有对数据库的更新写到磁盘上的物理数据库中去，事务正常结束。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.事务的回滚（Rollback）指在事务运行的过程中发生了错误，需要将事务中对数据库的所有已完成的操作全部撤消，回滚到事务开始的状态。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.JDBC通过setAutoCommit(true)控制事务时，执行更新语句，需要添加commit方法。 \n', 'isCorrect': '-1'}]","【答案解析】事务四个特性题目中书写正确。事务提交的含义描述正确。事务回滚的含义描述正确。setAutoCommit(true)方法中参数值为true时，表示自动提交，不需要commit提交。所以D错误。
","【正确答案】A,B,C
"
"
Filter和Listener
1、
(单选题)所有的 servlet 过滤器类都必须实现哪个接口？
","[{'optionContent': 'A.javax.servlet.Filter \n', 'isCorrect': '-1'}, {'optionContent': 'B.javax.servlet.ServletConfig \n', 'isCorrect': '-1'}, {'optionContent': 'C.javax.servlet.ServletContext \n', 'isCorrect': '-1'}, {'optionContent': 'D.javax.servlet.Servlet \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Filter包名路径问题。可以根据Fitler所在的包名来判断。Servlet过滤器类都必须实现 javax.servlet.Filter接口。
","【正确答案】A
"
"
2、
(单选题)如果要实现监听HTTP会话的创建，需要实现哪个接口的什么方法 。
","[{'optionContent': 'A.HttpSessionListener接口的sessionDestroyed方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HttpSessionListener接口的sessionCreated方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HttpSessionActivationListener接口的sessionCreated方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HttpSessionAttributeListener接口的sessionCreated方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.HttpSessionBindingListener接口的sessionCreated方法 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Listener的概念和实际用法。具体考察HttpSessionListener接口的使用。由于实现的是会话的创建，所以是sessionCreated方法。
","【正确答案】B
"
"
3、
在web.xml中使用___________标签配置过滤器（）
","[{'optionContent': 'A.<filter>和<filter-mapping> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<filter-name>和<filter-class> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<filter>和<filter-class> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<filter-pattern>和<filter> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是filter过滤器的配置方式。需要配置和标签，filter标签里、是必须要的，filtermapper中、是必须要的。所以选择A选项。
","【正确答案】A
"
"
4、
(单选题)在一个Filter中，处理filter业务的方法是?
","[{'optionContent': 'A.dealFilter (ServletRequest request,ServletResponse response,FilterChain chain) \n', 'isCorrect': '-1'}, {'optionContent': 'B.dealFilter (ServletRequest request,ServletResponse response) \n', 'isCorrect': '-1'}, {'optionContent': 'C.doFilter (ServletRequest request,ServletResponse response, FilterChain chain) \n', 'isCorrect': '-1'}, {'optionContent': 'D.doFilter (ServletRequest request,ServletResponse response) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Filter过滤器接口中的方法。Filter接口中存在doFilter(ServletRequest,ServletResponse，FilterChain chain)这个方法，所以应用选择C选项。其他为干扰项。
","【正确答案】C
"
"
5、
(单选题)如何实现监听ServlvetRequest对象添加属性 。
","[{'optionContent': 'A.实现ServletRequestListener接口的RequestInitialized方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.实现ServletRequestAttributeListener接口的attributeReplaced方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实现ServletRequestListener接口的attributeAdded方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.实现ServletRequestAttributeListener接口的attributeAdded方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.实现ServletRequestListener接口的RequestDestroyed方法 \n', 'isCorrect': '-1'}]","【答案解析】根据题意，如果监听request域中属性添加，则为监听request域中属性的变换，所以要实现ServletRequestAttributeListener接口，监听属性添加的方法为attributeAdded方法。所以选择D。
","【正确答案】D
"
"
6、
关于filter链执行顺序，是由web.xml文件里那个元素决定的？
","[{'optionContent': 'A.<filter>元素顺序决定 \n', 'isCorrect': '-1'}, {'optionContent': 'B.<filter-mapping>元素顺序决定 \n', 'isCorrect': '-1'}, {'optionContent': 'C.<filter-class>元素顺序决定 \n', 'isCorrect': '-1'}, {'optionContent': 'D.由过滤器类名的字典序决定 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是filter执行的顺序。过滤器的执行顺序是由filter-mapping标签来控制的，所以选择B选项。
","【正确答案】B
"
"
7、
使用Servlet过滤器时，需要在web.xml通过（）元素将过滤器映射到Web资源。
","[{'optionContent': 'A.<filter> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<filter-mapping> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<servlet> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<servlet-mapping> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是过滤器相关知识点。filter标签里相当于申明一个变量，后面filter-Mapping标签里会使用此处配置的过滤器。
","【正确答案】B
"
"
多选题 （共计 4 题，总计 8分）
8、
在JaveEE中，使用servlet过滤器，需要在web.xml中配置（ ）元素。
","[{'optionContent': 'A.<filter> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<filter-mapping> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<servlet-filter> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<filter-config> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是servlet中的过滤器。在web.xml中配置filter和filter-mapping标签。所以选择A,B选项。
","【正确答案】A,B
"
"
9、
(多选题)过滤器在现实开发中有哪些作用 。
","[{'optionContent': 'A.可以对客户提交的数据进行重新编码 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以从系统获得配置信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以过滤客户提交的某些不合法的词汇 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以验证客户是否已经登录 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以验证客户端浏览器是否支持当前的应用 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Filter的概念和实际用法。在EasyMall项目中实现了全站乱码过滤，使用的就是过滤器实现。在Filter接口中有init方法，其中可以获取配置信息。过滤器可以实现过滤敏感词汇。30天自动登录使用过滤实现。也可以实现当前浏览器是否可以使用。总的来说以上5个选项都是需要过滤请求响应指向才能进行的操作，所以均可以使用过滤器。
","【正确答案】A,B,C,D,E
"
"
10、
(多选题)JavaEE提供了哪几种对象的事件监听。
","[{'optionContent': 'A.ServletContext监听Servlet的会话信息 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ServletContext监听Web上下文的信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HttpSession监听Servlet的会话信息 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ServletRequest监听Servlet的请求信息 \n', 'isCorrect': '-1'}, {'optionContent': 'E.HttpSession监听Web上下文的信息 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Listener的概念和实际用法。其中ServletContext负责监听web应用域的创建和销毁，HttpSession负责监听session域的创建和销毁，ServletRequest负责监听请求的创建和销毁。所以由此的确定B,C,D正确。
","【正确答案】B,C,D
"
"
11、
(多选题)实现ServletContextListener和ServletContextAttributeListener接口,可以监听ServletContext的哪些信息 ？
","[{'optionContent': 'A.ServletContext的创建 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ServletContext的销毁 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ServletContext属性的增加 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ServletContext属性的删除 \n', 'isCorrect': '-1'}, {'optionContent': 'E.ServletContext属性的修改 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Listener的概念和实际用法。其中ServletContextListener负责监听web应用域的创建和销毁，ServletContextAttributeListener负责监听web域中的属性创建，更新和销毁。所以由此的确定A,B,C,D,E正确。
","【正确答案】A,B,C,D,E
"
"

JAVAEE开发模式
1、
下面关于MVC的说法不正确的是?
","[{'optionContent': 'A.M表示Model层，封装处理数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.View表示视图层，负责向用户显示外观 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Controller是控制层，负责控制流程 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在MVC架构中 jsp通常做控制层 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是MVC每一层的用途。其中jsp是页面，主要负责页面展示，所以属性View层。故此D选项描述错误。
","【正确答案】D
"
"
2、
下面关于MVC设计模式说法不正确的是
","[{'optionContent': 'A.MVC设计模式，一个模型对应多个视图，可以减少代码的复制即代码的维护量 \n', 'isCorrect': '-1'}, {'optionContent': 'B.模型返回的数据与视图逻辑分离 \n', 'isCorrect': '-1'}, {'optionContent': 'C.控制层可以把不同的模型和不同的视图组合在一起，完成不同的请求 \n', 'isCorrect': '-1'}, {'optionContent': 'D.MVC更符合软件工程化管理的精神，并能提高软件运行速度 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是MVC设计模式的作用。MVC设计模式的思想是为了提升代码的可读性和可维护性，代码的可读性。并不会提升代码的执行速度。所以选择D选项。
","【正确答案】D
"
"多选题 （共计 2 题，总计 4分）

3、
(多选题)Web应用的数据共享方式包括？
","[{'optionContent': 'A.基于请求的共享 \n', 'isCorrect': '-1'}, {'optionContent': 'B.基于会话的共享 \n', 'isCorrect': '-1'}, {'optionContent': 'C.基于页面的共享 \n', 'isCorrect': '-1'}, {'optionContent': 'D.基于应用的共享 \n', 'isCorrect': '-1'}]","【答案解析】在Web开发中可以在四个不同的范围内共享数据，这四个不同范围分别为：基于请求的共享，基于会话的共享，基于页面的共享和基于应用的共享。
","【正确答案】A,B,C,D
"
"
4、
以下关于JavaBean说法正确的是（   ）
","[{'optionContent': 'A.JavaBean常用来封来业务逻辑，数据库操作等，但是不可重用。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一个封装数据的JavaBean一般情况下对应着数据库内的多张表或视图 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一般JavaBean是一个公共类，并提供无参的公有构造方法，属性私有，具有公有的访问属性getter方法和setter方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.JavaBean实际上是一个Java类，从功能上可以分为封装数据和封装业务两类 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JAVABEAN的概念及应用方式。javabean一般对应数据库中的一张表，可以处理业务逻辑，但是不能负责数据的操作，可以重用。javabean都会实现setter或者getter方法。所以选择C,D选项。
","【正确答案】C,D
"
"JSP技术
1、
哪一个不是EL定义的隐式对象？
","[{'optionContent': 'A.cookie \n', 'isCorrect': '-1'}, {'optionContent': 'B.pageContext \n', 'isCorrect': '-1'}, {'optionContent': 'C.attributes \n', 'isCorrect': '-1'}, {'optionContent': 'D.initParam \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是EL内置的对象。其中attributes不是el内置对象，所以C选项错误。
","【正确答案】C
"
"
2、
(单选题)JSP EL表达式：${(10*10) ne 100}的值是?
","[{'optionContent': 'A.0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.true \n', 'isCorrect': '-1'}, {'optionContent': 'C.false \n', 'isCorrect': '-1'}, {'optionContent': 'D.1 \n', 'isCorrect': '-1'}]","【答案解析】题目为el表达式的应用，其中ne表示不等于。属于关系运算，得出布尔值类型结果，当前题目判断内容为100不等于100，显然是错误的，所以为false，选择C。
","【正确答案】C
"
"
3、
从HTTP请求中，获得请求参数，应该调用____。
","[{'optionContent': 'A.request对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request对象的getParameter()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.session对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.session对象的getParameter()方法 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是api的调用。意在区分getParameter和getAttribute的区别。getParameter是获取请求参数，getAttribute是获取域属性，session身上没有请求参数，所以选择B选项。
","【正确答案】B
"
"
4、
(单选题)以下哪项陈述是错误的()
","[{'optionContent': 'A.在WEB项目的共享数据范围内,application是范围最广泛的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.当我们在一个JSP页面新开窗口时,新开窗口的页面也共享session范围内的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.当在JSP页面中，将页面请求转发到的页面中,可以共享一个page范围内的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当用户重新打开一个浏览器窗口时,原session对象不再有效 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP的概念及应用。page范围内的数据仅在当前页面生效，所以无法跨页面共享。所以C描述错误，选择C。
","【正确答案】C
"
"
5、
(单选题)在jsp中需要将1.jsp的请求数据通过2.jsp转发给3.jsp，应该在2.jsp中采用（）式实现?
","[{'optionContent': 'A.<%request.sendRedirect(""3.jsp"")%> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<%response.sendRedirect(""3.jsp"")%> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<%request.getRequestDispatcher(""3.jsp"").forward(reqeust,response)%> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<%response.sentRedirect(""3.jsp"").forward(reqeust,response)%> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP页面中请求转发的操作，请求转发需要使用request.getRequestDispatcher().forward()实现。所以选择C选项。 
","【正确答案】C
"
"6、
(单选题)要在页面上输出2+3=${2+3}，则对应的程序代码应为()
","[{'optionContent': 'A.2+3=\\${2+3} \n', 'isCorrect': '-1'}, {'optionContent': 'B.2+3=${2+3} \n', 'isCorrect': '-1'}, {'optionContent': 'C.2+3=/${2+3} \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不对 \n', 'isCorrect': '-1'}]","【答案解析】根据题意，是希望在浏览器页面中直接展示字符数据2+3=${2+3}，而如果直接在页面源代码中书写这段内容，则会导致el表示执行，计算出结果，所以应该将el表达式转义。转义之后即可展示出正确的字符串内容。以上选项中转义正确的是A选项。
","【正确答案】A
"
"
7、
(单选题)jsp指令不包括(  )
","[{'optionContent': 'A.page指令 \n', 'isCorrect': '-1'}, {'optionContent': 'B.taglib指令 \n', 'isCorrect': '-1'}, {'optionContent': 'C.import指令 \n', 'isCorrect': '-1'}, {'optionContent': 'D.include指令 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP页面中可以使用的指令。共有三个，page,taglib,include。没有import，所以选择C选项。
","【正确答案】C
"
"
8、
(单选题)JAVA EE中，JSP EL表达式：${user.loginName}的执行效果等同于（）。
","[{'optionContent': 'A.<%=user.getLoginName()%> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<% user.getLoginName();%> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<%=user.loginName%> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<% user.loginName;%> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是el表达式的与JSP表达式的转换。el表达式对应的JSP表达式应该为<%=%>,${ user.loginName }相当于<%= user.getLoginName %>,所以选择A选项正确。
","【正确答案】A
"
"
9、
(单选题)在 JSP中，以下的 page 指令设置了使用的脚本语言是 Java，且导入了 java.rmi.* 和java.util.* 包．正确的是
","[{'optionContent': 'A.＜ %＠ page Language=“Java” ,import= ”java.rmi.*;java.uitl.*“%”> \n', 'isCorrect': '-1'}, {'optionContent': 'B.＜ %＠ page language=“Java” import= ”java.rmi.* java.uitl.* ”%”> \n', 'isCorrect': '-1'}, {'optionContent': 'C.＜%＠ page language=“Java”; import= ”java.rmi.*;java.uitl.* ”%”> \n', 'isCorrect': '-1'}, {'optionContent': 'D.＜%＠ page language=“Java” import= ”java.rmi.* ,java.uitl.* ”%> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP页面指令书写的具体形式。JSP指令中属性之间使用空格隔开，import属性导入多个包使用逗号隔开，所以选择D选项。
","【正确答案】D
"
"
10、
(单选题)以下（  ）标签用于实现循环功能，类似与Java语句中的for循环
","[{'optionContent': 'A.<c:set> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<c:forEach> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<c:forTokens> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<c:import> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSTL标签的用法。用于设置变量值和对象属性 指定分隔符将字符串分隔为一个数组然后迭代它们 可以把其他静态(HTML,txt文件等)或是动态(JSP,PHP文件等)文件的内容包含到本身的JSP网页中。
","【正确答案】B
"
"
11、
给定以下JSP代码片段，有2个客户依次浏览该JSP;且每个客户只浏览一次，第2个客户会看到浏览器显示（ ）
<%int x = 1; %>
<%!int x = 10; %>
X =<%=x%>
","[{'optionContent': 'A.x=1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.x=2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.x=10 \n', 'isCorrect': '-1'}, {'optionContent': 'D.x=11 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP脚本片段相关知识点。是声明的全局变量，只加载一次，<%int x = 1%>是一个局部变量，每次访问页面都会加载，且当前题目中，局部变量会覆盖全局变量来使用，所以x=1，选择A选项。
","【正确答案】A
"
"
12、
下面有关EL中“.“和“[ ]“两种存取运算符的说法不正确的是（  ）
","[{'optionContent': 'A.两者在某些情况下是等效的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.“[ ]“运算符主要用来访问数组、列表或其他集合 \n', 'isCorrect': '-1'}, {'optionContent': 'C.[]不能访问数组、列表中的元素 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当要存取的属性名称中包含一些特殊字符，如.或?等并非字母或数字的符号，就一定要使用“[ ]“ \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是el表达式的应用。动态取值，只能通过[]的形式实现。如果使用”.”的形式可能会引起歧义，导致无法读取某一个属性值。所以选择C选项。
","【正确答案】C
"
"
13、
要使用JSTL的核心标签库，需要在JSP源文件的首部加入如下声明语句？
","[{'optionContent': 'A.<%@ taglib prefix=""c"" uri=""http://java.sun.com/jsp/jstl/core"" %> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<%@ taglib prefix=”x” uri=”http://java.sun.com/jsp/jstl/xml”%> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<%@ taglib prefix=”fmt” uri=”http://java.sun.com/jsp/jstl/fmt”%> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<%@ taglib prefix=”sql”uri=”http://java.sun.com/jsp/jstl/sql”%> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSTL标签库的引入方式。核心标签库为core库，引入方式<%@ taglib prefix=""c"" uri=""http://java.sun.com/jsp/jstl/core"" %>，所以选择A选项。
","【正确答案】A
"
"
14、(单选题)（  ）动作用于转向另一个页面。
","[{'optionContent': 'A.next \n', 'isCorrect': '-1'}, {'optionContent': 'B.forward \n', 'isCorrect': '-1'}, {'optionContent': 'C.include \n', 'isCorrect': '-1'}, {'optionContent': 'D.param \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP的pageContext隐式对象。pageContext的forward方法表示请求转发。所以选择B选项。
","【正确答案】B
"
"
15、(单选题)JSP页面的page指令主要用于设置该页面的各种属性page指令的language属性的作用是?
","[{'optionContent': 'A.将需要的包或类引入到JSP页面中 \n', 'isCorrect': '-1'}, {'optionContent': 'B.指定JSP页面使用的脚本语言，默认为java \n', 'isCorrect': '-1'}, {'optionContent': 'C.指定jsp页面采用的编码方式，默认为text/html \n', 'isCorrect': '-1'}, {'optionContent': 'D.服务器所在国家 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP指令的概念，JSP指令中language是指定当前页面中可以使用的脚本语言。默认为java。
","【正确答案】B
"
"
16、page指令用于定义JSP文件中的全局属性，下列关于该指令用法的描述不正确的是?
","[{'optionContent': 'A.<%@page%>作用于整个JSP页面 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以在一个页面中使用多个<%@page %>指令 \n', 'isCorrect': '-1'}, {'optionContent': 'C.为增强程序的可读性，建议将<%@page %>指令放在JSP文件的开头，但不是必须的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.<%@page%>指令中的属性只能出现一次 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是指令作用于整个JSP页面，同样包括静态的包含文件。但是指令不能作用于动态的包含文件，比如 你可以在一个页面中用上多个指令，但是其中的属性只能用一次，不过也有个例外，那就是import属性。因为import属性和Java中的import语句差不多(参照Java Language)，所以你就能多用此属性几次了. 无论你把指令放在JSP的文件的哪个地方，它的作用范围都是整个JSP页面。不过，为了JSP程序的可读性，以及好的编程习惯，最好还是把它放在JSP文件的顶部.所以选择D选项。
","【正确答案】D
"
"
17、(单选题)在JAVA EE中，以下不是JSP隐式对象的是？
","[{'optionContent': 'A.pageContext \n', 'isCorrect': '-1'}, {'optionContent': 'B.context \n', 'isCorrect': '-1'}, {'optionContent': 'C.application \n', 'isCorrect': '-1'}, {'optionContent': 'D.out \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP九大隐式对象。九个隐式对象中并不包含context，所以选择B选项。
","【正确答案】B
"
"
18、(单选题)以下关于 EL和 JSTL说法错误的是 ?()
","[{'optionContent': 'A.EL是一种简洁的数据访问语言 \n', 'isCorrect': '-1'}, {'optionContent': 'B.EL表达式基本形式： ${var} \n', 'isCorrect': '-1'}, {'optionContent': 'C.JSTL的全称是 JavaServer Pages Standard Tag Library \n', 'isCorrect': '-1'}, {'optionContent': 'D.JSTL只有一个 Core 核心标签库 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Filter包名路径问题。JSTL的核心标签库不只有Core一个.还有sql库等其他的标签库。所以D是错误。 
","【正确答案】D
"
"
多选题 （共计 2 题，总计 4分）
19、
(多选题)下面哪些属于JSP内置对象?
","[{'optionContent': 'A.request \n', 'isCorrect': '-1'}, {'optionContent': 'B.out \n', 'isCorrect': '-1'}, {'optionContent': 'C.application \n', 'isCorrect': '-1'}, {'optionContent': 'D.config \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSP的隐式对象。九大隐式对象中包含request,out,application,config这四个选项。所以四个选项均正确。
","【正确答案】A,B,C,D
"
"
20、
对JSTL说法中正确的是？
","[{'optionContent': 'A.forEach用来循环输出集合中的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.set标签用来定义变量并添加到域中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.when标签只能输出判断一次变量值 \n', 'isCorrect': '-1'}, {'optionContent': 'D.if标签主要用来执行数据库操作 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSTL标签库的应用。when标签可以判断多次。if标签是用作判断使用，这两项错误，所以选择A,B选项。
","【正确答案】A,B
"
"会话技术
1、
(单选题)Cookie如果没有指定失效时间，默认的时效是（）
","[{'optionContent': 'A.一天 \n', 'isCorrect': '-1'}, {'optionContent': 'B.一分钟 \n', 'isCorrect': '-1'}, {'optionContent': 'C.会话级别 \n', 'isCorrect': '-1'}, {'optionContent': 'D.永不过期 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是COOKIE中基本概念的生命时长。如果不设置COOKIE的最大生命时长，则默认的COOKIE最大生命时长为会话级别的COOKIE。所以选择C。
","【正确答案】C
"
"
2、
下列有关ajax说法正确的是（）
","[{'optionContent': 'A.ajax是一个异步请求操作，并且只能实现异步请求 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ajax是由服务器主动发出的操作 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ajax的实现其实就是一个请求的过程，包括创建ajax对象，创建连接，发送请求。注册监听4个过程 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ajax注册监听的过程只关心状态3即可 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是tomcat服务器相关知识点。运行servlet必须有servlet容器，tomcat就是一个servlet容器。这个容器安装在服务器端而不是客户端。服务器端需要安装JDK才可以使用tomcat。客户端访问服务器需要通过浏览器操作，所以B描述错误，选择B。
","【正确答案】C
"
"
3、
(单选题)J2EE中，Servlet API为使用Cookie,提供了(  )类
","[{'optionContent': 'A.Javax.servlet.http.Cookie \n', 'isCorrect': '-1'}, {'optionContent': 'B.Javax.servlet.http.HttpCookie \n', 'isCorrect': '-1'}, {'optionContent': 'C.Javax.servlet.Cookie \n', 'isCorrect': '-1'}, {'optionContent': 'D.Javax.http.HttpCookie \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Cookie基本概念。Cookie位于JavaEE的包中，所以是javax，cookie是存在于servlet包下的，所以选择javax.servlet.cookie。
","【正确答案】C
"
"
4、
(单选题)以下（）可用于检索session属性userid的值
","[{'optionContent': 'A.session.getAttribute(“userid”) \n', 'isCorrect': '-1'}, {'optionContent': 'B.session.setAttribute(“userid”) \n', 'isCorrect': '-1'}, {'optionContent': 'C.request.getParameter(“userid”） \n', 'isCorrect': '-1'}, {'optionContent': 'D.request.getAttribute(“userid”) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是session作为域对象时的用法。想要获取session域中的域属性，则要使用session对象的获取，获取域属性的api为getAttribute，所以选择A选项。
","【正确答案】A
"
"
5、
关于Cookie的说法，错误的是?
","[{'optionContent': 'A.获取Cookie的名字用cookie的getName方法，getValue方法获取cookie的值，设置cookie的值用setValue方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.getMaxAge和setMaxAge是获取和设置cookie经过多长时间就过期的两个的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Cookie是服务器端状态管理机制 \n', 'isCorrect': '-1'}, {'optionContent': 'D.浏览器可以关闭Cookie功能 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是cookie。cookie是 浏览器和服务器之间有约定：通过使用cookie技术来维护应用的状态。 1、创建：Cookie是可以被Web服务器设置的字符串，并且可以保存在浏览器中。 2、发送：当浏览器访问了页面1时，web服务器设置了一个cookie，并将这个cookie和页面1一起返回给浏览器， 3、保存：浏览器接到cookie之后，就会保存起来， 4、发送：在它访问页面2的时候会把这个cookie也带上，Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。所以选择C选项。
","【正确答案】C
"
"
6、
下列选项中，（  ）可以准确地获取请求页面的一个文本框的输入（文本框的名称为name）
","[{'optionContent': 'A.request.getParameter（name） \n', 'isCorrect': '-1'}, {'optionContent': 'B.request.getParameter（”name”） \n', 'isCorrect': '-1'}, {'optionContent': 'C.request.getParameterValues(name) \n', 'isCorrect': '-1'}, {'optionContent': 'D.request.getParameterValues(“name”) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值 getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例。所以选择B选项。
","【正确答案】B
"
"
7、
(单选题)给定一个Servlet程序的代码片段，如下：
Public void doPost(HttpServletRequest request,HttpServletResponse response) throws 
ServletException,IOException {
     request.getSession().getAttribute(“A”);  //第二行
}
假定第二行返回的对象引用不是null，那么这个对象存储在（）范围中。
","[{'optionContent': 'A.page \n', 'isCorrect': '-1'}, {'optionContent': 'B.session \n', 'isCorrect': '-1'}, {'optionContent': 'C.request \n', 'isCorrect': '-1'}, {'optionContent': 'D.application \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Session对象的域属性使用方式。题目中代码表示获取session域中的域属性A，所以这个域属性存储在session域中。
","【正确答案】B
"
"
8、
session对象中用于设定指定名字的属性值，并且把它存储在session对象中的方法是？
","[{'optionContent': 'A.setAttribute \n', 'isCorrect': '-1'}, {'optionContent': 'B.getAttributeNames \n', 'isCorrect': '-1'}, {'optionContent': 'C.getValue \n', 'isCorrect': '-1'}, {'optionContent': 'D.getAttribute \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Session获取域属性的方式。session.setAttribute(""usrid"", userid); 给session添加自定义key,value（HttpServletRequest request 作为方法的输入参数）所以选择A选项。
","【正确答案】A
"
"
多选题 （共计 9 题，总计 18分）
9、
关于HttpSession的正确的说法是_____。
","[{'optionContent': 'A.getAttributer()方法返回类型是String \n', 'isCorrect': '-1'}, {'optionContent': 'B.getAttributer()方法返回类型是Object \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个session中设置的域属性可以在多个不同会话中获取到。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个会话只能使用一个session共享数据。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是session的使用方式，getAttribute()返回的是Object类型的数据。一个session只能共享一个会话的数据。所以选择B,D选项。
","【正确答案】B,D
"
"
10、
关于HttpSession的正确的说法是_____。
","[{'optionContent': 'A.getAttributer()方法返回类型是String \n', 'isCorrect': '-1'}, {'optionContent': 'B.getAttributer()方法返回类型是Object \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个session中设置的域属性可以在多个不同会话中获取到。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个会话只能使用一个session共享数据。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是session的使用方式，getAttribute()返回的是Object类型的数据。一个session只能共享一个会话的数据。所以选择B,D选项。
","【正确答案】B,D
"
"
11、
关于下列描述错误的是___ 。
","[{'optionContent': 'A.request对象的getSession()方法每次调用都创建一个新的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request对象的getSession()方法用于创建一个新的或者获取一个已存在的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.request对象的getSession(false)方法每次调用都创建一个新的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.request对象的getSession(false)方法用于获取一个已存在的session, 如果没有session, 将会返回null \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Session对象的创建方法。request.getSession()方法在服务器没有当前浏览器对应session对象时会创建一个新的session对象，如果已经有了session，则会直接使用。request.getSession(false)在获取到session时直接使用，获取不到返回false,所以A,C选项描述错误，选择A,C。
","【正确答案】A,C
"
"
12、
下列关于编码，正确的说法是？
","[{'optionContent': 'A.HTTP协议不支持非ISO8859-1的字符，所以如果想传输中文应该进行URL编码 \n', 'isCorrect': '-1'}, {'optionContent': 'B.许多乱码都是由于编解码时码表不一致产生的，所以应该尽力保证编解码码的一致，防止乱码产生 \n', 'isCorrect': '-1'}, {'optionContent': 'C.request.setCharacterEncoding对请求实体内容起作用，而request GET方式提交的参数是附加在URL后的并不在请求的实体内容中，所以此方法只能解决POST乱码 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对于get方式提交的请求参数，我们需要自己手动的经过将乱码先编码再解码的过程解决乱码 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request对象的乱码处理。HTTP协议支持其他字符集的使用。乱码产生的原因就是编解码不一致，编解码一直不会出现乱码问题。setCharacterEncoding对请求实体内容有效，所以仅对post请求生效。get请求需要手动先编码，再解码的过程来处理乱码。所以B,C,D选项正确。
","【正确答案】B,C,D
"
"
13、
下列说法正确的是？
","[{'optionContent': 'A.请求转发是服务器端技术，与浏览器没有任何关系，浏览器并不知道获得的响应消息是否是经过转发得到的。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.请求转发的过程中转发前写入response中的实体内容数据会丢失掉，最终输出的将是请求转发过程中的最后一个节点资源的数据输出。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.请求转发是两次请求两次响应 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个Servlet中可以转发两次 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是请求转发时的特点。请求转发是服务器的内部跳转，浏览器不会感受到这个跳转。请求转发时会清空response中的数据，只保留最后一个节点的数据。请求转发是一次请求，一次响应。不可以在一个servlet中请求转发两次。所以A,B选项正确。
","【正确答案】A,B
"
"
14、
关于HttpSession的getAttibute()和setAttribute()方法，正确的说法是_____。
","[{'optionContent': 'A.getAttributer()方法返回类型是String \n', 'isCorrect': '-1'}, {'optionContent': 'B.getAttributer()方法返回类型是Object \n', 'isCorrect': '-1'}, {'optionContent': 'C.setAttributer()方法保存数据时如果名字重复会抛出异常 \n', 'isCorrect': '-1'}, {'optionContent': 'D.setAttributer()方法保存数据时如果名字重复会覆盖以前的数据 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Session域属性的创建与获取。getAttribute方法获取的参数是Object类型，在获取之后再做强转使用。setAttribute()设置数据时出现重复名字的属性，会实现覆盖的效果。所以选择B,D两个选项。
","【正确答案】B,D
"
"
15、
session与cookie的区别是？
","[{'optionContent': 'A.Session保存在服务端，cookie保存在客户端 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Session保存是对象，cookie只能保存字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Session永远不会过期，cookie也是 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Session在非正常关闭后会自动消失，会话级别的cookie则不会 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是servlet中的过滤器。在web.xml中配置filter和filter-mapping标签。所以选择A,B选项。
","【正确答案】A,B
"
"16
、
关于下列session的描述错误的是___ 。
","[{'optionContent': 'A.request对象的getSession()方法每次调用都创建一个新的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request对象的getSession()方法用于创建一个新的或者获取一个已存在的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.request对象的getSession(false)方法每次调用都创建一个新的session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.request对象的getSession(false)方法用于获取一个已存在的session, 如果没有session, 将会返回null \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Session创建的特征。getSession()方法在没有session对象的情况下创建一个，在已有对象的情况下直接获取使用。getSession(false)获取不到session时会返回null。所以选择B,D选项。
","【正确答案】B,D
"
"17
、
有关会话跟踪技术描述正确的是？
","[{'optionContent': 'A.Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端 \n', 'isCorrect': '-1'}, {'optionContent': 'B.关闭浏览器意味着会话Session的ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期 \n', 'isCorrect': '-1'}, {'optionContent': 'C.session是服务器端的技术 \n', 'isCorrect': '-1'}, {'optionContent': 'D.cookie是客户端技术 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Cookie和Session会话技术的知识点。cookie是一段字符串信息，可以依靠请求由浏览器发送到服务器。浏览器关闭SessionID会失效。但是会话信息仍然存储在服务器中，等待超时之后自动销毁。cookie是客户端的技术，session是服务器端的技术。所以四个选项都正确。
","【正确答案】A,B,C,D
"
"
HTTP协议
1、
(单选题)给定一个Servlet的代码片段如下：（）
public void doGet(HttpServletRequest request,
HttpServletResponse response)throws ServletException ,IOException{
______________	
out.println(""hi kitty"");
	out.close();
}
运行此servlet时输出如下：
hi kitty!
则应在此Servlet下划线处填充如下代码。
","[{'optionContent': 'A.PrintWriter out=response.getWriter(); \n', 'isCorrect': '-1'}, {'optionContent': 'B.PrintWriter out=request.getWriter(); \n', 'isCorrect': '-1'}, {'optionContent': 'C.OutputStream out=responst.getOutputStream(); \n', 'isCorrect': '-1'}, {'optionContent': 'D.OutputStream out=request.getWriter(); \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是resposne对象API的应用。
","【正确答案】A
"
"
2、
安装tomcat成功后，要修改tomcat端口，要修改的文件是？
","[{'optionContent': 'A.tomcat/bin/startup.bat文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.tomcat/conf/server.xml \n', 'isCorrect': '-1'}, {'optionContent': 'C.tomcat/conf/web.xml \n', 'isCorrect': '-1'}, {'optionContent': 'D.tomcat/bin/server.xml \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是 TOMCAT服务器配置方式。tomcat拥有目录结构中bin目录是负责tomcat启动和关闭的。conf目录是负责配置文件的目录，且servlet.xml是和tomcat配置密切相关的一个文件，端口也在这个文件中修改。所以选择B。
","【正确答案】B
"
"
3、
要运行一个JSP页面，下列说法不正确的是（  ）
","[{'optionContent': 'A.服务器端需要安装Servlet容器，如Tomcat等。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.客户端需要安装Servlet容器，如Tomcat等。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.服务器端需要安装JDK。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.客户端需要安装浏览器，如IE等。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是tomcat服务器相关知识点。运行servlet必须有servlet容器，tomcat就是一个servlet容器。这个容器安装在服务器端而不是客户端。服务器端需要安装JDK才可以使用tomcat。客户端访问服务器需要通过浏览器操作，所以B描述错误，选择B。
","【正确答案】B
"
"
4、
(单选题)调用以下哪个方法可以获取到name=hobit的checkbox的所有值？
","[{'optionContent': 'A.getParameter（""hobit""） \n', 'isCorrect': '-1'}, {'optionContent': 'B.getParameterValues(""hobit"") \n', 'isCorrect': '-1'}, {'optionContent': 'C.getParameterNames() \n', 'isCorrect': '-1'}, {'optionContent': 'D.getParameterMap() \n', 'isCorrect': '-1'}]","【答案解析】Request对象身上有三个获取参数的API。getParameter（），getParameterValues(),getParameterMap().其中getParameterValues（）可以获取多个同名参数的值。题目中要求获取checkbox中的值，可能是多个值，为了保证能过去获取到多个值，所以应该使用getParameterValues（）获取。
","【正确答案】B
"
"
5、
在WEB项目的目录结构中，web.xml文件位于(  )中?
","[{'optionContent': 'A.src \n', 'isCorrect': '-1'}, {'optionContent': 'B.META-INF \n', 'isCorrect': '-1'}, {'optionContent': 'C.WEB-INF \n', 'isCorrect': '-1'}, {'optionContent': 'D.WebRoot \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是web应用的目录结构。web.xml文件位于Web-INF目录中，所以选择C选项。
","【正确答案】C
"
"
6、
(单选题)从Http请求中，获得请求参数，应该调用？
","[{'optionContent': 'A.request对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request对象的getParameter()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.session对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.session对象的getParameter()方法 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request,session基本概念。session中没有获取请求参数的api。request对象身上的getParameter方法是获取请求参数，getAttribute是获取请求域中的域属性。
","【正确答案】B
"
"
7、
(单选题)关于HTTP协议，以下说法不正确的是（）
","[{'optionContent': 'A.HTTP协议就是一套基于tcp/ip协议的应用层协议 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HTTP协议基于请求响应模型，一次请求对应一次响应 \n', 'isCorrect': '-1'}, {'optionContent': 'C.请求只能是客户端发出服务器端只能被动的等待请求，做出响应 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HTTP的请求和响应消息如果没有发送并传递成功的话，HTTP可以保存已传递的信息 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是HTTP协议的特点。HTTP协议是无状态协议，所谓无状态就是无法在多个请求响应之间共享数据。所以D描述错误。选择D选项。
","【正确答案】D
"
"
8、
HttpServletRequest对象的____方法能够获取request域中属性的值。
","[{'optionContent': 'A.getQuaryString() \n', 'isCorrect': '-1'}, {'optionContent': 'B.getPathInfo() \n', 'isCorrect': '-1'}, {'optionContent': 'C.getParameter() \n', 'isCorrect': '-1'}, {'optionContent': 'D.getAttribute() \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是api的调用。意在区分getParameter和getAttribute的区别。getParameter是获取请求参数，getAttribute是获取域属性，session身上没有请求参数，所以选择D选项。
","【正确答案】D
"
"
9、
下面有关HTTP协议的说法不正确的是？
","[{'optionContent': 'A.HTTP协议是Web应用所使用的主要协议 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HTTP协议是一种超文本传输协议（Hypertext Transfer Protocol），是基于请求/响应模式的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HTTP是无状态协议 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HTTP的请求和响应消息如果没有发送并传递成功的话，HTTP可以保存已传递的信息 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是HTTP协议的特点。HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。所以选择D选项。
","【正确答案】D
"
"
10、
HttpServlet的子类要从HTTP请求中获得请求参数，应该调用哪个方法？
","[{'optionContent': 'A.调用HttpServletRequest对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.调用ServletContext对象的getAttribute()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.调用HttpServletRequest对象的getParameter()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.调用HttpServletRequest对象的getHeader()方法 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request作为请求对象使用，request可以获取请求参数，调用的是getParameter()方法.request对象的类型是HttpServletRequest，所以易得C选项正确。
","【正确答案】C
"
"
11、
(单选题)下列关于ajax说明错误的是？
","[{'optionContent': 'A.ajax是一种异步的请求方式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.$.ajax()函数默认的请求方式是GET请求 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ajax本身是不支持跨域请求的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.$.post函数可以没有url属性 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是AJAX的基本概念和操作步骤。ajax是一个异步请求的方式。$.ajax()函数默认情况下就是GET请求。ajax本身不支持跨域请求。$.post函数也必须要有url属性。任何AJAX请求都需要url。所以选D。
","【正确答案】D
"
"
12、
关于request和response下列说法中不正确的是？
","[{'optionContent': 'A.javaweb开发是基于HTTP协议进行的，javaweb中使用request代表请求对象，response代表响应对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request对象代表请求，response对象代表响应，这两个对象都是由浏览器创建后发送给服务器的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HTTP协议只规定了浏览器和服务器之间如何通信，而request和response对象是由javaee规范规定的、由javaweb容器负责创建的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HTTP协议是javaweb开发的基石，如response中提供的请求重定向的方法和request中提供的转发和包含方法就是基于HTTP协议进行的 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是HTTP协议的特点，javaweb中使用request作为请求，response作为响应，这两个对象都是服务器创建而非浏览器创建，javaee规范没有规定这两个对象，资源跳转都是依赖于HTTP协议实现的。所以B,C选项正确。
","【正确答案】C
"
"
13、
(单选题)以下状态码表示请求资源成功的
","[{'optionContent': 'A.201 \n', 'isCorrect': '-1'}, {'optionContent': 'B.404 \n', 'isCorrect': '-1'}, {'optionContent': 'C.500 \n', 'isCorrect': '-1'}, {'optionContent': 'D.302 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是对于请求状态码的掌握。200~299均表示请求成功。404表示资源路径不存在。500表示服务器报错。302配合location响应头实现请求重定向。所以选择A选项。
","【正确答案】A
"
"
14、
(单选题)在JAVA EE中，request对象的(  )方法可以获取页面请求中一个表单组件对应多个值时的用户的请求数据？
","[{'optionContent': 'A.String getParameter(String name) \n', 'isCorrect': '-1'}, {'optionContent': 'B.String[] getParameter(String name) \n', 'isCorrect': '-1'}, {'optionContent': 'C.String \tgetParameterValues(String name) \n', 'isCorrect': '-1'}, {'optionContent': 'D.String[]\tgetParameterValues(String name) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request的 api应用。获取表中的一组值，可以使用getParameteValues(String name),此方法返回值是一个String的数组，所以选择D选项。
","【正确答案】D
"
"
15、
关于request域的说法不正确的是？
","[{'optionContent': 'A.request域作用范围为整个请求链 \n', 'isCorrect': '-1'}, {'optionContent': 'B.request域的生命周期为：请求链的开始和结束对应request生命周期的开始和结束 \n', 'isCorrect': '-1'}, {'optionContent': 'C.request作用范围为整个请求链，因此常常在请求转发时由一个servlet（或jsp）向另一个servlet（或jsp）传递属性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.request域中可以获取到浏览器发送过来的请求参数 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request作为域对象使用时的特征。request作用范围就是整个请求链，请求链的开始和结束对应request生命周期的开始和结束。请求转发可以保持request的生命周期。但是request域中并不能获取请求参数，应该在请求中获取请求参数。所以D描述错误，选择D选项。
","【正确答案】D
"
"
16、(单选题)在J2EE中，重定向到另一个页面，以下（）语句是正确的 （）
","[{'optionContent': 'A.request . sendRedirect(“http :// www . svse . com . cn”) \n', 'isCorrect': '-1'}, {'optionContent': 'B.request . sendRedirect() \n', 'isCorrect': '-1'}, {'optionContent': 'C.response . sendRedirect(“http: // www . svse . com . cn”) \n', 'isCorrect': '-1'}, {'optionContent': 'D.response .sendRedirect() \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是资源跳转方式。重定向是通过response对象调用sendRedirect实现，所以选择C选项。
","【正确答案】C
"
"
17、(单选题)在JAVA EE中，重定向到另一个页面，以下（）语句是正确的。
","[{'optionContent': 'A.request.sendRedirect(""http://www.jb-aptech.com.cn""); \n', 'isCorrect': '-1'}, {'optionContent': 'B.request.sendRedirect(); \n', 'isCorrect': '-1'}, {'optionContent': 'C.response.sendRedirect(""http://www.jb-aptech.com.cn""); \n', 'isCorrect': '-1'}, {'optionContent': 'D.response.sendRedirect(); \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request和response的api应用。request对象身上有请求转发，并没有请求重定向操作。response对象身上有请求重定向操作。api为response.sendRedirect(String url);所以选择C选项。
","【正确答案】C
"
"
18、(单选题)在JAVAEE中，以下对RequestDispatcher描述正确的是（）
","[{'optionContent': 'A.Jsp中有个隐含的对象dispatcher，它的类型是RequestDispatcher \n', 'isCorrect': '-1'}, {'optionContent': 'B.ServletConfig有一个方法：getRequestDispatcher可以返回RequestDipatcher对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.RequestDispatcher有一个方法：forward可以把请求继续传递给别的Servlet或者JSP界面 \n', 'isCorrect': '-1'}, {'optionContent': 'D.JSP中有个隐含的默认对象request,它的类型是RequestDispatcher \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是RequestDispatcher对应的含义极其应用。jsp中没有dispatch隐式对象。getRequestispatcher是request对像身上的方法。request隐式对象的类型为HTTPServletRequest。所以C正确。
","【正确答案】C
"
"多选题 （共计 8 题，总计 16分）
19、http协议中关于get请求与post请求说法正确的是？
","[{'optionContent': 'A.get方式只能传输1k(4k)以下数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.post方式可以传输的数据大小没有限制 \n', 'isCorrect': '-1'}, {'optionContent': 'C.get方式会将请求信息在地址栏上显示，post不会 \n', 'isCorrect': '-1'}, {'optionContent': 'D.get与post其实没什么区别，只是名字不一样 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是请求方式的特点。get请求和post请求在参数的传递位置上是有差别的，并且在本质上传输方式也是不同的。所以D选项描述错误，选择D。
","【正确答案】A,C
"
"
20、
(多选题) 下列关于请求方式的说法正确的是？
","[{'optionContent': 'A.请求方式只有GET和POST两种 \n', 'isCorrect': '-1'}, {'optionContent': 'B.GET请求可以携带任意长度的请求参数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.POST请求的请求参数在请求实体内容中传输 \n', 'isCorrect': '-1'}, {'optionContent': 'D.不指定<form>表单的method属性默认就是GET提交 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是两种常用请求方式的特性。请求方式一共有7种，常用的有get和post两种，并非只有这两种。get请求是在地址栏拼接参数，所以携带的参数长度受限制，不能超过1KB。post请求参数在请求实体内容中传输，form标签默认就是get提交方式。所以选择C,D选项。
","【正确答案】C,D
"
"
21、
下面关于tomcat服务器描述正确的是？
","[{'optionContent': 'A.tomcat是一个付费的web服务器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.tomcat 安装后默认端口8080 \n', 'isCorrect': '-1'}, {'optionContent': 'C.tomcat 启动时必须要配置JAVA_HOME 环境变量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.tomcat 启动时必须要配置CATALINA_HOME环境变量 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是 TOMCAT服务器基本特征。tomcat本身就是一个免费开源的服务器，安装后默认的端口号为8080，tomcat是以java语言为基础编写的，所以依赖于JAVA_HOME环境变量，启东市必须要配置JAVA_HOME环境变量，CATALINA_HOME的配置是为了让不同位置的tomcat以同一个路径启动，这个配置并不是必须的，甚至某些场景是不推荐的。所以应该选择B,C选项。
","【正确答案】B,C
"
"
22、
下列关于编码，正确的说法是？
","[{'optionContent': 'A.ISO8859-1字符集中包含字符集，所以可以用以保存中文字符串。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.许多乱码都是由于编解码时码表不一致产生的，所以应该尽力保编码的一致，防止乱码产生 \n', 'isCorrect': '-1'}, {'optionContent': 'C.request.setCharacterEncoding方法只对请求实体内容起作用，而request GET方式提交的参数是附加在URL后的并不在请求的实体内容中，所以此方法只能解决POST乱码 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对于get方式提交的请求参数乱码问题，可以通过request.setCharacterEconding方法解决乱码。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是请求字符集的设置和使用。iso8859-1中没有中文字符，所以无法保存中文。request.setCharacterEncoding()只会处理请求实体内容中的中文字符，所以只对post请求有效。所以选择B,C选项。
","【正确答案】B,C
"
"
23、
对于ServletRequest接口获取请求参数的方法，描述错误的是__。
","[{'optionContent': 'A.getParameter方法只用于接收POST请求参数，接收GET请求参数需要使用getQueryString方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果一个参数key有多个值，那么getParameter(key)方法会返回空 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果一个参数key有多个值，那么getParameterValues(key)方法会返回一个包含所有值的字符串数组 \n', 'isCorrect': '-1'}, {'optionContent': 'D.getParameter方法返回Object对象，使用前要强制类型转换：如String str=(String) request.getParameter(key) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request接收参数，不论是get还是post，均为getParameter()，如果一个参数多个值，这个方法会返回第一个值，且返回的是一个String类型的参数，而不是Object类型的数据。所以选择A,B,D。
","【正确答案】A,B,D
"
"
24、
下列关于HTTP协议说法正确的是？
","[{'optionContent': 'A.HTTP协议规定了浏览器端和服务器端通信的方式 \n', 'isCorrect': '-1'}, {'optionContent': 'B.所有的网络通信都使用HTTP \n', 'isCorrect': '-1'}, {'optionContent': 'C.HTTP协议是基于TCP/IP协议工作的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HTTP协议是一个无状态协议 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是HTTP协议工作模式及特性。HTTP协议规定了浏览器和服务器之间的通信方式，但是并非所有的网络通信都是用HTTP。HTTP协议是基于TCP/IP工作的。HTTP协议是一个无状态协议。所以A,C,D选项正确。
","【正确答案】A,C,D
"
"
25、
服务器通过字符流响应数据给客户端浏览器，浏览器收到数据后出现乱码, Servlet中doGet()方法代码如下：
response.getWriter().write(""中国"");
//浏览器收到的数据是 ??
根据描述判断下面说法正确的是？
","[{'optionContent': 'A.出现乱码的原因是因为编解码使用的码表不一致造成的。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.出现乱码是因为客户端浏览器查错了码表 \n', 'isCorrect': '-1'}, {'optionContent': 'C.出现乱码是因为服务器发送数据时查错了码表 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过response.setContentType(“text\\html,charset=utf-8”);来解决乱码 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以通过response.setContentType(“text/html;charset=GBK”);来解决乱码 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是响应乱码处理的方式以及乱码处理的方式。乱码出现的原因是编解码不一致造成的。可以通过response.setContextType(“text/html;charset=GBK”)；解决。D选项中”/”写错。所以选择A,E选项。
","【正确答案】A,E
"
"
26、
关于请求转发、请求重定向、定时刷新下列说法正确的是？
","[{'optionContent': 'A.请求转发是一次请求一次响应，地址栏地址不会发生变化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.定时刷新可以实现在跳转之前的这段时间输出数据到客户端浏览器 \n', 'isCorrect': '-1'}, {'optionContent': 'C.请求重定向和定时刷新的实现机制是相同的，属于同一种资源跳转 \n', 'isCorrect': '-1'}, {'optionContent': 'D.请求重定向和定时刷新是两次请求两次响应，并且地址栏地址会发生变化 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是三种资源跳转方式的特点。请求转发是服务器内部的资源跳转方式。定时刷新可以在跳转的过程中可以向页面中输出一些数据。请求重定向是根据302+location响应头实现，定时刷新是refresh响应头实现，两者不一致。请求重定向和定时刷新都是两次请求和响应，地址栏会发生变化，所以选择A,B,D选项。 
","【正确答案】A,B,D
"
"Servlet相关
1、
下列关于Servlet生命周期的说法中，错误的是（   ）
","[{'optionContent': 'A.服务器每接收到一个请求，就会创建与之相关的Servlet实例 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Servlet通过ServletRequest对象获取客户端的请求 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用url传递参数时，Servlet不会直接调用doPost方法处理用户请求 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Servlet的生命周期包括：加载和实例化，初始化，服务和销毁4个基本过程 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet生命周期。服务器接收的请求可能是静态资源的请求。这种请求不会创建servlet实例。所以选择A选项。
","【正确答案】A
"
"
2、
假设在news应用中有一个cn.tedu.sportnews类，它在web.xml文件中的配置如下
<servlet>
	<servlet-name> sportnews </servlet-name>
	<servlet-class>cn.tedu.sportnews</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name> sportnews </servlet-name>
	<url-pattern>/sport</url-pattern>
</servlet-mapping>
","[{'optionContent': 'A.http://localhost:8080/sport \n', 'isCorrect': '-1'}, {'optionContent': 'B.http://localhost:8080/sportnews/sport \n', 'isCorrect': '-1'}, {'optionContent': 'C.http://localhost:8080/news/sport \n', 'isCorrect': '-1'}, {'optionContent': 'D.http://localhost:8080/cn/tedu/sportnews \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet映射方式，servlet-mapping中的url-pattern是servlet虚拟路径的映射，web应用的虚拟路径为news，所以虚拟路径为/news/sport.所以由此可知选择C选项。
","【正确答案】C
"
"
3、
(单选题)对于如下的一些映射关系：Servlet1 映射到 /abc/* Servlet2 映射到 /* Servlet3 映射到 /abc Servlet4 映射到 *.do 当请求URL为“/abc/a.do”时，匹配哪个Servlet？
","[{'optionContent': 'A.Servlet1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Servlet2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Servlet3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Servlet4 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet中的细节问题——servlet映射的优先级。映射匹配的方式为虚拟路径与通配路径越相似的越优先被访问，并且*.do永远匹配级别最低。所以选择A。
","【正确答案】A
"
"4、
在application对象中用（  ）方法可以获取所有application对象使用的属性名
","[{'optionContent': 'A.getServerInfo \n', 'isCorrect': '-1'}, {'optionContent': 'B.getAttributeNames \n', 'isCorrect': '-1'}, {'optionContent': 'C.removeAttribute \n', 'isCorrect': '-1'}, {'optionContent': 'D.getRealPath \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletContext对象获取全部域属性的api。getAttributeNames():获取所有application对象使用的属性名 getAttribute(String name):从application对象中获取指定的对象名的值 setAttribute(String key,Object obj):设置application对象的属性的值 removeAttribute(String name):从application对象中去掉指定的名称的属性。所以选择B选项。
","【正确答案】B
"
"
5、
(单选题)有关Servlet的生命周期说法正确的有?
","[{'optionContent': 'A.Servlet的生命周期由Servlet实例控制 \n', 'isCorrect': '-1'}, {'optionContent': 'B.init()方法在创建完Servlet实例后对其进行初始化，传递的参数为实现ServletContext接口的对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.service()方法响应客户端发出的请求 \n', 'isCorrect': '-1'}, {'optionContent': 'D.destroy()方法释放Servlet实例 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet的生命周期。Servlet的生命周期的开始是在访问开始之后产生的，并不是单独由一个实例来控制的。init方法中参数的类型为ServletConfig。在Servlet实现释放之后，才会调用destroy()方法执行善后的操作。所以选择C选项。
","【正确答案】C
"
"
6、
web.xml中的<servlet>标签内可以配置<load-on-startup>标签，有关这个标签的说法正确的是？
","[{'optionContent': 'A.<load-on-startup>标签必须配置给每一个servlet \n', 'isCorrect': '-1'}, {'optionContent': 'B.<load-on-startup>标签中间可以放置负数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.<load-on-startup>标签可以一次性配置多个 \n', 'isCorrect': '-1'}, {'optionContent': 'D.<load-on-startup>标签的配置意味着，当前servlet会随着web应用的加载而自动初始化。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet细节中的标签。此标签不必配给每一个servlet，标签中间可以防止正数或者是负数，且只能配置一个，标签的配置,且数字大于0意味着，当前servlet会随着web应用的加载而自动初始化。所以B选项正确。
","【正确答案】B
"
"
7、
(单选题)假设在helloapp应用中有一个com.tedu.HelloServlet类，它在web.xml文件中的配置如下：
<servlet>
	<servlet-name>HelloServlet</servlet-name>
	<servlet-class>com.tedu.HelloServlet</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name>HelloServlet</servlet-name>
	<url-pattern>/hello</url-pattern>
</servlet-mapping>
那么在浏览器访问HelloServlet的URL是什么？
","[{'optionContent': 'A.http://localhost:8080/HelloServlet \n', 'isCorrect': '-1'}, {'optionContent': 'B.http://localhost:8080/helloapp/HelloServlet \n', 'isCorrect': '-1'}, {'optionContent': 'C.http://localhost:8080/helloapp/com/tedu/hello \n', 'isCorrect': '-1'}, {'optionContent': 'D.http://localhost:8080/helloapp/hello \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet虚拟路径问题。判断虚拟路径需观察servlet-mapping标签中的url-pattern标签内容。所以路径应该是web应用的虚拟路径名称及url-pattern中的内容。所以选择D。
","【正确答案】D
"
"
8、
(单选题)在web.xml中配置了Serlvet的初始化参数，请问通过以下哪个方法可以获取到？
","[{'optionContent': 'A.getParameter(String name) \n', 'isCorrect': '-1'}, {'optionContent': 'B.getInitParameter(String name) \n', 'isCorrect': '-1'}, {'optionContent': 'C.getAttribute() \n', 'isCorrect': '-1'}, {'optionContent': 'D.getRequestDispatcher() \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletConfig的API。获取初始化配置参数的APi为getInitParameter(String name)；所以选择B。
","【正确答案】B
"
"9
、
请求Servlet的时候，Servlet的对象由__________。
","[{'optionContent': 'A.服务器负责实例化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.由开发人员在请求中实例化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Servlet会自动实例化 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Servlet只加载，无需实例化 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet运行过程。servlet在被访问的时候，由服务器完成实例化的操作，所以选择A选项。
","【正确答案】A
"
"
10、
在J2EE中，当用在户浏览器中输入：http://localhost:8080/myweb/stu ,就会调用myweb应用中的cn.tedu包中studentServlet,在web.xml中配置关于servlet配置中url--pattern正确的是？
","[{'optionContent': 'A./stu \n', 'isCorrect': '-1'}, {'optionContent': 'B.*.stu \n', 'isCorrect': '-1'}, {'optionContent': 'C./myweb/stu \n', 'isCorrect': '-1'}, {'optionContent': 'D.cn.tedu.stu \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet映射方式。Servlet中负责虚拟路径的是url-pattern标签，此题目中，/myweb为web应用的虚拟路径。/stu为servlet的虚拟路径。所以显然A选项正确。
","【正确答案】A
"
"
11、
(单选题)下面关于servlet service描述错误的是？
","[{'optionContent': 'A.不管是post还是get方法提交过来的数据，都会在service中处理 \n', 'isCorrect': '-1'}, {'optionContent': 'B.doGet/doPost则是在javax.servlet.Servlet接口中实现的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.service()是在javax.servlet.Servlet接口中定义的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.service判断请求类型，决定是调用doGet还是doPost方法 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是servlet接口和实现方法。doGet和doPost方法是在HttpServlet中实现的。
","【正确答案】B
"
"
12、
(单选题)如何获取ServletContext设置的参数值？
","[{'optionContent': 'A.context.getParameter() \n', 'isCorrect': '-1'}, {'optionContent': 'B.context.getInitParameter() \n', 'isCorrect': '-1'}, {'optionContent': 'C.context.getAttribute() \n', 'isCorrect': '-1'}, {'optionContent': 'D.context.getRequestDispatcher() \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletContext的API使用。ServletContext对象代表的是web应用的对象，可以通过这个对象获取全局参数。获取方式为context.getInitParameter().所以B选项正确
","【正确答案】B
"
"
13、
(单选题)以下哪项是代表当前Servlet在web.xml中的配置信息的？
","[{'optionContent': 'A.servletconfig \n', 'isCorrect': '-1'}, {'optionContent': 'B.servletrequest \n', 'isCorrect': '-1'}, {'optionContent': 'C.servletresponse \n', 'isCorrect': '-1'}, {'optionContent': 'D.httpsession \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletConfig的应用。ServletConfig代表当前Servlet在web.xml中的配置信息的对象，可以通过这个对象获取web.xml中的配置信息。所以选择A选项。
","【正确答案】A
"
"
14、在J2EE中，给定某Servlet的代码如下，编译运行该文件，以下陈述正确的是
public class Servlet1 extends HttpServlet{
    public void init() throws ServletException{
         }
         public void service(HttpServletRequest request,HttpServletResponse response) ThrowsServletException,IOException{
                  PrintWriter  out = response.getWriter();
                  out.println(“hello!”);
         }
}
","[{'optionContent': 'A.编译该文件时会提示缺少doGet()或者doPost()方法，编译不能够成功通过 \n', 'isCorrect': '-1'}, {'optionContent': 'B.编译后，把Servlet1.class放在正确位置，运行该Servlet，在浏览器中会看到输出文字：hello! \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译后，把Servlet1.class放在正确位置，运行该Servlet，在浏览器中看不到任何输出的文字 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译后，把Servlet1.class放在正确位置，运行该Servlet,在浏览器中会看到运行期错误信息 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet底层实现原理。此题综合性较强，考点是HttpServlet底层具体的实现。HttpServlet中实现了两个service方法，其中包含参数类型为HttpServletRequest，HttpServletResponse这个service方法。所以可以被自己创建的Servlet1重写。resonse.getWriter()方法调用正确，所以页面会输出hello！，选择B选项。
","【正确答案】B
"
"
15、(单选题)给定某servlet程序的片段如下，用户在浏览器地址栏中键盘键入正确的请求URL并回车后，在控制台上显示的结果是？
public void doGet(HttpServletRequest request,
HttpServletResponse response)throws ServletException ,IOException{
	System.out.println(""get"");
}
public void doPost(HttpServletRequest request,
HttpServletResponse response)throws ServletException ,IOException{
System.out.println(""post"");
}
post 
get 
","[{'optionContent': 'A.get \n', 'isCorrect': '-1'}, {'optionContent': 'B.post \n', 'isCorrect': '-1'}, {'optionContent': 'C.get\n', 'isCorrect': '-1'}, {'optionContent': 'D.post\n', 'isCorrect': '-1'}]","【答案解析】Servlet是一个接口，其包含子实现类HttpServlet，其中有doGet和doPost两个方法。这两个方位分别在get和post提交时被调用。题目中描述为在地址栏中书写请求，属于get请求方式，所以会导致doGet方法执行，打印get字符串。
","【正确答案】A
"
"16、在J2EE中，对于HttpServlet类的描述，错误的是？
","[{'optionContent': 'A.自己编写的Servlet继承了HttpServlet类，所实现的doGet和doPost方法参数类型为ServletRequest和ServletResponse。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Httpservlet类扩展了GenericServlet类，实现了GenericServlet类的抽象方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.继承HttpServlet相当于实现了Servlet接口 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HttpServlet类中已经实现service方法的重写。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet底层原理。这个题考查的难度较深，需要通过查看源码来确定方法的实现。doGet方法参数类型应该为HttpServletRequest和HttpServletResponse。HttpServlet继承了GenericServlet，实现了其中的方法。继承HttpServlet也会实现Servlet接口。HttpServlet完成了对service方法的重写，实现内容为doGet，doPost方法等。所以A选项描述错误，选择A。
","【正确答案】A
"
"
多选题 （共计 6 题，总计 12分）
17、
(多选题)关于servlet生命周期，以下说法正确的是？
","[{'optionContent': 'A.Servlet在服务器启动时创建对象，创建出来后立即执行init方法执行初始化的操作 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Servlet对象每次被访问后即销毁，销毁之前会调用destory方法执行善后工作 \n', 'isCorrect': '-1'}, {'optionContent': 'C.服务器关闭或web应用移除出容器时，随着web应用的销毁Servlet对象被销毁掉 \n', 'isCorrect': '-1'}, {'optionContent': 'D.每次调用Servlet 都会导致Service方法的执行 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet中的细节问题——servlet生命周期。Servlet在第一次被访问时创建对象，对象创建成功后一直驻留在内存中，直到服务器关闭或web应用移除出容器时，随着web应用的销毁Servlet对象被销毁掉。
","【正确答案】C,D
"
"
18、
<servlet>
         <servlet-name>testServlet</servlet-name>
         <servlet-class>com.accp.servlet.TestServlet</servlet-class>
</servlet>
对于以上代码片段，说法正确的是(   )
","[{'optionContent': 'A.配置了逻辑名为testServlet的Servlet组件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.其对应的类的路径是：com.accp.servlet.TestServlet \n', 'isCorrect': '-1'}, {'optionContent': 'C.客户端可以通过testServlet访问 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上说法都不对 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet配置方式。题目中servlet名称为testServlet，路径为com.accp.servlet.TestServlet，客户端需要访问url-pattern中的内容，题目未给出，所以选择A,B两项。
","【正确答案】A,B
"
"
19、
下列关于ServletContext的说法正确的是____。
","[{'optionContent': 'A.一个应用对应一个ServletContext \n', 'isCorrect': '-1'}, {'optionContent': 'B.ServletContext的范围比Session的范围要大。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.第一个会话在ServletContext中保存了数据，第二个会话读取不到这些数据 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ServletContext使用setAttributer()和getAttribute()方法操作数据 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletContext相关概念。一个ServletContext表示一个web应用。ServletContext比Session的范围要大，所以可以在多次会话中读取数据。ServletContext是域对象，所以操作域属性也是使用set/getAttribute()的方法来实现。所以选择A,B,D三个选项。
","【正确答案】A,B,D
"
"
20、
有关Servlet的生命周期说法正确的有？
","[{'optionContent': 'A.Servlet的生命周期由Servlet实例控制 \n', 'isCorrect': '-1'}, {'optionContent': 'B.init()方法在创建完Servlet实例后, Servlet调用该方法进行初始化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.service()方法处理客户端发出的请求 \n', 'isCorrect': '-1'}, {'optionContent': 'D.服务器调用destroy()方法做一些善后的处理 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是Servlet生命周期。Servlet生命周期由服务器来控制，init方法只能完成初始化操作，无法创建对象，service()方法负责处理请求。服务器自动调用destroy()方法完成善后操作。
","【正确答案】C,D
"
"
21、
下列关于ServletContext的说法正确的是____。
","[{'optionContent': 'A.ServletContext是一个代表全局配置信息的对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ServletContext的范围比Session的范围要大 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ServletContext对象可以用于保存用户的登录状态，且非常合理 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ServletContext可以通过getRealPath()方法获取磁盘目录到web应用的路径 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是ServletContext对象的应用。ServletContext是一个代表web应用的对象。范围比session要大，它保存用户登录状态不太合理，因为范围过大，可能会造成登录状态冲突。getRealPath可以获取D所述路径。
","【正确答案】B,D
"
"
22、
request的功能有哪些?
","[{'optionContent': 'A.实现请求转发 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在保存会话中的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实现请求包含 \n', 'isCorrect': '-1'}, {'optionContent': 'D.获取Session对象 \n', 'isCorrect': '-1'}, {'optionContent': 'E.作为域对象使用 \n', 'isCorrect': '-1'}, {'optionContent': 'F.获取请求头信息 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request对象的功能。除了B选项，均为request的功能。
","【正确答案】A,C,D,E,F
"
"


Web服务器
1、
下面关于tomcat服务器描述正确的是？
","[{'optionContent': 'A.tomcat是一个servlet容器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.tomcat 可以通过temp目录查看日志信息 \n', 'isCorrect': '-1'}, {'optionContent': 'C.tomcat 只能存在一个虚拟主机目录 \n', 'isCorrect': '-1'}, {'optionContent': 'D.tomcat 不能修改端口 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是 TOMCAT服务器概念及目录结构。tomcat是一个servlet容器，通过logs目录查看日志信息，可以存在多个虚拟主机的目录，tomcat可以修改端口，所以选择A选项。
","【正确答案】A
"
"
2、
(单选题)关于web容器，以下说法不正确的是（）
","[{'optionContent': 'A.Tomcat是一个免费的Web服务器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Servlet容器就是web容器，web容器就是Servlet容器 \n', 'isCorrect': '-1'}, {'optionContent': 'C.能够运行Servlet的环境叫做Servlet容器 \n', 'isCorrect': '-1'}, {'optionContent': 'D.能够运行web应用的环境叫做web容器 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是web容器的概念。一般来说，Servlet容器就是web容器，web容器则不一定是Servlet容器
","【正确答案】B
"
"
3、
下列关于有关request对象说法正确的是？
","[{'optionContent': 'A.request对象是一个代表HTTP请求的对象。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HttpServletRequest是接口，可以创建request对象。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ServletRequest没有子实现类，所以只能通过HttpServletReques接口创建对象。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.request对象可以获取ServletContext中的域属性。 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是request对象的特性及概念。request是一个HTTP请求对象。是由HttpServletRequestWrapper类实例化而来，而不是HttpServletRequest接口实例化，request对象不可以获取servletContext中的域属性。所以选择A选项。
","【正确答案】A
"
"
4、
以下URL中语法不正确的是？
","[{'optionContent': 'A.http://www.bta.net.cn:80/software/home.html \n', 'isCorrect': '-1'}, {'optionContent': 'B.telnet://bdysseu.bbb.com:70 \n', 'isCorrect': '-1'}, {'optionContent': 'C.ftp://ftp.btbu.edu.cn \n', 'isCorrect': '-1'}, {'optionContent': 'D.www0.btbu.edu.cn \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是url地址使用方式。并不存在www0这个域名。所以D选项描述错误。
","【正确答案】D
"
"多选题 （共计 1 题，总计 2分）
5
、
一个用户安装了Tomcat，但无法启动Tomcat，可能是由于哪些原因引起的？
","[{'optionContent': 'A.没有安装JDK \n', 'isCorrect': '-1'}, {'optionContent': 'B.Tomcat与JDK的版本不匹配，例如Tomcat6.x要求使用JDK1.5或以上版本 \n', 'isCorrect': '-1'}, {'optionContent': 'C.没有设置JAVA_HOME系统环境变量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.没有安装浏览器 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是 TOMCAT服务器使用细节。使用tomcat之前要先确认是否安装与当前服务器版本匹配的JDK，且必须配置JAVA_HOME环境变量。与浏览器是否安装没有关系，所以选择A,B,C选项。
","【正确答案】A,B,C
"
"

JDBC

1、
(单选题)下面的代码用于删除emp表中的empno为7369的记录：
Class.forName(""orcale.jdbc.OracleDriver"");
Connection con = DriverManager
.getConnection(""jdbc:oracle:thin:@192.168.0.26:1521:tarena""
,""openlab"",""open123"");
//填入代码段
stmt.close();
con.close();
填入代码段处应填入的代码是（此题考核jdbc的知识，对于数据库驱动无影响，可了解oracle的连接）：（）。
int updateRows= stmt.execute(""delete from emp where empno=7369""); 
int updateRows =stmt.executeUpdate(""delete from emp where empno=7369""); 
","[{'optionContent': 'A.Statement stmt= con.createStatement(""delete from emp where empno=7369""); \n', 'isCorrect': '-1'}, {'optionContent': 'B.Statement stmt =con.createStatement(""delete from emp where empno=7369""); \n', 'isCorrect': '-1'}, {'optionContent': 'C.Statement stmt = con.createStatement();\n', 'isCorrect': '-1'}, {'optionContent': 'D.Statement stmt = con.createStatement();\n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JDBC语句对象的应用 选项AB错误，Statement对象创建，方法createStatement()没有参数。 选项C错误，Statement对象中的execute(String sql)，方法返回boolean类型 选项D正确。
","【正确答案】D
"
"
2、
(单选题)不是 JDBC的组件是：()
","[{'optionContent': 'A.SQL执行器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.数据源 \n', 'isCorrect': '-1'}, {'optionContent': 'C.驱动程序管理器 \n', 'isCorrect': '-1'}, {'optionContent': 'D.驱动程序 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JDBC的基本概念。JDBC六步中并没有数据源这个步骤，所以明显选择B选项。
","【正确答案】B
"
"
3、
(单选题)关于PreparedStatement与Statement描述错误的是？
","[{'optionContent': 'A.一般而言PreparedStatement比Statement执行效率更高 \n', 'isCorrect': '-1'}, {'optionContent': 'B.PreparedStatement会预编译SQL语句。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Statement每次都会解析/编译SQL，确立并优化数据获取路径。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.PreparedStatement执行扫描的结果集比Statement小 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是 JDBC传输器的特点。A,B,C描述的内容均正确，则D选项，PreparedStatement和Statement扫描的结果集大小是一致的。所以D选项描述错误。
","【正确答案】D
"
"
4、
(单选题)下述选项中不属于JDBC基本功能的是：()
","[{'optionContent': 'A.与数据库建立连接 \n', 'isCorrect': '-1'}, {'optionContent': 'B.提交SQL语句 \n', 'isCorrect': '-1'}, {'optionContent': 'C.处理查询结果 \n', 'isCorrect': '-1'}, {'optionContent': 'D.数据库维护管理 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JDBC的基本概念。JDBC六步中并没有数据库维护管理这个步骤，所以明显选择D选项。
","【正确答案】D
"
"
5、
获取数据库连接的方法是？
","[{'optionContent': 'A.Connection() \n', 'isCorrect': '-1'}, {'optionContent': 'B.getConnection() \n', 'isCorrect': '-1'}, {'optionContent': 'C.con \n', 'isCorrect': '-1'}, {'optionContent': 'D.getContent() \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JDBC操作。连接数据库： 1.加载驱动： Class.forName(); 2.获取连接： DriverManager.getConnection(); 3.创建处理对象： 获取连接对象.createStatement(); 4.编写sql语句： sql语句！ 5.执行sql语句： statement.executeQuery(sql);//查询 starementexecuteUpdate(sql);//增，删，改 6.关闭流 获取连接对象.close;
","【正确答案】B
"
"
6、
下面的选项加载MySQL驱动正确的是哪一个？
","[{'optionContent': 'A.Class.forname(""com.mysql.JdbcDriver""); \n', 'isCorrect': '-1'}, {'optionContent': 'B.Class.forname(""com.mysql.driver.Driver""); \n', 'isCorrect': '-1'}, {'optionContent': 'C.Class.forname(""com.mysql.jdbc.MySQLDriver""); \n', 'isCorrect': '-1'}, {'optionContent': 'D.Class.forname(""com.mysql.jdbc.Driver""); \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是注册驱动的类名。mysql驱动包中，驱动的类名应该为com.mysql.jdbc.Driver。所以选择D选项。
","【正确答案】D
"
"多选题 （共计 4 题，总计 8分）

7、
(多选题)能执行带参数的SQL语句的对象是？
","[{'optionContent': 'A.Statement \n', 'isCorrect': '-1'}, {'optionContent': 'B.PreparedStatement \n', 'isCorrect': '-1'}, {'optionContent': 'C.CallStatement \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上三个都是 \n', 'isCorrect': '-1'}]","【答案解析】JDBC技术中涉及到发送sql语句的传输器。传输器一共有三种，Statement，PreparedStatement，CallableStatement。由此可知C选项拼写错误。剩余A,B两个选项均可在查询时添加参数。Statement以拼接的形式添加参数，PreparedStatement可以在问号预留的位置传入参数。
","【正确答案】A,B
"
"
8、
下面的描述Statement错误的是___？
","[{'optionContent': 'A.Statement是一个sql语句的传输器 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Statement的传输的sql语句较为安全，不容易受到攻击 \n', 'isCorrect': '-1'}, {'optionContent': 'C.PreparedStatement是Statement的父级接口，且有预编译功能 \n', 'isCorrect': '-1'}, {'optionContent': 'D.PreparedStatement拥有预留参数的功能 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是传输器概念及应用。Statement是一个普通的sql语句传输器，容易受到sql注入攻击，PreparedStatement是其子级接口，且能够预留参数。所以B,C描述错误，选择B,C选项。
","【正确答案】B,C
"
"
9、
(多选题)下面的描述正确的是：( )
","[{'optionContent': 'A.Statement的executeQuery()方法会返回一个结果集 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Statement的executeUpdate()方法会返回是否更新成功的boolean值 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用ResultSet中的getString()可以获得一个对应于数据库中varchar类型的值 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ResultSet中的next()方法会使结果集中的下一行成为当前行 \n', 'isCorrect': '-1'}]","【答案解析】executeQuery返回结果集类型的对象，A正确。B错误。getString()是用于获取数据库中的varchar和char类型的值。C正确。next方法两个作用：使结果集中下一行成为当前行，并返回当前行是否有效的布尔值。D正确。虽然D选项描述不完整，但是所描述的内容是正确的。
","【正确答案】A,C,D
"
"
10、
在JDBC编程中执行完下列SQL语句SELECT name, age, gender FROM employee，能得到rs的第一列数据的代码是哪两个？
","[{'optionContent': 'A.rs.getString(1); \n', 'isCorrect': '-1'}, {'optionContent': 'B.rs.getInt(""name""); \n', 'isCorrect': '-1'}, {'optionContent': 'C.rs.getString(0); \n', 'isCorrect': '-1'}, {'optionContent': 'D.rs.getString(""name""); \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是结果集概念及应用。rs对象在获取字段内容时候有两个重载方法，分别是根据字段名称和字段下标来获取。此题目中还要获取第一个name字段，name字段应该为字符串类型，所以应该使用A,D两个选项来选择字段值。
","【正确答案】A,D
"
"










数据库
1、
(单选题)若用如下的SQL语句创建了一个表SC: CREATE TABLE SC( S# CHAR(6) NOT NULL, C# CHAR(3) NOT NULL, SCORE INT, NOTE CHAR(20));向SC表插入如下行时，哪行可以被插入。
","[{'optionContent': 'A.(‘201009’, ’111’, ’60’, 必修) \n', 'isCorrect': '-1'}, {'optionContent': 'B.(‘200823’, ‘101’, NULL, NULL) \n', 'isCorrect': '-1'}, {'optionContent': 'C.(NULL, ‘103’, ‘80’, ‘选修’) \n', 'isCorrect': '-1'}, {'optionContent': 'D.(‘201132’, NULL, ’86’, “) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是SQL语句的插入语句。可以通过创建的语句中确定，S#字段不能为空，C#字段不能为空，从而得知，C,D选项错误，最后一个字段类型为char类型。所以插入数据必须书写单引号或者双引号。
","【正确答案】B
"
"
2、
(单选题)有关系 S（S＃, SNAME, SAGE）,C（C＃, CNAME）, SC（S＃, C＃, GRADE）。其中 S＃是学生号，SNAME 是学生姓名，SAGE是学生年龄， C＃是课程号， CNAME是课程名称。
要查询选修“ACCESS ”课的年龄不小于 20 的全体学生姓名的 SQL语句是 SELECT SNAME FROM   S， C， SC WHERE子句。这里的 WHERE子句的内容是（） 。
","[{'optionContent': 'A.SAGE>=20 and CNAME=’ ACCESS’ \n', 'isCorrect': '-1'}, {'optionContent': 'B.S.S# = SC.S# and C.C# = SC.C# and SAGE in>=20 and CNAME in ‘ACCESS ’ \n', 'isCorrect': '-1'}, {'optionContent': 'C.SAGE in>=20 and CNAME in ‘ACCESS ’ \n', 'isCorrect': '-1'}, {'optionContent': 'D.S.S# = SC.S# and C.C# = SC.C# and SAGE>=20 and CNAME= ‘ACCESS ’ \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是SQL语句的应用。从题目中的关系可以看出，需要三张表联查。表与表之间的连接关系是根据id连接。再添加题目条件年龄不小于20的选修ACCESS课程的学生，所以选择D选项。
","【正确答案】D
"
"
3、
(单选题)按照传统的数据库模型分类，数据库系统可以分为哪三类?
","[{'optionContent': 'A.大型、中型和小型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.西文、中文和兼容 \n', 'isCorrect': '-1'}, {'optionContent': 'C.层次、网状和关系 \n', 'isCorrect': '-1'}, {'optionContent': 'D.数据、图形和多媒体 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是数据库发展中的类型。应该为层次、网状和关系型数据库。选择C选项。
","【正确答案】C
"
"
4、
(单选题)为保证数据库字段的唯一，在建立表的时候应使用保留字（）
","[{'optionContent': 'A.UNIQUE \n', 'isCorrect': '-1'}, {'optionContent': 'B.COUNT \n', 'isCorrect': '-1'}, {'optionContent': 'C.DISTINCT \n', 'isCorrect': '-1'}, {'optionContent': 'D.UNION \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是MYSQL各个关键字的含义。
","【正确答案】A
"
"
多选题 （共计 6 题，总计 12分）
5、
下面有关数据库描述正确的是什么？
","[{'optionContent': 'A.现在常用的数据库是关系型数据库 \n', 'isCorrect': '-1'}, {'optionContent': 'B.所有市面上的数据库都是免费的，可以任意使用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一般情况下，会根据一个项目创建一个数据库，一个功能创建一张表 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sql是所有数据库的通用语言 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是数据库概念及应用。现在常用数据库就是关系型数据库。数据库分为开源和收费两种。一般情况下，会根据一个项目创建一个数据库，一个功能创建一张表。sql可以在所有数据库中使用。所以选择A,C,D选项。
","【正确答案】A,C,D
"
"
6、
以下有关数据库表的叙述有错的是？
","[{'optionContent': 'A.一张表中只能有一个主键 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主键一定为自动增长 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个数据库中可以存在两个同名表 \n', 'isCorrect': '-1'}, {'optionContent': 'D.表中的字段可以不必书写字段类型 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是创建数据库表中的细节。数据库表中可以有多个主键，主键不一定自动增长，一个数据库中不可以出现两个同名表。表中的字段必须有数据类型。所以选择A,C,D三个选项。
","【正确答案】A,C,D
"
"
7、
Stu为学生表,Class为班级表(其中banzhangid字段为外键,指向Stu表中的id),下列哪个选项可以查询出班级名称及对应的班长的姓名？（多选）
stu:
  +------+--------------+
  | id   |	name 	|
  +------+--------------+
  | s01  |	张无忌	| 
  +------+--------------+
  | s02  |	韦小宝	| 
  +------+--------------+
  | s03  |	段誉	| 
  +------+--------------+
  | s04  |	杨过	| 
  +------+--------------+
class:		
 +------+-------------+----------------+
 | id	 | name   |banzhangid|
 +------+-------------+---------------+
 | 001   |向日葵班|  s01	 |
 | 002   |玫瑰花班|  s02	 | 
 | 003   |菊花班  |  s04	 |
 +------+-------------+---------------+
","[{'optionContent': 'A.Select class.name 班级,stu .name 班长 from class ,stu; \n', 'isCorrect': '-1'}, {'optionContent': 'B.Select class.name 班级,stu .name 班长 from class ,stu where class.banzhangid=stu.id; \n', 'isCorrect': '-1'}, {'optionContent': 'C.Select class.name 班级,stu .name 班长 from class inner join stu; \n', 'isCorrect': '-1'}, {'optionContent': 'D.Select class.name 班级,stu .name 班长 from class inner join stu on class.banzhangid=stu.id; \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是SQL语句的应用。根据多表查询的方式可以得知，两张表一起查询，需要添加条件过滤出正确的选项。所以B,D选项正确。
","【正确答案】B,D
"
"
8、
SQL中，下列关于创建、管理数据库的操作语句不正确的是？
","[{'optionContent': 'A.CREATE DATABASE Instant \n', 'isCorrect': '-1'}, {'optionContent': 'B.USE Instant \n', 'isCorrect': '-1'}, {'optionContent': 'C.NEW DATABASE Instant \n', 'isCorrect': '-1'}, {'optionContent': 'D.Delete DATEBASE Instant \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是操作数据库的语句。创建数据库的语句为create database db_name;删除数据库的语句为Drop database db_name;所以C,D选项。
","【正确答案】C,D
"
"
9、
以下有关主键的表述正确的是？
","[{'optionContent': 'A.主键约束的字段中的数据不能重复 \n', 'isCorrect': '-1'}, {'optionContent': 'B.主键约束的字段中的数据不能为null \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以声明多个列一起作为主键,称为联合主键 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sql语句主键预留的关键字为：primary key \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是主键的基本概念及应用方式。主机约束的字段使用primary key修饰。且主键字段不允许为空，也不允许重复。一个表中的若有多个主键，则称之为联合主键。所以A,B,C,D选项正确。
","【正确答案】A,B,C,D
"
"
10、
(多选题)以下有关数据库键的表述正确的是？（）
","[{'optionContent': 'A.主键约束的字段中的数据不能重复 \n', 'isCorrect': '-1'}, {'optionContent': 'B.只有主键约束的字段中的数据不能为null \n', 'isCorrect': '-1'}, {'optionContent': 'C.主键可以作为索引使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.设置主键，字段不能为空，所以会自动增长 \n', 'isCorrect': '-1'}]","【答案解析】主键：表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义 PRIMARY KEY 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列
","【正确答案】A,C
"
"








 
WEB前端技术
1、
(单选题)下面哪一个是Json对象？
","[{'optionContent': 'A.{name:""xiaoming"",age:18} \n', 'isCorrect': '-1'}, {'optionContent': 'B.{“name”:”xiaoming”,”age”:”18”} \n', 'isCorrect': '-1'}, {'optionContent': 'C.{“xiaoming”,”student”} \n', 'isCorrect': '-1'}, {'optionContent': 'D.[“xiaoming”,”student”] \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JSON相关概念。js对象可以引申为json对象，其格式为{ name：”xiaoming”,age,”student”},主要特征是键名不使用双引号包起来，值可能使用双引号包起来。所以选择A选项。
","【正确答案】A
"
"
2、
(单选题)在Javascript中如何把7.25四舍五入为最接近的整数（）
","[{'optionContent': 'A.round(7.25) \n', 'isCorrect': '-1'}, {'optionContent': 'B.rnd(7.25) \n', 'isCorrect': '-1'}, {'optionContent': 'C.Math.rnd(7.25) \n', 'isCorrect': '-1'}, {'optionContent': 'D.Math.round(7.25) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JS的内置对象Math.四舍五入为js中内置的Math身上的方法。调用方式为Math.round()。
","【正确答案】D
"
"3
、
(单选题)setInterval(""alert('welcome');"",1000); 这段代码的意思是()
","[{'optionContent': 'A.等待1000秒后，再弹出一个对话框 \n', 'isCorrect': '-1'}, {'optionContent': 'B.等待1秒钟后弹出一个对话框 \n', 'isCorrect': '-1'}, {'optionContent': 'C.每隔一秒钟弹出一个对话框 \n', 'isCorrect': '-1'}, {'optionContent': 'D.语句报错,语法有问题 \n', 'isCorrect': '-1'}]","【答案解析】setInterval是DHTML中BOM对象中的window对象身上的方法。代表着每过一段时间执行一次函数。题目语句书写无误，所以选C。
","【正确答案】C
"
"
4、
(单选题)关于JavaScript正则表达式，能够匹配邮箱的是（）
","[{'optionContent': 'A.^(0|[1-9][0-9]*)$ \n', 'isCorrect': '-1'}, {'optionContent': 'B.^\\w+@\\w\\.\\w+$ \n', 'isCorrect': '-1'}, {'optionContent': 'C.\\w@\\w+(\\.\\w+)+ \n', 'isCorrect': '-1'}, {'optionContent': 'D.\\w+@\\w+(\\.\\w+)+ \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JS的正则使用方式。JS中的正则使用方式和JAVA中的使用方式相同。所以答案显而易见是D。
","【正确答案】D
"
"
5、
(单选题)在JavaScript中定义 var a=”40”,var b=7,则执行a%b会得到？
","[{'optionContent': 'A.5 \n', 'isCorrect': '-1'}, {'optionContent': 'B.“5” \n', 'isCorrect': '-1'}, {'optionContent': 'C.underfined \n', 'isCorrect': '-1'}, {'optionContent': 'D.null \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JS的数据类型在运算中的特点。虽然a为字符串的40，但是在取余运算时，会自动转换为数值型的40，完成运算，获得数值型的结果5.
","【正确答案】A
"
"
6、
(单选题)以下选项中，哪个标签表示复选框：（）
","[{'optionContent': 'A.<input type=""checkbox""/> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<input type=""text""/> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<input type=""radio""/> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<input type=""textarea""/> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是input框的用法。input框中可以使用type来区分不同的选框。其中复选框使用的是type=”checkbox”。
","【正确答案】A
"
"
7、
(单选题)通常我们可以在浏览器内容区看到的内容，都是放在（）之间
","[{'optionContent': 'A.<!doctype html> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<html> </html> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<head></head> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<body><body> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是HTML中的基本结构，是声明，只能出现在第一行，并不会展示页面内容，标签是整个页面范围最大的标签，可以存储和标签，所以不是专门存储页面内容的标签。常用于存储页面中的配置信息。是中的内容是用户展示页面的。所以选择D。
","【正确答案】D
"
"8
、
在JavaScript中，失去焦点触发的方法是?
","[{'optionContent': 'A.onblur( ) \n', 'isCorrect': '-1'}, {'optionContent': 'B.focus( ) \n', 'isCorrect': '-1'}, {'optionContent': 'C.blur( ) \n', 'isCorrect': '-1'}, {'optionContent': 'D.leave( ) \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是DHTML技术中的window对象。window对象身上是失去焦点事件为onblur，所以选择A选项。
","【正确答案】A
"
"
9、
(单选题)关于以下css样式选择器的优先级下面描述正确的是?
","[{'optionContent': 'A.ID选择器->类选择器->标签选择器->行内式（inline） \n', 'isCorrect': '-1'}, {'optionContent': 'B.类选择器->ID选择器->标签选择器->行内式（inline） \n', 'isCorrect': '-1'}, {'optionContent': 'C.行内式（inline）->ID选择器->类选择器->标签选择器 \n', 'isCorrect': '-1'}, {'optionContent': 'D.行内式（inline）->类选择器->ID选择器->标签选择器 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是CSS的优先级，在多个css修饰同时存在的情况下，行内式（inline）->ID选择器->类选择器->标签选择器，所以选择C选项。
","【正确答案】C
"
"
10、
(单选题)下面关于js事件的响应，描述错误的是（）
","[{'optionContent': 'A.onclick鼠标点击事件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.onfocus元素失去焦点事件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.onload是某个页面的css js html 文档结构和图像被完全加载 \n', 'isCorrect': '-1'}, {'optionContent': 'D.onmousedown 某个鼠标按键被按下 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JS的API。onfocus是元素获取焦点事件，所以B错误。
","【正确答案】B
"
"
11、(单选题)表单中的数据要提交到到哪里处理由表单的（ ）属性指定。
","[{'optionContent': 'A.method \n', 'isCorrect': '-1'}, {'optionContent': 'B.name \n', 'isCorrect': '-1'}, {'optionContent': 'C.action \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不对 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是form标签的应用，其中表单提交的位置是通过action属性的来指定的。所以选择C选项。
","【正确答案】C
"
"
12、(单选题)我们可以在下列哪个HTML元素中放置 Javascript 代码?
","[{'optionContent': 'A.<script> \n', 'isCorrect': '-1'}, {'optionContent': 'B.<javascript> \n', 'isCorrect': '-1'}, {'optionContent': 'C.<js> \n', 'isCorrect': '-1'}, {'optionContent': 'D.<scripting> \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是引入方式。在页面中的标签中的书写
","【正确答案】A
"
"
13、(单选题)执行以下程序后，x的值是（）
var x=0;
switch(++x){
case 0:++x;
case 1:++x;
case 2:++x;
}
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.4 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是JS语句的特性。在判断题位置的内容会先执行，再运算。所以进入switch之后x=1，执行case 1。再次加一。由于语句之后没有break，所以会依次执行剩下的case语句，再次加一。所以结果为3。
","【正确答案】C
"
"
16、
(单选题)以下哪个不是document对象的方法是？

多选题 （共计 4 题，总计 8分）
17、
下列有关JavaScript说法正确的是（）。
","[{'optionContent': 'A.getElementById \n', 'isCorrect': '-1'}, {'optionContent': 'B.getElementsById \n', 'isCorrect': '-1'}, {'optionContent': 'C.getElementsByTagName \n', 'isCorrect': '-1'}, {'optionContent': 'D.getElemenetsByName \n', 'isCorrect': '-1'}, {'optionContent': 'A.javascript是一门独立的语言 \n', 'isCorrect': '-1'}, {'optionContent': 'B.javascript相关的代码需要写在<script>标签中 \n', 'isCorrect': '-1'}, {'optionContent': 'C.javascript可以实现页面中的一些动态效果，所以属于动态web资源 \n', 'isCorrect': '-1'}, {'optionContent': 'D.javascript可以实现前台页面的校验 \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是javascript特征及概念。javascript是一门独立的脚本语言，书写时需要写在script标签中，能够完成前台的校验。A,B,D选项正确。
","【正确答案】A,B,D
"
"
18、
(多选题)下列属于CSS 选择符的是？
","[{'optionContent': 'A.id选择器（ # myid） \n', 'isCorrect': '-1'}, {'optionContent': 'B.类选择器（.myclassname） \n', 'isCorrect': '-1'}, {'optionContent': 'C.元素名选择器（div, h1, p） \n', 'isCorrect': '-1'}, {'optionContent': 'D.相邻选择器（h1 + p） \n', 'isCorrect': '-1'}]","【答案解析】题目考察的是CSS选择器的应用。四项内容均为CSS选择器的内容，所以全部正确
","【正确答案】A,B,C,D
"
"
19、
(多选题)下列选项中(   )是属性选择器。
","[{'optionContent': 'A.$(""img[src=.gif]"") \n', 'isCorrect': '-1'}, {'optionContent': 'B.$(""img"") \n', 'isCorrect': '-1'}, {'optionContent': 'C.[title=hello]{color:back;} \n', 'isCorrect': '-1'}, {'optionContent': 'D.$(""div>span"") \n', 'isCorrect': '-1'}]","【答案解析】此题目考查的是jQuery选择器理解。A,C包含”[]”所以明显为属性选择器。
","【正确答案】A,C
"
"




反射
1、
下列关于反射的说法错误的是？
","[{'optionContent': 'A.可以通过newlnstance()来创建一个字节码对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过 Class<String> clz = Class. forName(""String"");来获取代表String类的Class对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Method[] ms = String.class. getMethods()来获取 String 类中的所有方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.通过执行方法对象上的invoke方法来运行该方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.当私有属性想直接赋值的时候，必须先要将其暴力破解 \n', 'isCorrect': '-1'}]","【答案解析】newinstance方法是执行构造方法返回实例对象。B选项需要填入全路径名。C选项需要调用Declared这样的方法
","【正确答案】A,B,C
"
"
2、
下列各项中，关于枚举的说法正确的是
","[{'optionContent': 'A.可以利用Enumeration来声明一个枚举对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.枚举类中可以定义静态常量 \n', 'isCorrect': '-1'}, {'optionContent': 'C.枚举类中可以定义抽象方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.所有的枚举类的顶级父类是java.lang.Enumeration \n', 'isCorrect': '-1'}, {'optionContent': 'E.从JDK1.5开始，switch-case语句支持枚举常量 \n', 'isCorrect': '-1'}]","【答案解析】Enumeration是迭代器对象。所以枚举类的顶级父类是java.lang.Enum
","【正确答案】B,C,E
"
"

网络编程
1、
java socket如何获取本地ip地址
","[{'optionContent': 'A.getInetAddress() \n', 'isCorrect': '-1'}, {'optionContent': 'B.getLocalAddress() \n', 'isCorrect': '-1'}, {'optionContent': 'C.getReuseAddress() \n', 'isCorrect': '-1'}, {'optionContent': 'D.getReuseAddress(） \n', 'isCorrect': '-1'}]","【答案解析】只有getLocalAddress才能返回ip地址
","【正确答案】B
"
"
2、
下面哪个方法是类 java.net.Socket的成员方法，用来获取 Socket的输入流
","[{'optionContent': 'A.getChannel() \n', 'isCorrect': '-1'}, {'optionContent': 'B.getConnetion() \n', 'isCorrect': '-1'}, {'optionContent': 'C.getInputStream() \n', 'isCorrect': '-1'}, {'optionContent': 'D.getStream() \n', 'isCorrect': '-1'}]","【答案解析】获取自带输入流
","【正确答案】C
"
"
多选题 （共计 1 题，总计 2分）
3、
下列哪些在socket编程中,属于服务端的操作可以是?
","[{'optionContent': 'A.connect \n', 'isCorrect': '-1'}, {'optionContent': 'B.write \n', 'isCorrect': '-1'}, {'optionContent': 'C.close \n', 'isCorrect': '-1'}, {'optionContent': 'D.accept \n', 'isCorrect': '-1'}]","【答案解析】connect属于客户端的操作
","【正确答案】B,C,D
"
"




线程
1、
编译并运行程序，下列说法正确的是？ public class Ground extends Thread{ public static void main(String args[]){ Ground g= new Ground(); g.start(); } public void run(){ for(inti=0;i<10;i++){ System.out.println(""Value of i = ""+i); } } }
","[{'optionContent': 'A.编译错误，指明run方法没有定义 \n', 'isCorrect': '-1'}, {'optionContent': 'B.运行错误，只指明run方法没有定义 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译通过并输出0到9 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译通过，但无输出 \n', 'isCorrect': '-1'}]","【答案解析】继承Thread类创建线程对象执行循环输出0-9
","【正确答案】C
"
"
2、
多个线程同时操作一个数据，为了保证数据的准确性，可将操作该数据的部分改为
","[{'optionContent': 'A.只读 \n', 'isCorrect': '-1'}, {'optionContent': 'B.只写 \n', 'isCorrect': '-1'}, {'optionContent': 'C.同步 \n', 'isCorrect': '-1'}, {'optionContent': 'D.异步 \n', 'isCorrect': '-1'}]","【答案解析】同步才能保证线程对象没有抢占
","【正确答案】C
"
"
3、
下列有关线程的说法正确的是（ ）
","[{'optionContent': 'A.启动一个线程是调用start（）方法，是线程所代表的虚拟处理机处于可运行状态，这意味着线程此时就会立即运行。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.notify（）方法可以确切的唤醒某个处于等待状态的线程。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.wait（）方法可以使一个线程处于等待状态，但不会释放所持有对象的锁 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sleep（）方法使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法时，需要捕捉InterruptedException异常。 \n', 'isCorrect': '-1'}]","【答案解析】调用start()是开启线程让线程对象处于就绪状态，因为线程执行之前需要做一些准备工作。notify()只能随机唤醒一个线程对象不能指定。Wait()会让线程处于等待也会释放对象锁
","【正确答案】D
"
"
4、
下列程序的功能是在控制台上，每隔1秒钟显示字符串""Hello"",能够填写在程序中下划线位置，使程序完整，并能够正确运行的语句是（ ） public class Test implements Runnable {
	public static void main(String[] args) {
		Test t = new Test();
		Thread tt = new Thread(t);
		tt.start();
	}

	public void run(){ 
		for(;;){ 
			try{ __________ 
				}catch(_________ e ){
					
				} 
			System.out.println(“Hello”); 
			}
		}
}
","[{'optionContent': 'A.Thread. sleep (1000) InterruptedException \n', 'isCorrect': '-1'}, {'optionContent': 'B.sleep (1000) InterruptedException \n', 'isCorrect': '-1'}, {'optionContent': 'C.t. sleep (1000) InterruptedException \n', 'isCorrect': '-1'}, {'optionContent': 'D.Thread. sleep (1000) RuntimeException \n', 'isCorrect': '-1'}]","【答案解析】Sleep（）是定义在Thread类中的一个静态方法并且抛出的异常是InterruptedException
","【正确答案】A
"
"
5、
执行以下程序，最终输出可能是 
Thread[] the = new Thread[3];
		for (int i = 0; i < 3; i++) {
			the[i] = new Thread(new Runnable() {
				@Override
				public void run() {
					for (int j = 0; j < 5; j++) {
						System.out.print(j);
					}
					System.out.print(""*"");
				}
			});
		}
		for (Thread thread : the) {
			thread.start();
		}
","[{'optionContent': 'A.010*2123012*3434 \n', 'isCorrect': '-1'}, {'optionContent': 'B.01201*340124*2334 \n', 'isCorrect': '-1'}, {'optionContent': 'C.0012314*01223344** \n', 'isCorrect': '-1'}, {'optionContent': 'D.12345*12345*12345 \n', 'isCorrect': '-1'}]","【答案解析】每个线程都会输出01234*，虽然线程之间会存在相互抢占每次结果可能会不同，但是线程不会回头执行，所以*之前一定会打印01234
","【正确答案】C
"
"
6、
①Thread myThread=new MyThreadClass(); ②myThread.start(); ③try ④{ ⑤ myThread.sleep(10000); ⑥} ⑦catch(InterruptedException e) ⑧{ ⑨} ⑩myThread.stop(); 程序执行完第一行后，线程进入______ __状态； 程序执行完第二行后，线程进入_______状态； 程序开始执行第五行时，线程进入________状态； 程序执行完第五行后，线程进入________状态； 程序执行完第十行后，线程进入_______状态；
","[{'optionContent': 'A.新建状态、可运行状态、阻塞状态、阻塞状态、终止状态 \n', 'isCorrect': '-1'}, {'optionContent': 'B.新建状态、可运行状态、阻塞状态、可运行状态、终止状态 \n', 'isCorrect': '-1'}, {'optionContent': 'C.新建状态、可运行状态、可运行状态、阻塞状态、终止状态 \n', 'isCorrect': '-1'}, {'optionContent': 'D.新建状态、就绪状态、可运行状态、阻塞状态、终止状态 \n', 'isCorrect': '-1'}]","【答案解析】创建线程对象就是指线程对象处于创建状态，当开启线程时线程对象处于就绪状态需要为接下来的执行做准备，当调用sleep方法时就是强使线程对象进行休眠也就是等待状态，休眠时间结束立即转为就绪状态为下一次的执行做准备，调用stop方法就是结束线程，线程对象进入终止状态
","【正确答案】B
"
"
7、
下列各项中，关于线程的说法正确的
","[{'optionContent': 'A.在synchronized代码块中，Integer.class可以作为锁对象来使用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.守护线程结束，被守护线程随之结束 \n', 'isCorrect': '-1'}, {'optionContent': 'C.如果线程t1的优先级为2，线程t2的优先级位7，则理论上线程t1抢占资源的概率更大 \n', 'isCorrect': '-1'}, {'optionContent': 'D.线程在sleep期间释放锁对象也释放执行权 \n', 'isCorrect': '-1'}, {'optionContent': 'E.如果代码中出现了死锁，可以通过try-catch来进行捕获处理 \n', 'isCorrect': '-1'}]","【答案解析】方法区被所有线程对象共享所有可以作为锁对象。被守护线程结束守护线程才结束。优先级越大理论上抢到的资源概率更大。Sleep不会释放锁对象。产生死锁之后一般是优化代码或者指定优先级大的先执行
","【正确答案】A
"
"
8、
以下哪个方法用于定义线程的执行体？
","[{'optionContent': 'A.start() \n', 'isCorrect': '-1'}, {'optionContent': 'B.init() \n', 'isCorrect': '-1'}, {'optionContent': 'C.run() \n', 'isCorrect': '-1'}, {'optionContent': 'D.synchronized() \n', 'isCorrect': '-1'}]","【答案解析】无论是继承Thread类还是实现Runnable接口都是重写run方法
","【正确答案】C
"
"
9、
下列程序的运行结果( ) public class Demo {
	public static void main(String[] args) {
		Object obj = new Object();
		Salar s1 = new Salar(""张三"", obj);
		Salar s2 = new Salar(""李四"", obj);
		Salar s3 = new Salar(""王五"", obj);
		s1.start();
		s2.start();
		s3.start();
	}
}

class Salar extends Thread {
	private String name;
	Object obj = new Object();

	public Salar(String name, Object obj) {
		this.name = name;
		this.obj = obj;
	}

	public void run() {
		synchronized (obj) {
			for (int i = 0; i < 2; i++) {
				System.out.println(name + ""--出发了"");
			}
		}
	}
}
","[{'optionContent': 'A.异步 \n', 'isCorrect': '-1'}, {'optionContent': 'B.同步 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译报错 \n', 'isCorrect': '-1'}, {'optionContent': 'D.无法确定 \n', 'isCorrect': '-1'}]","【答案解析】通过有参构造进行传值创建线程对象时，传的是同一个obj对象，当线程把obj对象当作锁对象时三个线程对象共享这一个锁对象所以可以锁住三个线程对象之间就实现了同步
","【正确答案】B
"
"
10
、
下列关于单例设计模式的描述中，正确的是（   ）
","[{'optionContent': 'A.将一个类设计为单例设计模式,在其他类中可以创建这个类对象 \n', 'isCorrect': '-1'}, {'optionContent': 'B.将一个类设计为单例设计模式,必须私有其无参数构造方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.将一个类设计为单例设计模式,必须定义一个静态的成员方法将本类创建的对象返回给调用者 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上答案都不对 \n', 'isCorrect': '-1'}]","【答案解析】单例模式就是只能提供一个对象而且需要在本类中创建所以构造方法一定要私有。单例模式的实现形式有很多种不一定必须要定义静态方法返回。
","【正确答案】B
"
"多选题 （共计 4 题，总计 8分）

11、
在Java线程状态转换时，下列转换不可能发生的有()?
","[{'optionContent': 'A.初始态->运行态 \n', 'isCorrect': '-1'}, {'optionContent': 'B.就绪态->运行态 \n', 'isCorrect': '-1'}, {'optionContent': 'C.阻塞态->运行态 \n', 'isCorrect': '-1'}, {'optionContent': 'D.运行态->就绪态 \n', 'isCorrect': '-1'}]","【答案解析】线程执行不可能直接执行都要经过就绪，线程执行完可以转回就绪
","【正确答案】A,C
"
"
12、
下面关于自定义一个线程说法正确的是
","[{'optionContent': 'A.实现Thread接口，重写run方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.实现Runnable接口，重写run方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.实现Callable接口，重写call方法，call方法没有返回值 \n', 'isCorrect': '-1'}, {'optionContent': 'D.继承Thread类，重写run方法 \n', 'isCorrect': '-1'}]","【答案解析】Thread是类。Call方法必须有返回值
","【正确答案】B,D
"
"
13、
属于单例模式的基本要点的是
","[{'optionContent': 'A.静态工厂方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.构造方法私有化 \n', 'isCorrect': '-1'}, {'optionContent': 'C.唯一实例 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不对 \n', 'isCorrect': '-1'}]","【答案解析】单例模式就是全局只能提供一个对象所以构造方法私有化
","【正确答案】B,C
"
"
14、
关于sleep()和wait()，下列说法正确的是？
","[{'optionContent': 'A.sleep不释放对象锁，wait放弃对象锁 \n', 'isCorrect': '-1'}, {'optionContent': 'B.sleep暂停线程、但监控状态仍然保持，结束后自动恢复 \n', 'isCorrect': '-1'}, {'optionContent': 'C.sleep是线程类（Thread）的方法，wait是Object类的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用 \n', 'isCorrect': '-1'}]","【答案解析】查看笔记即可
","【正确答案】A,B,C,D
"
"
15、阅读以下代码： public class X extends Thread implements Runnable{ public void run(){ System.out.println(“this is run()”); } public static void main(String args[]){ Thread t=new Thread(new X()); t.start(); } } 下列说法正确的是（）
","[{'optionContent': 'A.第一行会产生编译错误 \n', 'isCorrect': '-1'}, {'optionContent': 'B.第六行会产生编译错误 \n', 'isCorrect': '-1'}, {'optionContent': 'C.第六行会产生运行错误 \n', 'isCorrect': '-1'}, {'optionContent': 'D.程序会运行和启动 \n', 'isCorrect': '-1'}]","【答案解析】Thread类提供了Runnable类型的有参构造，X类对象就是Runnable类型所以可以正常构建线程对象和启动
","【正确答案】D
"
"




IO流
1、
下列各项中，说法正确的是：
","[{'optionContent': 'A.Reader r = new FileReader(); 能够正确的编译运行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.转换流使用的默认编码是GBK编码 \n', 'isCorrect': '-1'}, {'optionContent': 'C.序列化流可以将一个ArrayList对象序列化到硬盘上 \n', 'isCorrect': '-1'}, {'optionContent': 'D.OuputStreamWriter是一个字节流 \n', 'isCorrect': '-1'}, {'optionContent': 'E.加载一个视频文件需要用字节输入流 \n', 'isCorrect': '-1'}]","【答案解析】创建IO对象需要指定路径。转换流编码要看当前是字符转字节还是字节转字符。持久化才是存储到硬盘中。D选项是字符流
","【正确答案】E
"
"
2、
在Java中，下列关于读写文件的描述错误的是
","[{'optionContent': 'A.Reader类的read()方法用来从源中读取一个字符的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Reader类的read(int n )方法用来从源中读取一个字符的数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Writer类的write(int n)方法用来向输出流写入单个字符 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Writer类的write(String str)方法用来向输出流写入一个字符串 \n', 'isCorrect': '-1'}]","【答案解析】B选项读取的是字符个数
","【正确答案】B
"
"
3、
下面哪个流类属于面向字符的输入流
","[{'optionContent': 'A.BufferedWriter \n', 'isCorrect': '-1'}, {'optionContent': 'B.FileInputReader \n', 'isCorrect': '-1'}, {'optionContent': 'C.InputStream \n', 'isCorrect': '-1'}, {'optionContent': 'D.InputStreamReader \n', 'isCorrect': '-1'}]","【答案解析】面向字符就是在考察转换流的问题，所以选择D
","【正确答案】D
"
"
4、
关于反射机制下列说法错误的是？
","[{'optionContent': 'A.反射机制指的是在程序运行过程中，通过.class文件加载并使用一个类的过程 \n', 'isCorrect': '-1'}, {'optionContent': 'B.反射机制指的是在程序编译期间，通过.class文件加载并使用一个类的过程 \n', 'isCorrect': '-1'}, {'optionContent': 'C.反射可以获取类中所有的属性和方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.暴力反射可以获取类中私有的属性和方法 \n', 'isCorrect': '-1'}]","【答案解析】反射发生在运行时期
","【正确答案】B
"
"
多选题 （共计 4 题，总计 8分）
5、
下列说法正确的是
","[{'optionContent': 'A.使用transient修饰的变量不会被序列化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.使用PrintWriter可以将对象进行传输 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用FileOutputStream可以将对象进行传输 \n', 'isCorrect': '-1'}, {'optionContent': 'D.对象序列化的所属类需要实现Serializable接口 \n', 'isCorrect': '-1'}]","【答案解析】PrintWriter和FileOutPutStream都不能传输对象
","【正确答案】A,D
"
"
6、
能指定字符编码的I/O流类型是
","[{'optionContent': 'A.Reader \n', 'isCorrect': '-1'}, {'optionContent': 'B.InputStreamReader \n', 'isCorrect': '-1'}, {'optionContent': 'C.BufferedReader \n', 'isCorrect': '-1'}, {'optionContent': 'D.Writer \n', 'isCorrect': '-1'}, {'optionContent': 'E.OutputStreamWriter \n', 'isCorrect': '-1'}]","【答案解析】可以指定编码的只有转换流
","【正确答案】B,E
"
"
7、
下列关于Java中文件输入输出的说法错误的是
","[{'optionContent': 'A.在Java中，可以通过流来实现文件的读写操作 \n', 'isCorrect': '-1'}, {'optionContent': 'B.要向文件中写入数据，可以用一个输入流对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.字符流在汉字的处理方面比字节流更加的高效 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过Reader reader = new Reader(“C:\\\\a.txt”);来创建一个流对象 \n', 'isCorrect': '-1'}, {'optionContent': 'E.字符流底层也是通过字节流来实现的，因此通过字符流来操作的一定可以通过字节流来操作 \n', 'isCorrect': '-1'}]","【答案解析】写入数据是需要一个输出流对象。Reader是抽象类没有对象
","【正确答案】B,D
"
"
8、
以下选项中关于如下代码的说法正确的是（ ）。 public class TestBuffered { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(""d:/bjsxt1.txt"")); BufferedWriter bw = new BufferedWriter(new FileWriter(""d:/bjsxt2.txt"")); String str = br.readLine(); while (str != null) { bw.write(str); bw.newLine(); str = br.readLine(); } br.close(); bw.close(); } }
","[{'optionContent': 'A.该类使用字符流实现了文件复制，将d:/bjsxt1.txt复制为d:/bjsxt2.txt \n', 'isCorrect': '-1'}, {'optionContent': 'B.FileReader和FileWriter是字节流，直接从文件读写数据 \n', 'isCorrect': '-1'}, {'optionContent': 'C.BufferedReader和BufferedWriter是字节流，提供缓冲区功能，提高读写效率 \n', 'isCorrect': '-1'}, {'optionContent': 'D.readLine()可以读取一行数据，返回值是字符串类型，简化了操作 \n', 'isCorrect': '-1'}]","【答案解析】FileReader与File Writer是字符流。BufferedReader和BufferedWriter是字符流
","【正确答案】A,D
"
"



映射与文件
1、
在Java中，关于HashMap类的描述，以下说法错误的是？
","[{'optionContent': 'A.HashMap使用键/值的形式保存数据 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HashMap能够保证其中元素的顺序 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HashMap的存储方式是哈希表，查询指定元素效率高 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HashMap通过get( key)获取对应的值 \n', 'isCorrect': '-1'}]","【答案解析】hashMap底层key是根据链式栈结构进行存储的不能保证顺序
","【正确答案】B
"
"
2、
下列关于File的说法正确的是
","[{'optionContent': 'A.File file=new File(""D:\\\\a.txt"");是在D盘下创建一个a.txt文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过mkdirs()方法创建多个文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.当调用getPath()方法的时候，会去计算机中检查 该文件是否存在 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过isFile()方法判断该File对象是否是一个文件对象 \n', 'isCorrect': '-1'}]","【答案解析】创建File对象只是指明有一个路径但是不会去检查路径是否存在。mkdirs方法是可以创建多个目录。getPath方法返回的是路径名
","【正确答案】D
"
"
多选题 （共计 2 题，总计 4分）
3、
下列说法正确的是
","[{'optionContent': 'A.HashMap的实现不是线程同步的，不是线程安全的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.HashMap中的key-value都是存放在Entry中的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.HashMap有两个参数影响其对象的性能：“初始容量”、“加载因子 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Hashmap保证元素的顺序恒久不变 \n', 'isCorrect': '-1'}]","【答案解析】HashMap底层的键是根据链式栈结构来进行存储的，扩容之后就会重新计算所有结果，所有无法保证顺序不变
","【正确答案】A,B,C
"
"
4、
下列关于File的说法正确的是：
","[{'optionContent': 'A.File file = new File(""D:\\\\a.txt"");是在D盘下创建了—个a.txt文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过mkdirs()方法创建多个文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.当调用getPath()方法的时候，会去计算机中检查该文件是否存在 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过isFile()方法判断该File对象是否是一个文件对象 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以通过list(FileFilter filter)来筛选执行目录下的子目录对象 \n', 'isCorrect': '-1'}]","【答案解析】创建文件对象不会去检测路径是否存在。Mkdirs创建多个文件夹。C选项是获取路径
","【正确答案】D,E
"
"





集合
1、
下列关于ArrayList和LinkedList和Vector说法错误的是
","[{'optionContent': 'A.ArrayList 和 Vector 都ay是使用数组方式存储数据，所以查找速度比较快 \n', 'isCorrect': '-1'}, {'optionContent': 'B.LinkedList是基于链表实现的，所以进行插入速度比较快 \n', 'isCorrect': '-1'}, {'optionContent': 'C.LinkedList内存不连续不会发生扩容 \n', 'isCorrect': '-1'}, {'optionContent': 'D.ArrayList是线程安全的，LinkedList是非线程安全的 \n', 'isCorrect': '-1'}]","【答案解析】ArrayList也是线程不安全的
","【正确答案】D
"
"
2、
给出以下代码运行结果Collection<String> c = new ArrayList<>();
		c.add(""ac"");
		c.add(""bdc"");
		c.add(""cac"");
		c.add(""dad"");
		Stream<String> s = c.stream();
		s.filter(str -> str.matches("".*a.*"")).filter(str -> str.endsWith(""c"")).forEach(str -> {
			c.remove(str);
			System.out.println(str);
			System.out.println(c);
			try {
				Thread.sleep(500);
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
","[{'optionContent': 'A.ac [bdc,cac,dad] cac [bdc,dad] NullPointerException \n', 'isCorrect': '-1'}, {'optionContent': 'B.ac dbc cac [dbc] \n', 'isCorrect': '-1'}, {'optionContent': 'C.ac [bdc,cac,dad] cac [bdc,dad] \n', 'isCorrect': '-1'}, {'optionContent': 'D.NullPointerException \n', 'isCorrect': '-1'}]","【答案解析】把包含a的元素进行筛选出来再根据以c结尾来进行过滤，剩下了ac和cac，根据ac和cac进行删除接着输出删除内容再输出新的剩下的元素，要删除2个所以要输出2次最后结果是ac [bdc,cac,dad] cac [bdc,dad]，最后又执行了一次删除但是此时没有元素了c的对象就是null再调用remove方法就出来空指针异常
","【正确答案】A
"
"
3、
下面关于泛型，说法不正确的是
","[{'optionContent': 'A.在jdk1.7之前没有泛型。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.<? extends 类或者接口> 可以向下划定范围 \n', 'isCorrect': '-1'}, {'optionContent': 'C.<? super 类或者接口> 可以向上划定范围 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在编译的时候，泛型会被指定的类型替代，称之为泛型的擦除。 \n', 'isCorrect': '-1'}]","【答案解析】泛型属于jdk1.5新特性
","【正确答案】A
"
"
4、
下列说法正确的是()
TreeSet可以对任意对象进行排序 
","[{'optionContent': 'A.compartor方法指定了集合的排序规则 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Iterator实例化的对象是迭代器对象 \n', 'isCorrect': '-1'}, {'optionContent': 'C.\n', 'isCorrect': '-1'}, {'optionContent': 'D.iterator方法的返回值是迭代器对象 \n', 'isCorrect': '-1'}]","【答案解析】Comparator是接口，重写里面的compare方法才是指定排序规则。Iterator是接口没有对象。TreeSet只能排序类实现Comparable接口的对象
","【正确答案】D
"
"
5、
对于Java中的集合类java.util.ArrayList，以下说法正确的是（）。
","[{'optionContent': 'A.这个集合中的元素是无序的 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过键来获取这个集合中的元素 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在对这个集合的元素执行遍历操作时，效率比较高 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过addFirst()方法，在列表的首部插入元素 \n', 'isCorrect': '-1'}]","【答案解析】Arraylist的底层依赖数组实现所以有序、没有键，addFirst是属于链表里的方法
","【正确答案】C
"
"
6、
下列关于集合的说法正确的是
","[{'optionContent': 'A.集合的顶级接口是Collections \n', 'isCorrect': '-1'}, {'optionContent': 'B.List中存储的元素的内存空间一定是连续的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Set中的元素是不可重复的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以利用Iterable对集合进行迭代遍历 \n', 'isCorrect': '-1'}]","【答案解析】集合顶级接口是Collection。LinkedList空间不连续。Iterable是接口
","【正确答案】C
"
"
7、
下列关于增强for循环说法不正确的是
","[{'optionContent': 'A.增强for循环只能遍历，不能修改 \n', 'isCorrect': '-1'}, {'optionContent': 'B.增强for循环底层是用迭代器实现的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.增强for循环不能遍历数组 \n', 'isCorrect': '-1'}, {'optionContent': 'D.增强for循环可以遍历集合 \n', 'isCorrect': '-1'}]","【答案解析】可以遍历数组
","【正确答案】C
"
"
8、
对于Set<String> set = new HashSet<>(32);扩容的次数为
","[{'optionContent': 'A.0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.3 \n', 'isCorrect': '-1'}, {'optionContent': 'E.4 \n', 'isCorrect': '-1'}]","【答案解析】可以指定初始容量，所以没有扩容
","【正确答案】A
"
"9
、
import java.util.*;

public class test1 {
	public static void main(String args[]) {
		Set<Short> s = new HashSet<Short>();
		for (Short i = 0; i < 100; i++) {
			s.add(i);
			s.remove(i - 1);
		}
		System.out.println(s.size());
	}
}
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.100 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Throws Exception. \n', 'isCorrect': '-1'}, {'optionContent': 'D.None of the Above \n', 'isCorrect': '-1'}]","【答案解析】由于Set集合存储的元素类型时Short类型那么删除的时候也只能根据Short类型进行删除，当执行i-1时会默认变成int类型，所以类型不一致就不能删除
","【正确答案】B
"
"
10、
ArrayList list = new ArrayList(20);中的list扩充几次？
","[{'optionContent': 'A.0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.3 \n', 'isCorrect': '-1'}]","【答案解析】可以指定Arraylist初始容量，所以没有扩容
","【正确答案】A
"
"
多选题 （共计 2 题，总计 4分）
11、
下列关于集合的说法正确的是
","[{'optionContent': 'A.集合的顶级接口是Collections \n', 'isCorrect': '-1'}, {'optionContent': 'B.List中存储的元素的内存空间一定是连续的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Set中的元素是不可重复的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以利用Iterable对集合进行迭代遍历 \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C
"
"
12、
下列关于数组和集合之间的区别说法正确的是
","[{'optionContent': 'A.求集合和数组的大小是用size方法。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.集合大小是不固定的，数组的大小是固定的。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.集合只能存储基本类型数据和引用类型数据。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.数组一旦定义，那么此数组就只能存储定义的数据类型元素。 \n', 'isCorrect': '-1'}]","【答案解析】数组长度是调用length。集合不能存储基本类型数据
","【正确答案】B,D
"
"
13、
下列选项中关于Java中ArrayList、LinkedList、HashMap三个类的描述错误的是？
","[{'optionContent': 'A.ArrayList和LinkedList均实现了List接口 \n', 'isCorrect': '-1'}, {'optionContent': 'B.ArrayList的访问速度比LinkedList快 \n', 'isCorrect': '-1'}, {'optionContent': 'C.添加和删除元素时，ArrayList的表现更佳 \n', 'isCorrect': '-1'}, {'optionContent': 'D.HashMap实现Map接口，它允许任何类型的键和值对象，允许将null用作键或值 \n', 'isCorrect': '-1'}]","【答案解析】LinkedList底层依赖节点来实现的数据存储的，所以增删更快
","【正确答案】C
"
"


包装类与异常
1、
以下运行结果正确的是 
public static int func (){
 try{ return 1; 
}catch (Exception e){
 return 2; 
}finally{ 
return 3;
 }
 }
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译报错 \n', 'isCorrect': '-1'}]","【答案解析】无论try块或者catch块里是否执行，finally一定执行，就会执行到return语句返回3
","【正确答案】C
"
"
2、
package test;

import java.math.BigInteger;

public class Test5 {
	public static void main(String[] args) {
		BigInteger sum = new BigInteger(""0"");
		BigInteger one = new BigInteger(""1"");
		BigInteger two = new BigInteger(""2"");
		sum.add(one);
		sum.add(two);
		System.out.println(sum + sum.toString());
	}
}
","[{'optionContent': 'A.33 \n', 'isCorrect': '-1'}, {'optionContent': 'B.00 \n', 'isCorrect': '-1'}, {'optionContent': 'C.6 \n', 'isCorrect': '-1'}, {'optionContent': 'D.0 \n', 'isCorrect': '-1'}]","【答案解析】BigInteger类里的add方法执行完之后返回新的Big Integer对象，此时没有影响原sum对象的值，所有还是0，最后拼接之后的结果就是00
","【正确答案】B
"
"
3、
对于代码: public class Test {
	public static void main(String[] args) {
		Person p = new Person();
		p.name = ""Sam"";
		p.age = 16;
		m(p);
		System.out.println(p);
	}

	public static Person m(Person p) {
		try {
			p.name = ""Amy"";
			p.age = 18;
			throw new NullPointerException();
		} catch (Exception e) {
			p.name = ""Tom"";
			p.age = 20;
			return p;
		} finally {
			p = new Person();
			p.name = ""Jack"";
			p.age = 22;
		}
	}
}

class Person {
	String name;
	int age;

	@Override
	public String toString() {
		return ""Person [name = "" + name + "", age = "" + age + ""]"";
	}
}的输出结果是
","[{'optionContent': 'A.Person[name = Sam, age = 16] \n', 'isCorrect': '-1'}, {'optionContent': 'B.Person[name = Amy, age = 18] \n', 'isCorrect': '-1'}, {'optionContent': 'C.Person[name = Tom, age = 20] \n', 'isCorrect': '-1'}, {'optionContent': 'D.Person[name = Jack, age = 22] \n', 'isCorrect': '-1'}]","【答案解析】执行try块里内容抛出异常被catch块捕获此时执行到return语句，检测到有finally块需要把p的地址值进行挂起，执行finally块里内容，这个里内容执行完没有影响原p对象的内容，所以最后返回时还是返回的catch块里的对象以及属性值
","【正确答案】C
"
"4
、
今天是2015年6月12日，以下能将今天日期格式化为2015-06-12字串的日期格式化对象是
","[{'optionContent': 'A.new SimpleDateFormat(""yyyy-mm-dd"") \n', 'isCorrect': '-1'}, {'optionContent': 'B.new SimpleDateFormat(""yyyy-mm-DD"") \n', 'isCorrect': '-1'}, {'optionContent': 'C.new SimpleDateFormat(""yyyy-MM-DD"") \n', 'isCorrect': '-1'}, {'optionContent': 'D.new SimpleDateFormat(""yyyy-MM-dd"") \n', 'isCorrect': '-1'}]","【答案解析】y代表年份，M代表月份，d代表一个月中的日某一日
","【正确答案】D
"
"5
、
下列输出结果是 System.out.println(Byte.MAX_VALUE+1)
","[{'optionContent': 'A.128 \n', 'isCorrect': '-1'}, {'optionContent': 'B.-128 \n', 'isCorrect': '-1'}, {'optionContent': 'C.-127 \n', 'isCorrect': '-1'}, {'optionContent': 'D.报错 \n', 'isCorrect': '-1'}]","【答案解析】包装类Byte调用Max_Value属性是获取Byte类型最大值就127
","【正确答案】A
"
"
6、
以下表达式值为true的是
","[{'optionContent': 'A.“123”equals(123) \n', 'isCorrect': '-1'}, {'optionContent': 'B.new Integer(123)==123 \n', 'isCorrect': '-1'}, {'optionContent': 'C.new Integer(3250)==new Integer(3250) \n', 'isCorrect': '-1'}, {'optionContent': 'D.new String(“abc”)==“abc“ \n', 'isCorrect': '-1'}]","【答案解析】B选项有共享区域，在区域内就是共享结果为true，不在就返回false。B在范围之内，C出范围
","【正确答案】B
"
"7
、
下列代码的运行结果是 public static void func() { try { throw new Exception(); } finally { System.out.println(""B""); } } public static void main(String[] args) { try { func(); System.out.println(""A""); } catch (Exception e) { System.out.println(""C""); } System.out.println(""D""); }
","[{'optionContent': 'A.BACD \n', 'isCorrect': '-1'}, {'optionContent': 'B.BAD \n', 'isCorrect': '-1'}, {'optionContent': 'C.ACD \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译失败 \n', 'isCorrect': '-1'}]","【答案解析】抛出的异常没有捕获
","【正确答案】D
"
"
8、
public class T11 { public static void main(String[] args) { try { System.out.println(“main1”); ma(); System.out.println(“main2”); } catch(Exception e) { System.out.println(“Catch Exception in main”); System.out.println(e.getMessage()); } } public static void ma() throws IOException { try { System.out.println(“ma1”); mb(); System.out.println(“ma2”); } catch (SQLException e) { System.out.println(“Catch SQLException in ma”); throw new IOException(e.getMessage()); } } public static void mb() throws SQLException { throw new SQLException(“SQLException in mb”); } } 输出结果是
","[{'optionContent': 'A.main1, Catch Exception in main, ma1, Catch SQLException in ma, SQLException in mb \n', 'isCorrect': '-1'}, {'optionContent': 'B.main1, Catch Exception in main, main2, ma1, Catch SQLException in ma, ma2, SQLException in mb \n', 'isCorrect': '-1'}, {'optionContent': 'C.main1, ma1, Catch SQLException in ma, Catch Exception in main, SQLException in mb \n', 'isCorrect': '-1'}, {'optionContent': 'D.main1, main2, ma1, ma2, SQLException in mb \n', 'isCorrect': '-1'}, {'optionContent': 'E.main1, Catch Exception in main, ma1, ma2 \n', 'isCorrect': '-1'}]","【答案解析】先执行main方法里try块里内容输出main1，接着执行ma方法执行方法里的try块输出ma1，接着执行mb方法抛出异常以及异常信息，被ma方法里的catch块捕获输出Catch SQLException in ma以及把捕获到的mb方法中的异常继续抛出被main方法里的catch捕获输出Catch Exception in main接着输出了ma方法抛出的之前捕获mb里的异常信息最后输出SqlException in mb
","【正确答案】C
"
"
9、
public class TestLlan {
	static int test() {
		int x = 1;
		try {
			return x;
		} finally {
			++x;
		}
	}

	public static void main(String[] args) throws FileNotFoundException {
		System.out.println(TestLlan.test());
	}
}
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译异常 \n', 'isCorrect': '-1'}, {'optionContent': 'D.运行异常 \n', 'isCorrect': '-1'}]","【答案解析】finally块里内容一定会执行而且需要执行完毕，所有return 1一定能完整的执行结束就会把1的值进行返回
","【正确答案】A
"
"
10、
下面的方法将返回？
public static int func() {
		int i = 2;
		try {
			return i++;
		} catch (Exception e) {
			return i++;
		} finally {
			i++;
		}
	}
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译错误 \n', 'isCorrect': '-1'}]","【答案解析】try块里在执行return 2时发现有finally就会把值和状态都要挂起，所以执行完finally接着执行挂起的内容所以最后返回2
","【正确答案】B
"
"
多选题 （共计 3 题，总计 6分）
11、
java异常描述错误的是
","[{'optionContent': 'A.抛出异常意味着发生了运行时错误，需要调试修改 \n', 'isCorrect': '-1'}, {'optionContent': 'B.如果try块没有出现异常，则finally块里的内容不会执行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.java中的运行时异常，可能来自RuntimeException类及其子类 \n', 'isCorrect': '-1'}, {'optionContent': 'D.用throws定义了方法可能抛出异常，那么调用此方法一定会抛出异常 \n', 'isCorrect': '-1'}]","【答案解析】抛出异常有可能是编译时异常。无论try里有无异常都要执行finnaly。如果抛出的是运行时异常就可能不抛出
","【正确答案】A,B,D
"
"
12、
下列各项中，能够正确编译（不考虑运行）的是
","[{'optionContent': 'A.Integer i = new Integer(“0x123”) \n', 'isCorrect': '-1'}, {'optionContent': 'B.Double d = new Double(5) \n', 'isCorrect': '-1'}, {'optionContent': 'C.Boolean b = new Boolean(“tRue”) \n', 'isCorrect': '-1'}, {'optionContent': 'D.Boolean b = new Boolean(“abc”) \n', 'isCorrect': '-1'}]","【答案解析】编译都不会报错都是通过字符串去构建包装类对象
","【正确答案】A,B,C,D
"
"
13、
下列各项中可以正确编译运行的是
","[{'optionContent': 'A.Integer i = new Integer(""017""); \n', 'isCorrect': '-1'}, {'optionContent': 'B.Long l = 35; \n', 'isCorrect': '-1'}, {'optionContent': 'C.Byte b = new Byte(127); \n', 'isCorrect': '-1'}, {'optionContent': ""D.Float f = 'a'; \n"", 'isCorrect': '-1'}, {'optionContent': 'E.Boolean b = new Boolean(null); \n', 'isCorrect': '-1'}]","【答案解析】BD选项是属于自动封箱，在进行自动封箱时需要保证基本类型数据只能直接封箱为对应类型包装类。C是属于封箱但是也是范围不一致
","【正确答案】A,E
"
"
14、
对于代码： public class Text { public static void main(String[] args) { System.out.println(m()); } public static Person m() { Person p = new Person(); try { p.setName(""Amy""); p.setAge(15); return p; } catch (Exception e) { p.setName(""Sam""); p.setAge(12); return p; } finally { p.setName(""Tom""); p.setAge(13); throw new NullPointerException(); } } } class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return name + "" "" + age; } }
","[{'optionContent': 'A.Amy 15 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Sam 12 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Tom 13 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译错误 \n', 'isCorrect': '-1'}, {'optionContent': 'E.运行错误 \n', 'isCorrect': '-1'}]","【答案解析】finally是在try以及catch的后面执行而且必须执行，当在finally里抛出异常就没有catch能够捕获
","【正确答案】E（D）
"
"
15、
关于异常处理机制的叙述正确的是
","[{'optionContent': 'A.catch部分捕捉到异常情况时，才会执行finally部分 \n', 'isCorrect': '-1'}, {'optionContent': 'B.当try区段的程序发生异常时，才会执行finally部分 \n', 'isCorrect': '-1'}, {'optionContent': 'C.当try区段不论程序是否发生错误及捕获到异常情况，都会执行finally \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都是 \n', 'isCorrect': '-1'}]","【答案解析】Finally块里内容是一定会执行的
","【正确答案】C
"
"
16、
对于下列代码，结果正确的是：public class Text {
	public static void main(String[] args) {
		System.out.println(m());
	}

	@SuppressWarnings(""finally"")
	public static Person m() {
		Person p = new Person();
		try {
			p.setName(""Amy"");
			p.setAge(15);
		} catch (Exception e) {
			p.setName(""Sam"");
			p.setAge(12);
			return p;
		} finally {
			p = new Person();
			p.setName(""Tom"");
			p.setAge(13);
		}
	}
}

class Person {
	private String name;
	private int age;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return name + "" "" + age;
	}
}
","[{'optionContent': 'A.Tom  13 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Sam  12 \n', 'isCorrect': '-1'}, {'optionContent': 'C.运行错误 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译错误 \n', 'isCorrect': '-1'}]","【答案解析】方法需要返回值，但是try块以及finally块里都没有return，如果try块没有异常那就不会·走catch块里，就有可能没有返回值
","【正确答案】D
"
"
String
1、
对于代码： public class Test { public static void main(String[] args) { String str = new String(""abc""); twice(str); System.out.println(str); } pubilc static String twice(String str) { return str += new StringBuilder(str).reverse(); } } 的运行结果是：
","[{'optionContent': 'A.abc \n', 'isCorrect': '-1'}, {'optionContent': 'B.abcabc \n', 'isCorrect': '-1'}, {'optionContent': 'C.cba \n', 'isCorrect': '-1'}, {'optionContent': 'D.abccba \n', 'isCorrect': '-1'}, {'optionContent': 'E.cbaabc \n', 'isCorrect': '-1'}]","【答案解析】实参是引用数据类型传递的是地址值的拷贝，所以方法执行完之后不会原结果
","【正确答案】A
"
"
2、
指出下列程序运行的结果（）interface InterfaceA {
	int MAX = 10;
}

class ClassA implements InterfaceA {
	int a = 1;
}

class ClassB extends ClassA {
	int b = 2;
}

public class E {
	public static void main(String[] args) {
		ClassB b = new ClassB();
		System.out.print(b.MAX);
		System.out.print("" "" + ClassB.MAX);
		System.out.print("" "" + ClassA.MAX);
		System.out.print("" "" + InterfaceA.MAX);
	}
}
","[{'optionContent': 'A.good and abc \n', 'isCorrect': '-1'}, {'optionContent': 'B.good and gbc \n', 'isCorrect': '-1'}, {'optionContent': 'C.test ok and abc \n', 'isCorrect': '-1'}, {'optionContent': 'D.test ok and gbc \n', 'isCorrect': '-1'}]","【答案解析】字符串本身就是对象所以str传值过去就被地址值覆盖了，所以没有改变原值。字符数组把地址值传递过去改变了原数组中第一个元素值为g
","【正确答案】B
"
"
3、
关于下面的程序，哪一个选项是正确的输出结果（） 
public static void main (String[] args) { 
String classFile = ""com.jd."". replaceAll(""."", ""/"") + ""MyClass.class""; 
System.out.println(classFile); 
}
","[{'optionContent': 'A.com. jd \n', 'isCorrect': '-1'}, {'optionContent': 'B.com/jd/MyClass.class \n', 'isCorrect': '-1'}, {'optionContent': 'C.///////MyClass.class \n', 'isCorrect': '-1'}, {'optionContent': 'D.com.jd.MyClass \n', 'isCorrect': '-1'}]","【答案解析】在正则语法中.代表任意字符，replaceAll方法相当于可以匹配所有字符进行替换成/,所以MyClass.class之前都是/
","【正确答案】C
"
"
4、
String s = ""a""; s = s + ""b""; 上述代码运行过程中共产生了几个对象？ （）
","[{'optionContent': 'A.3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.4 \n', 'isCorrect': '-1'}, {'optionContent': 'C.5 \n', 'isCorrect': '-1'}, {'optionContent': 'D.6 \n', 'isCorrect': '-1'}]","【答案解析】“a”是一个对象。S=s+”b”是根据new StringBuilder(“a”).append(“b”).toString()。这句话一共产生了4个对象
","【正确答案】C
"
"
5、
String s = ""hello""；String t = ""hello""；char c [ ] = {'h','e','l','l','o'}；下列选项中返回false的语句是？
","[{'optionContent': 'A.s==t \n', 'isCorrect': '-1'}, {'optionContent': 'B.s.equals(t); \n', 'isCorrect': '-1'}, {'optionContent': 'C.s.equals(String.valueOf(c)) \n', 'isCorrect': '-1'}, {'optionContent': 'D.t.equals(c) \n', 'isCorrect': '-1'}]","【答案解析】字符串对象比较是一位一位比较，但是c不是String类型
","【正确答案】D
"
"
6、
下面代码的运行结果为：（） public class foo{ public static void main (String[] args){ String s; System.out.println(""s="" + s); } }
","[{'optionContent': 'A.代码得到编译，并输出“s=” \n', 'isCorrect': '-1'}, {'optionContent': 'B.代码得到编译，并输出“s=null” \n', 'isCorrect': '-1'}, {'optionContent': 'C.由于String s没有初始化，代码不能编译通过 \n', 'isCorrect': '-1'}, {'optionContent': 'D.代码得到编译，但捕获到 NullPointException异常 \n', 'isCorrect': '-1'}]","【答案解析】字符串对象需要进行初始化才能操作
","【正确答案】C
"
"
多选题 （共计 3 题，总计 6分）
7、
下列说法正确的是
","[{'optionContent': 'A.StringBuilder是线程安全的，因此效率较低 \n', 'isCorrect': '-1'}, {'optionContent': 'B.StringBuffer是线程安全的，因此效率较低 \n', 'isCorrect': '-1'}, {'optionContent': 'C.String中的“+”拼接运算默认调用的是StringBuilder中的append方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.String中的“+”拼接运算默认调用的是StringBuffer中的append方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.StringBuilder和StringBuffer继承了String类 \n', 'isCorrect': '-1'}]","【答案解析】StringBuider、Stringbuffer、String都是最终类不能被继承
","【正确答案】B,C
"
"
8、
以下关于String描述正确的是
","[{'optionContent': 'A.String 不可变 \n', 'isCorrect': '-1'}, {'optionContent': 'B.StringBuilder是非线程安全的 \n', 'isCorrect': '-1'}, {'optionContent': 'C.StringBuffer是线程安全的 \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上都不对 \n', 'isCorrect': '-1'}]","【答案解析】字符串底层根据不可改变的字符数组实现的所以字符串也无法改变
","【正确答案】A,B,C
"
"
9、
下列判断结果为true的是（）
","[{'optionContent': 'A.String str1=new String(""abc""); String str2=new String(""abc""); str1==str2; \n', 'isCorrect': '-1'}, {'optionContent': 'B.String str1=""abc""; String str2=""abc""; str1==str2; \n', 'isCorrect': '-1'}, {'optionContent': 'C.Integer i1=127; Integer i2=127; i1==i2; \n', 'isCorrect': '-1'}, {'optionContent': 'D.String str1=""a""; String str2=""b""; str2+=str1; String str3=""ab""; str2==str3 \n', 'isCorrect': '-1'}]","【答案解析】字符串会共享对象，B选项两个引用指向同一个区域。C选项的整数值包装类进行自动封箱时会存在共享区域
","【正确答案】B,C
"
"


Object与string
1、
对于已经不被任何变量引用的对象，当垃圾回收器准备对回收该对象所占用的内存时，将调用该对象的哪个方法
","[{'optionContent': 'A.gc \n', 'isCorrect': '-1'}, {'optionContent': 'B.finalize \n', 'isCorrect': '-1'}, {'optionContent': 'C.notify \n', 'isCorrect': '-1'}, {'optionContent': 'D.hashCode \n', 'isCorrect': '-1'}]","【答案解析】finalize方法定义在Object类中所以可以被对象调用
","【正确答案】B
"
"
2、
JAVA语言的下面几种数组复制方法中，哪个效率最高？
","[{'optionContent': 'A.使用clone方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.for循环逐一复制 \n', 'isCorrect': '-1'}, {'optionContent': 'C.System.arraycopy \n', 'isCorrect': '-1'}, {'optionContent': 'D.Arrays.copyOf \n', 'isCorrect': '-1'}]","【答案解析】C选项的执行是最接近底层计算过程
","【正确答案】C
"
"多选题 （共计 0 题，总计 0分）





接口与内部类
1、
以下类或者接口定义中正确的是？
","[{'optionContent': 'A.public class A { private int x; public int getX() { return x; } } \n', 'isCorrect': '-1'}, {'optionContent': 'B.public abstract class A { private int x; public abstract int getX() { return x; } public abstract int aMethod(); } \n', 'isCorrect': '-1'}, {'optionContent': 'C.public class a { private int x; public abstract int getX(); } \n', 'isCorrect': '-1'}, {'optionContent': 'D.public interface interfaceA { private int x; public int getX() { return x; } } \n', 'isCorrect': '-1'}]","【答案解析】抽象方法不能含有方法体。抽象方法所在的类一定是抽象类。接口中的方法默认是抽象方法不能有方法体。
","【正确答案】A
"
"
2、
下列程序运行的结果是（ ）。interface B {
	void f();
}

class C implements B {
	public void f() {
		System.out.print(""good "");
	}

	public void g(B b) {
		b.f();
	}
}

class A implements B {
	public void f() {
		System.out.print(""bad "");
	}

	public void g(B b) {
		b.f();
	}

	public static void main(String[] args) {
		B b1 = new A();
		B b2 = new C();
		b1.f();
		b2.f();
	}
}
","[{'optionContent': 'A.编译错误 \n', 'isCorrect': '-1'}, {'optionContent': 'B.执行错误 \n', 'isCorrect': '-1'}, {'optionContent': 'C.good bad \n', 'isCorrect': '-1'}, {'optionContent': 'D.bad good \n', 'isCorrect': '-1'}]","【答案解析】b1和b2对象都是向上造型创建的对象，所以方法的执行看子类，故执行都是子类的重写方法
","【正确答案】D
"
"
3、
Java的核心包中，提供编程应用的基本类的是
","[{'optionContent': 'A.java.util \n', 'isCorrect': '-1'}, {'optionContent': 'B.java.lang \n', 'isCorrect': '-1'}, {'optionContent': 'C.java.io \n', 'isCorrect': '-1'}, {'optionContent': 'D.java.awt \n', 'isCorrect': '-1'}, {'optionContent': 'E.java.applet \n', 'isCorrect': '-1'}]","【答案解析】Java.lang包是存放中java的核心类库的内容
","【正确答案】B
"
"
4、
以下说法正确的是
","[{'optionContent': 'A.外部类前面可以修饰public,protected和private \n', 'isCorrect': '-1'}, {'optionContent': 'B.成员内部类前面可以修饰public,protected和private \n', 'isCorrect': '-1'}, {'optionContent': 'C.方法内部类前面可以修饰public,protected和private \n', 'isCorrect': '-1'}, {'optionContent': 'D.以上说法都不正确 \n', 'isCorrect': '-1'}]","【答案解析】外部类就是普通类只能被默认和public修饰。方法内部类不能被访问权限修饰符修饰
","【正确答案】B
"
"
5、
下列程序运行的结果是（ ）。interface InterfaceA {
	int MAX = 10;
}

class ClassA implements InterfaceA {
	int a = 1;
}

class ClassB extends ClassA {
	int b = 2;
}

public class E {
	public static void main(String[] args) {
		ClassB b = new ClassB();
		System.out.print(b.MAX);
		System.out.print("" "" + ClassB.MAX);
		System.out.print("" "" + ClassA.MAX);
		System.out.print("" "" + InterfaceA.MAX);
	}
}
","[{'optionContent': 'A.编译错误：MAX在类ClassB没有定义 \n', 'isCorrect': '-1'}, {'optionContent': 'B.编译错误：MAX不能通过对象名b来访问 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译错误：MAX不能通过接口名InterfaceA来访问 \n', 'isCorrect': '-1'}, {'optionContent': 'D.10 10 10 10 \n', 'isCorrect': '-1'}]","【答案解析】接口中的属性默认是被public、static、final共同修饰，而且A是接口实现类，B是A的子类，所以A类或者B类都可以直接类名点调用接口属性
","【正确答案】D
"
"
多选题 （共计 6 题，总计 12分）
6、
下面关于包的说法正确的是
","[{'optionContent': 'A.可以用import关键字导入包 \n', 'isCorrect': '-1'}, {'optionContent': 'B.不同的包中可以出现类名相同的类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Java中可以使用package语句导入包 \n', 'isCorrect': '-1'}, {'optionContent': 'D.导入包时可以出现*这个符号 \n', 'isCorrect': '-1'}]","【答案解析】package是声明包
","【正确答案】A,B,D
"
"
7、
在下列代码的//insert code here 处，加上下列哪行代码运行时会抛出java.lang.ClassCastException? interface foo {
}

class Alpha implements foo {
}

class Beta extends Alpha {
}
pulic class Delta extends Beta {
	public static void main(String[] args){ 
		Beta x = new Beta();
     //insert code here
		}
}
","[{'optionContent': 'A.Alpha a = x; \n', 'isCorrect': '-1'}, {'optionContent': 'B.foo f = (Delta) x; \n', 'isCorrect': '-1'}, {'optionContent': 'C.foo f = (Alpha) x \n', 'isCorrect': '-1'}, {'optionContent': 'D.Beta b = (Beta)(Alpha)x; \n', 'isCorrect': '-1'}, {'optionContent': 'E.Delta d = (Delta)(Alpha)x; \n', 'isCorrect': '-1'}]","【答案解析】如果进行和接口进行值的转换只要对象类型和接口不是实现类关系就会报错。如果要和类进行值的转换先要保证两个对象之间有继承关系这个能保证编译没错，再保证两个对象的实际创建类不是同一个运行就会报错。
","【正确答案】B,E
"
"
8、
（内部类）Java 中的内部类包括
","[{'optionContent': 'A.成员内部类 \n', 'isCorrect': '-1'}, {'optionContent': 'B.静态内部类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.公开内部类 \n', 'isCorrect': '-1'}, {'optionContent': 'D.抽象内部类 \n', 'isCorrect': '-1'}, {'optionContent': 'E.局部内部类 \n', 'isCorrect': '-1'}]","【答案解析】内部类包括：局部内部类、成员内部类、静态内部类、匿名内部类
","【正确答案】A,B,E
"
"
9、
关于代码public class Demo {
	int value;

	public static void main(String[] args) {
		Animal a = new Dog(); // 1
	}
}

interface tiger {
}

class Animal {
}

class Dog extends Animal {
}

class Cat extends Animal{}}}可以填在1处编译没错运行有错的选项是？
","[{'optionContent': 'A.Dog d=(Dog)a; \n', 'isCorrect': '-1'}, {'optionContent': 'B.Cat c=(Cat)a; \n', 'isCorrect': '-1'}, {'optionContent': 'C.Animal e=(Animal)a; \n', 'isCorrect': '-1'}, {'optionContent': 'D.tiger t=(tiger)a; \n', 'isCorrect': '-1'}]","【答案解析】给类传值时要求运行有错就是检测实际创建类不是一个。给接口传值运行报错不是实现类就行
","【正确答案】B,C,D
"
"
10、
下面关于jdk8的新特性说法正确的是
","[{'optionContent': 'A.jdk8开始，接口中允许定义实体方法。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.jdk8开始，switch 语句可以用字符串 \n', 'isCorrect': '-1'}, {'optionContent': 'C.jdk8开始，支持Lambda表达式 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Lambda表达式中，当方法体只有一句话时，可以省略return语句。 \n', 'isCorrect': '-1'}]","【答案解析】从jdk1.7开始switch表达式支持String类型
","【正确答案】A,C,D
"
"
11、
下列关于Lambda表达式说法正确的是
","[{'optionContent': 'A.当一个接口中有多个抽象方法的时候，可以通过Lambda表达式来重写其中的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过::来传递Arrays.sort() \n', 'isCorrect': '-1'}, {'optionContent': 'C.由于Lambda表达式是表示重写某个抽象方法，因此参数列表不可省略 \n', 'isCorrect': '-1'}, {'optionContent': 'D.当Lambda表达式的函数体只有一句的时候，可以省略return不写 \n', 'isCorrect': '-1'}]","【答案解析】接口中只有一个抽象方法时才能使用Lambda表达式。::可以传递静态方法。只有一个参数而且全局只操作这一个参数时可以省略。只有一句时可以省略
","【正确答案】B,D
"
"



static与final
1、
关于以下程序的说明，正确的是（） 1．  class   StaticStuff 2．	{ 3．	static  int  x=10； 4．	static  { x+=5；} 5．     public  static  void  main（String  args[ ]） 6．	{           7．              System.out.println(""x="" + x); 8．     } 9．     static  { x/=3;} 10.  }
","[{'optionContent': 'A.4行与9行不能通过编译，因为缺少方法名和返回类型 \n', 'isCorrect': '-1'}, {'optionContent': 'B.9行不能通过编译，因为只能有一个静态初始化器 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译通过，执行结果为：x=5 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译通过，执行结果为：x=3 \n', 'isCorrect': '-1'}]","【答案解析】按照静态信息出现先后顺序依次进行加载执行，先加载静态属性为10，在执行静态代码块加5为15，最后再执行一个静态代码块进行除3最后结果为5
","【正确答案】C
"
"
2、
关于final关键字，下面说法正确的是？
","[{'optionContent': 'A.final关键字如果用于修饰成员变量，那么该成员变量必须初始化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.final关键字修饰的类只能被继承一次 \n', 'isCorrect': '-1'}, {'optionContent': 'C.final关键字修饰的方法可以被重写 \n', 'isCorrect': '-1'}, {'optionContent': 'D.final关键字如果用于修饰方法，该方法所在的类不能被继承 \n', 'isCorrect': '-1'}]","【答案解析】final修饰的方法不能被重写不会影响所在的类。修饰类时不能被继承
","【正确答案】A
"
"3
、
关于抽象类的说法正确的是
","[{'optionContent': 'A.抽象类中一定包含抽象方法，否则是出现编译错误 \n', 'isCorrect': '-1'}, {'optionContent': 'B.包含抽象方法的类一定是抽象类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.抽象方法可以没有方法体，也可以有方法体 \n', 'isCorrect': '-1'}, {'optionContent': 'D.抽象类的子类一定不是抽象类 \n', 'isCorrect': '-1'}]","【答案解析】含有抽象方法的类一定是抽象类，抽象类不一定含有抽象方法。抽象方法一定不含方法体。抽象类的子类不一定是抽象类
","【正确答案】B
"
"
4、
下列代码的运行结果正确的是 public class Test_Syk_2 { public static void main(String[] as){ new Son(); } } class Father{ int num; Father() { System.out.println(""S""+(++this.num)); } { System.out.println(""G""+num); } static{ System.out.println(""H""); } } class Son extends Father{ private int num=7; Son() { System.out.println(""A""+(--super.num)); } { System.out.println(""D""+num); } static{ System.out.println(""F""); } }
","[{'optionContent': 'A.H F G0 S1 D6 A1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.H F G0 S0 D7 A1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.H F G1 S0 D7 A1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.H F G0 S1 D7 A0 \n', 'isCorrect': '-1'}]","【答案解析】当创建子类对象时整个程序的执行过程是先加载父类静态信息以及子类静态信息，再执行父类对象级别信息以及子类对象级别信息。父类静态信息只有静态代码块输出H，子类静态信息只有静态代码块输出F。执行父类对象级别信息先执行父类构造代码块输出G0，再执行构造方法输出S1。执行子类对象级别信息先执行构造代码块输出D7，执行构造代码块输出A0
","【正确答案】D
"
"
5、
下列的运行结果为( ) 
public class StaticExam {
	public static void main(String[] args) {
		System.out.println(SEDemo.i);
		System.out.println(new SEDemo().j);
	}
}

class SEDemo {
	public static int i = 6;
	public static SEDemo s = new SEDemo();
	public int j;

	public SEDemo() {
		i--;
		j--;
	}
}
","[{'optionContent': 'A.6，0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.6，-1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.5，0 \n', 'isCorrect': '-1'}, {'optionContent': 'D.5，-1 \n', 'isCorrect': '-1'}]","【答案解析】当SEDemo.i时，需要加载整个类，类的静态信息也需要加载，静态属性i赋值为6，静态属性s也需要进行赋值就需要创建本类对象一次所以需要去执行构造方法i--为5。当new SEDemo().j时静态信息以及加载完成直接执行属性j初始值为0，再去调用构造方法j--为-1
","【正确答案】D
"
"6
、
对于代码： class TestA {
	public static void ma() {
		System.out.println(""A ma"");
	}

	public static void mb() {
		System.out.println(""A mb"");
	}
}

class TestB extends TestA {
	public void ma() {
		System.out.println(""B ma"");
	}

	public void mb() {
		System.out.println(""B mb"");
	}
}

public class Test {
	public static void main(String[] args) {
		TestA a = new TestB();
		a.ma();
		a.mb();
	}
}运行结果是：
","[{'optionContent': 'A.A ma A mb \n', 'isCorrect': '-1'}, {'optionContent': 'B.A ma B mb \n', 'isCorrect': '-1'}, {'optionContent': 'C.B ma A mb \n', 'isCorrect': '-1'}, {'optionContent': 'D.B ma B mb \n', 'isCorrect': '-1'}, {'optionContent': 'E.编译错误 \n', 'isCorrect': '-1'}]","【答案解析】当父类类中出现了方法签名一致的方法，要么都是静态要么都是非静态
","【正确答案】E
"
"
7、
子类A继承了父类B，A a=new A();则①父类B静态代码块②父类B非静态代码块③父类B构造函数④子类A静态代码 ⑤子类A非静态代码块⑥子类A的构造函数 的执行顺序是
","[{'optionContent': 'A.①②③④⑤⑥ \n', 'isCorrect': '-1'}, {'optionContent': 'B.①④②③⑤⑥ \n', 'isCorrect': '-1'}, {'optionContent': 'C.①②④⑤③⑥ \n', 'isCorrect': '-1'}, {'optionContent': 'D.④⑤①②③⑥ \n', 'isCorrect': '-1'}, {'optionContent': 'E.④⑤⑥①②③ \n', 'isCorrect': '-1'}]","【答案解析】先执行父类静态信息再执行子类静态信息，接着执行父类对象级别信息再执行子类对象级别信息
","【正确答案】B
"
"
8、
给出如下代码 :	class Test{ private int m; public static void fun() { // some code... } } 如何使成员变量 m 被函数 fun() 直接访问 ?
","[{'optionContent': 'A.将 private int m 改为 protected int m \n', 'isCorrect': '-1'}, {'optionContent': 'B.将 private int m 改为 public int m \n', 'isCorrect': '-1'}, {'optionContent': 'C.将 private int m 改为 static int m \n', 'isCorrect': '-1'}, {'optionContent': 'D.将 private int m 改为 int m \n', 'isCorrect': '-1'}]","【答案解析】静态信息只能直接调用静态信息
","【正确答案】C
"
"
9、
关于下列代码说法正确的是？ 
byte b1 = 1, b2 = 2, b3, b6;
		final byte b4 = 4, b5 = 6;
		b6 = b4 + b5;
		b3 = (b1 + b2);
		System.out.println(b3 + b6);
","[{'optionContent': 'A.运行期抛出异常 \n', 'isCorrect': '-1'}, {'optionContent': 'B.输出结果：13 \n', 'isCorrect': '-1'}, {'optionContent': 'C.语句：b6=b4+b5编译出错 \n', 'isCorrect': '-1'}, {'optionContent': 'D.语句：b3=b1+b2编译出错 \n', 'isCorrect': '-1'}]","【答案解析】b4和b5都是最终值，值一直都是byte类型值所以求和之后仍然还是byte类型值所以可以直接赋值给b6
","【正确答案】D
"
"
10、
对于代码： public class StaticExam { public static void main(String[] args) { System.out.println(new SE().i); System.out.println(SEDemo.i); System.out.println(SEDemo.j); } } class SEDemo{ public static SEDemo s=new SEDemo(); public static int i=0; public static int j; public SEDemo(){ i++; j++; } } class SE{ { i=5; } int i=1; } }输出结果依次为
","[{'optionContent': 'A.5,0,1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.5,1,1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.1,0,1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.1,1,1 \n', 'isCorrect': '-1'}]","【答案解析】笔记有详细解释
","【正确答案】C
"
"
多选题 （共计 4 题，总计 8分）
11、
对于内部类，下列各项中说法正确的是：
","[{'optionContent': 'A.方法内部类可以使用当前外部类中的成员变量 \n', 'isCorrect': '-1'}, {'optionContent': 'B.成员内部类可以使用当前外部类中的成员方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.静态内部类可以使用当前外部类中的成员方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.成员内部类中可以定义静态变量 \n', 'isCorrect': '-1'}, {'optionContent': 'E.java.lang.String可以用于声明一个匿名内部类 \n', 'isCorrect': '-1'}]","【答案解析】静态内部类只能使用外部类的静态方法。成员内部类不能定义静态信息。String类不能被继承所以没有匿名内部类形式。
","【正确答案】A,B
"
"
12、
下列关于静态方法中说法正确的是
","[{'optionContent': 'A.静态方法中不能直接调用非静态方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.静态方法不能通过实例调用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.静态方法能够用类名直接调用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以在不产生任何一个对象的情况下调用静态方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.静态方法里可以使用 this \n', 'isCorrect': '-1'}]","【答案解析】静态方法可以被对象调用。静态方法里不能使用this，级别不一致
","【正确答案】A,C,D
"
"
13、
下列修饰符在JDK1.8可以修饰类的是
","[{'optionContent': 'A.private \n', 'isCorrect': '-1'}, {'optionContent': 'B.static \n', 'isCorrect': '-1'}, {'optionContent': 'C.default \n', 'isCorrect': '-1'}, {'optionContent': 'D.abstract \n', 'isCorrect': '-1'}, {'optionContent': 'E.final \n', 'isCorrect': '-1'}]","【答案解析】private和default不能修饰类
","【正确答案】B,D,E
"
"
14、
对于代码 public class Text{ static void alpha(){/*more code here*/} void beta(){/*more code here*/} } 下列说法正确的是
","[{'optionContent': 'A.Text.beta()是正确的方法调用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.Text t=new Text();t.alpha();是正确的方法调用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.方法beta()内可以直接调用alpha()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.方法alpha()内可以直接调用beta()方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以在beta()方法内通过this关键字调用alpha()方法 \n', 'isCorrect': '-1'}]","【答案解析】非静态方法不能被类名直接调用。静态方法不能直接调用非静态方法
","【正确答案】B,C,E
"
"
15、
下列程序中出现了几处错误 abstract class A{ abstract void f(){}; public abstract void k(); } class B extends A{ @Override protected void f() { // TODO Auto-generated method stub } @Override void k() { // TODO Auto-generated method stub } public static void main(String[] args){ A a=new A(); a.f(); a.k(); } }
","[{'optionContent': 'A.1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.3 \n', 'isCorrect': '-1'}, {'optionContent': 'D.4 \n', 'isCorrect': '-1'}]","【答案解析】f()抽象方法不能有方法体。k()方法进行重写是修饰符需要是public。A类是抽象类没有对象
","【正确答案】C
"
"
16、
下列Java代码运行的结果是（）。public class Test {
	public static void main(String[] args) {
		Aoo o1 = new Aoo();
		Aoo o2 = new Aoo();
		o2.show();
	}
}

class Aoo {
	int x;
	static int y;

	public Aoo() {
		x++;
		y++;
	}

	public void show(){
		System.out.println(x+"",""+y); 
	}
}
","[{'optionContent': 'A.1,1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.1,2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.0,1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.0,2 \n', 'isCorrect': '-1'}]","【答案解析】每个对象的非静态属性都是独有的不相关所以x的值不累加。y是静态信息对于所有的对象都是共享的，所有在做创建对象时会进行累加
","【正确答案】B
"
"
17、关于final关键字，下面说法正确的是
","[{'optionContent': 'A.final关键字如果用于修饰成员变量，那么该成员变量必须在声明时初始化 \n', 'isCorrect': '-1'}, {'optionContent': 'B.final关键字修饰的类只能被继承一次 \n', 'isCorrect': '-1'}, {'optionContent': 'C.final 关键字修饰的方法不可以被重写 \n', 'isCorrect': '-1'}, {'optionContent': 'D.final 关键字如果用于修饰方法，该方法所在的类不能被继承 \n', 'isCorrect': '-1'}]","【答案解析】final修饰的成员变量在创建对象之前初始化就行。final修饰的类不能被继承。final修饰的方法不会影响类
","【正确答案】C
"
"
18、关于以下程序代码的说明正确的是（） class HasStatic { private static int x = 100; public static void main(String[] args) { HasStatic hs1 = new HasStatic(); hs1.x++;//第5行 HasStatic hs2 = new HasStatic(); hs2.x++; hs1 = new HasStatic(); hs1.x++; HasStatic.x--;//第10行 System.out.println(""x="" + x); } }
","[{'optionContent': 'A.5行不能通过编译，因为引用了私有静态变量 \n', 'isCorrect': '-1'}, {'optionContent': 'B.10行不能通过编译，因为x是私有静态变量 \n', 'isCorrect': '-1'}, {'optionContent': 'C.程序通过编译，输出结果为：x=103 \n', 'isCorrect': '-1'}, {'optionContent': 'D.程序通过编译，输出结果为：x=102 \n', 'isCorrect': '-1'}]","【答案解析】在同类中可以使用私有静态变量。静态变量对所有对象共享，所以相当于加3减1，最后结果为102
","【正确答案】D
"
"







面向对象特征
1、
下列选项中关于 java 中 super 关键字的说法错误的是。
","[{'optionContent': 'A.super 关键字是在子类对象内部指代其父类对象的引用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.super 关键字不仅可以指代子类的直接父类，还可以指代父类的父类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.子类可以通过 super 关键字调用父类的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'D.子类可以通过 super 关键字调用父类的属性 \n', 'isCorrect': '-1'}]","【答案解析】Super只能指代父类对象
","【正确答案】B
"
"
2、
下列代码编译和运行的结果是？
class A {
	public void start() {
		System.out.println(""A Start"");
	}
}

public class B extends A {
	public void start() {
		System.out.println(""B Start"");
	}

	public static void main(String[] args) {
		((A) new B()).start();
	}
}
","[{'optionContent': 'A.输出：A Start \n', 'isCorrect': '-1'}, {'optionContent': 'B.输出：B Start \n', 'isCorrect': '-1'}, {'optionContent': 'C.输出：A Start B Start \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译错误 \n', 'isCorrect': '-1'}]","【答案解析】main方法里的对象相当于时向上造型的对象，所以方法的执行看子类执行子类重写方法
","【正确答案】B
"
"
3、
以下关于继承的叙述正确的是
","[{'optionContent': 'A.在Java中类只允许单一继承 \n', 'isCorrect': '-1'}, {'optionContent': 'B.在Java中一个类只能实现一个接口 \n', 'isCorrect': '-1'}, {'optionContent': 'C.在Java中一个类不能同时继承一个类和实现一个接口 \n', 'isCorrect': '-1'}, {'optionContent': 'D.在Java中接口只允许单一继承 \n', 'isCorrect': '-1'}]","【答案解析】类接口是多实现。既可以进行继承也可以进行实现。接口与接口就是多继承
","【正确答案】A
"
"
4、
public class CodeDemo {
	public static void main(String[] args) {
		new SB();
	}
}

class SA {
	D d;
	static {
		System.out.println(""D2"");
	}
	{
		System.out.println(""C3"");
		d = new D();
	}

	public SA() {
		System.out.println(""D1"");
	}
}

class SB extends SA {
	static C c = new C();
	static {
		System.out.println(""A1"");
	}
	{
		System.out.println(""B2"");
	}

	public SB() {
		System.out.println(""D"");
	}
}

class C {
	public C() {
		System.out.println(""A2"");
	}
}

class D extends C {
	public D() {
		System.out.println(""A3"");
	}
}
的输出结果是：
","[{'optionContent': 'A.A1 C B1 A2 C D A3 B2 B3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.D2 A2 A1 C3 A2 A3 D1 B2 D \n', 'isCorrect': '-1'}, {'optionContent': 'C.D2 A2 A1 C3 D D1 A3 B2 A2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.D2 A2 A1 C3 A3 A2 D1 B2 D \n', 'isCorrect': '-1'}]","【答案解析】当创建子类对象时，需要先加载父类静态信息、子类静态信息、父类对象级别信息、子类对象级别信息。父类静态信息只有静态代码块所有输出D2，子类静态信息包括静态属性和静态代码块依次加载所以输出A2、A1。子类对象级别信息包括构造代码块和构造方法依次执行（构造代码块要输出C3之后需要再雄黄酒D类对象，还要接着输出A2，A3）C3 A2 A3 D1，之后再执行子类对象级别输出B2 D
","【正确答案】B
"
"
5、
下面代码哪行会引起错误？ 1) class Parent { 2) private String name; 3) public Parent(){} 4) } 5) public class Child extends Parent { 6) private String department; 7) public Child() {} 8) public String getValue(){ return name; } 9) public static void main(String arg[]) { 10) Parent p = new Parent(); 11) } 12) }
","[{'optionContent': 'A.第 3 行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.第 6 行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.第 7 行 \n', 'isCorrect': '-1'}, {'optionContent': 'D.第 8 行 \n', 'isCorrect': '-1'}]","【答案解析】子类不能直接获取父类私有属性
","【正确答案】D
"
"
6、
分析如下Java代码，如果想在控制台上输出""B类的test()方法""， 则在1处应填入（ ）。
 class A {
 public void test() { 
System.out.println(""A类的test()方法""); 
}
 }
 class B extends A {
 public void test() {
 System.out.println(""B类的test()方法"");
 } 
public static void main(String args[]) { 
// 1
 } 
}
","[{'optionContent': 'A.A a = new B(); a.test(); \n', 'isCorrect': '-1'}, {'optionContent': 'B.A a = new A(); a.test(); \n', 'isCorrect': '-1'}, {'optionContent': 'C.B b = new A(); b.test(); \n', 'isCorrect': '-1'}, {'optionContent': 'D.B.test(); \n', 'isCorrect': '-1'}]","【答案解析】向上造型对象调用方法的执行看子类执行子类重写方法
","【正确答案】A
"
"
7、
对于代码：package cn.tedu.test1 ;
public class A{
int age;
}
package cn.tedu.test2  ;
public  class  C{
public static void main(String[] args) {
B b=new B();
}
}
class B extends A{
int age;
public void test1(){
A a=new B();
B b=new B();
}
}
 编译报错的行号是？
","[{'optionContent': 'b.clone();  //1\n', 'isCorrect': '-1'}, {'optionContent': 'a.clone();  //2\n', 'isCorrect': '-1'}, {'optionContent': 'b.clone(); //3\n', 'isCorrect': '-1'}, {'optionContent': 'A.1,2,3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.2,3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.1,2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.1,3 \n', 'isCorrect': '-1'}]","【答案解析】Clone方法被protected修饰在Object类中与ABC三个类不在一个包但是有父子关系，如果想要调用到clone方法需要保证子类对象在子类的本类中使用，1和2都不是
","【正确答案】C
"
"
8、
下列各项关于抽象类的说法正确的是
","[{'optionContent': 'A.含有抽象方法的类必须声明为抽象类 \n', 'isCorrect': '-1'}, {'optionContent': 'B.抽象类中必然含有抽象方法 \n', 'isCorrect': '-1'}, {'optionContent': 'C.抽象类可以被实例化 \n', 'isCorrect': '-1'}, {'optionContent': 'D.抽象类中没有构造方法 \n', 'isCorrect': '-1'}]","【答案解析】抽象类中不一定含有抽象方法，含有构造方法但是不能创建对象
","【正确答案】A
"
"
多选题 （共计 10 题，总计 20分）
9、
在Java中关于abstract关键字，以下说法正确的是
","[{'optionContent': 'A.abstract类中可以没有抽象方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.abstract类的子类也可以是抽象类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.abstract方法可以有方法体 \n', 'isCorrect': '-1'}, {'optionContent': 'D.abstract类可以创建对象 \n', 'isCorrect': '-1'}, {'optionContent': 'E.abstract类可以有构造方法 \n', 'isCorrect': '-1'}]","【答案解析】抽象方法不能有方法体且抽象类不能创建对象
","【正确答案】A,B,E
"
"10
、
下列关于访问控制的说法正确的是
","[{'optionContent': 'A.public修饰的类可以被任何一个类使用和访问 \n', 'isCorrect': '-1'}, {'optionContent': 'B.protected修饰的类不能被子类使用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.默认访问控制的类不能被同一个包中的子类使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.private修饰的类只能被本类自己访问使用 \n', 'isCorrect': '-1'}]","【答案解析】Protected修饰的可以被子类访问。默认修饰的可以被同包子类访问
","【正确答案】A,D
"
"
11、
给出以下代码，请问该程序的运行结果是什么？ 
class A{
 private int x=0; 
static int y=1;
 protected int z=2; 
} 
class B extends A{
 void method(){
 System.out.println(x); 
System.out.println(y); 
System.out.println(z); 
} 
} 下列说法正确的是（ ）
","[{'optionContent': 'A.程序编译错误，因为类B不能访问变量x \n', 'isCorrect': '-1'}, {'optionContent': 'B.程序编译成功，打印输出012。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.程序编译错误，如果移走System.out.println(x)这条语句，可使编译程序通过。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.程序编译错误,因为变量x未在类B中定义。 \n', 'isCorrect': '-1'}]","【答案解析】Private在父类中是私有属性子类访问不到
","【正确答案】A,C,D
"
"
12、
对于代码： class A { private static void m(){} } public class B extends A {// 1 } 下列各项中添加到// 1处不会出错的是：
","[{'optionContent': 'A.public static int m(){return 0;} \n', 'isCorrect': '-1'}, {'optionContent': 'B.private void m() throws Exception {} \n', 'isCorrect': '-1'}, {'optionContent': 'C.void m(){} \n', 'isCorrect': '-1'}, {'optionContent': 'D.public final double m(double i){return i *= 3;} \n', 'isCorrect': '-1'}, {'optionContent': 'E.public abstract void m(); \n', 'isCorrect': '-1'}]","【答案解析】父类私有方法对子类不可见，所以子类可以定义任意方法只要符合语法即可，因为B类不是抽象类所以不能定义抽象方法
","【正确答案】A,B,C,D
"
"
13、
在使用super和this关键字是，以下描述错误的是
","[{'optionContent': 'A.在子类构造方法中使用super( )显式调用父类的构造方法，super( )必须写在子类构造方法的第一行，否则编译不通过 \n', 'isCorrect': '-1'}, {'optionContent': 'B.super( )和this( )不一定要放在构造方法内第一行 \n', 'isCorrect': '-1'}, {'optionContent': 'C.this( )和super( )可以同时出现在一个构造函数中 \n', 'isCorrect': '-1'}, {'optionContent': 'D.this( )和super( )可以在static环境中使用，包括static方法和static语句块 \n', 'isCorrect': '-1'}]","【答案解析】super语句和this语句均需放在构造方法首行，所以不能同时出现。两个语句都是对象级别的不能在静态信息里使用
","【正确答案】B,C,D
"
"
14、
下列各项的说法正确的是
","[{'optionContent': 'A.封装可以降低代码的冗余度 \n', 'isCorrect': '-1'}, {'optionContent': 'B.内部类是封装的体现形式之一 \n', 'isCorrect': '-1'}, {'optionContent': 'C.继承可以降低代码的重复性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.运行时多态的前提是有继承或者实现关系 \n', 'isCorrect': '-1'}, {'optionContent': 'E.Java中类与类之间是单继承，接口与接口之间也是单继承 \n', 'isCorrect': '-1'}]","【答案解析】接口与接口之间是多继承
","【正确答案】A,B,C,D
"
"15
、
下面关于重载和重写说法正确的是
","[{'optionContent': 'A.静态方法可以被重载，但是不能被重写。 \n', 'isCorrect': '-1'}, {'optionContent': 'B.final修饰方法的时候，表示这个方法不能被重写，可以重载。 \n', 'isCorrect': '-1'}, {'optionContent': 'C.重载是一种编译时多态，重写是一种运行时多态。 \n', 'isCorrect': '-1'}, {'optionContent': 'D.子类重写的方法的权限修饰符要大于等于父类. \n', 'isCorrect': '-1'}]","【答案解析】任何方法都可以重载。
","【正确答案】A,B,C,D
"
"
16、
下列选项中 ，哪个可以使下列代码成功编译（） class Super{ private int a; //第2行 protected Super(int a) { this.a=a; } } public class Sub extends Super{ public Sub(int a) { super(a); } public Sub() { this.a=5; //第7行 } }
","[{'optionContent': 'A.将第2行改为public int a \n', 'isCorrect': '-1'}, {'optionContent': 'B.将第7行改为super(a) \n', 'isCorrect': '-1'}, {'optionContent': 'C.将第2行改为int a \n', 'isCorrect': '-1'}, {'optionContent': 'D.将第7行改为super(5) \n', 'isCorrect': '-1'}, {'optionContent': 'E.将第7行改为this(5); \n', 'isCorrect': '-1'}]","【答案解析】每个子类构造方法中都要默认调用父类的构造方法，此时父类只有有参构造，所以只有DE符合要求
","【正确答案】D,E
"
"
17、
下列关于面向对象的特征的说法正确的是
","[{'optionContent': 'A.封装可以提高代码的安全性 \n', 'isCorrect': '-1'}, {'optionContent': 'B.继承可以提高代码的复用性 \n', 'isCorrect': '-1'}, {'optionContent': 'C.封装可以统一代码的结构 \n', 'isCorrect': '-1'}, {'optionContent': 'D.多态可以实现解耦 \n', 'isCorrect': '-1'}]","【答案解析】上述就是面向对象特征的优点
","【正确答案】A,B,C,D
"
"
18、
下列选项中，哪个可以使下列代码成功编译？
 package cn.tedu.a; class Super{ 
private int a; //第2行 
Super(){} // 第3行
 protected Super(int a){ 
this.a = a;
 }
 } 
pakcage cn.tedu.b;
 import cn.tedu.a.Super; 
public class Sub extends Super{ 
public Sub(int a){ 
super(a);
 }
 public Sub() { 
this.a = 5;//第8行
 }
 }
","[{'optionContent': 'A.将第2行改成public int a; \n', 'isCorrect': '-1'}, {'optionContent': 'B.将第8行改成super(6); \n', 'isCorrect': '-1'}, {'optionContent': 'C.将第2行改成int a; \n', 'isCorrect': '-1'}, {'optionContent': 'D.将第3行改成protected Super(){}; \n', 'isCorrect': '-1'}, {'optionContent': 'E.将第8行改成this(5); \n', 'isCorrect': '-1'}]","【答案解析】此题的错误出在第8行，一是不能调用到父类私有属性，二是子类构造方法不能默认调用到父类无参构造
","【正确答案】B,E
"
"
19、
对于代码 public class Test { public double add(int a, double b){ return a + b; } // 1 } 下列各项中添加在// 1处编译不会出错的是：
","[{'optionContent': 'A.pubic void add(double i ,double j){return i + j;} \n', 'isCorrect': '-1'}, {'optionContent': 'B.public static double add(int i, double j){return i + j;} \n', 'isCorrect': '-1'}, {'optionContent': 'C.public final double adds(int a, double b){return a + b;} \n', 'isCorrect': '-1'}, {'optionContent': 'D.public double add(double b, int a){return a + b;} \n', 'isCorrect': '-1'}, {'optionContent': 'E.public abstract double add(double a,double b); \n', 'isCorrect': '-1'}]","【答案解析】
","【正确答案】C,D
"
"
20、
下列关于super的说法错误的是
","[{'optionContent': 'A.super代表当前对象的引用 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过super语句来实现父类构造函数的调用 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以通过super调用私有方法或者私有属性 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以在主函数中使用super来调用其他的方法 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以使用super关键字来调用静态属性 \n', 'isCorrect': '-1'}]","【答案解析】Super代表父类对象但是不能调用到父类的私有属性，main方法是静态方法不能使用super，不同级别
","【正确答案】A,C,D
"
"
21、下列各项中是面向对象的特征的是
","[{'optionContent': 'A.封装 \n', 'isCorrect': '-1'}, {'optionContent': 'B.继承 \n', 'isCorrect': '-1'}, {'optionContent': 'C.抽象 \n', 'isCorrect': '-1'}, {'optionContent': 'D.多态 \n', 'isCorrect': '-1'}, {'optionContent': 'E.跨平台 \n', 'isCorrect': '-1'}]","【答案解析】封装、继承、多态
","【正确答案】A,B,D
"
"10、在Java中关于abstract关键字，以下说法正确的是
","[{'optionContent': 'A.abstract类中可以没有抽象方法 \n', 'isCorrect': '-1'}, {'optionContent': 'B.abstract类的子类也可以是抽象类 \n', 'isCorrect': '-1'}, {'optionContent': 'C.abstract方法可以有方法体 \n', 'isCorrect': '-1'}, {'optionContent': 'D.abstract类可以创建对象 \n', 'isCorrect': '-1'}, {'optionContent': 'E.abstract类可以有构造方法 \n', 'isCorrect': '-1'}]","【答案解析】抽象方法不能有方法体且抽象类不能创建对象
","【正确答案】A,B,E
"
"

  面向对象的引入
1、
下面关于构造函数说法不正确的是
","[{'optionContent': 'A.构造函数中可以有return语句 \n', 'isCorrect': '-1'}, {'optionContent': 'B.每个类中都至少含有一个构造函数 \n', 'isCorrect': '-1'}, {'optionContent': 'C.一个类中可以有多个构造函数 \n', 'isCorrect': '-1'}, {'optionContent': 'D.一个类中，构造函数的优先级高于构造代码块 \n', 'isCorrect': '-1'}]","【答案解析】构造代码块优先于任意形式的构造方法先执行
","【正确答案】D
"
"
多选题 （共计 3 题，总计 6分）
2、
成员变量和局部变量说法正确的是
","[{'optionContent': 'A.作用域不同 \n', 'isCorrect': '-1'}, {'optionContent': 'B.存储位置不同 \n', 'isCorrect': '-1'}, {'optionContent': 'C.生命周期不同生命周期不同 \n', 'isCorrect': '-1'}, {'optionContent': 'D.定义位置不同 \n', 'isCorrect': '-1'}]","【答案解析】定义位置不同导致作用范围不同，作用范围不同是由内存位置不同来实现的，内存位置不同导致生命周期不同
","【正确答案】A,B,C,D
"
"
3、
关于定义构造方法，下列说法正确的是
","[{'optionContent': 'A.在类中声明构造函数时，名称应该与类名相同 \n', 'isCorrect': '-1'}, {'optionContent': 'B.具有重载特性，可以建立多个相同的名称 \n', 'isCorrect': '-1'}, {'optionContent': 'C.使用类建立新对象时，会自动执行构造函数，因此可以在构造函数内设定变量的初值或进行内存分配 \n', 'isCorrect': '-1'}, {'optionContent': 'D.构造函数没有返回值 \n', 'isCorrect': '-1'}]","【答案解析】构造方法是一个没有返回值、与类同名且可以支持重载的方法。创建对象必须调用构造方法所以可以进行属性初始化的操作
","【正确答案】A,B,C,D
"
"
4、
下列关于Java中的类和对象的说法正确的是
","[{'optionContent': 'A.类和对象一样，只是说法不一样 \n', 'isCorrect': '-1'}, {'optionContent': 'B.对象是具有属性和行为的实体 \n', 'isCorrect': '-1'}, {'optionContent': 'C.类规定类对象所拥有的特征和行为 \n', 'isCorrect': '-1'}, {'optionContent': 'D.类是对一类对象的概括 \n', 'isCorrect': '-1'}]","【答案解析】类和对象不一样，类是一段描述，对象是具体表现
","【正确答案】B,C,D
"
"
方法
1、
对于代码 public class Test{
 public int add(int i,int j){ 
return i+j; } //1 
} 下列各项中能够放入//1处的是
","[{'optionContent': 'A.public void add(int i,double j){ return i+j; } \n', 'isCorrect': '-1'}, {'optionContent': 'B.public double add(float i,char j){ return i+j; } \n', 'isCorrect': '-1'}, {'optionContent': 'C.public static add(int i,int j){ return i+j; } \n', 'isCorrect': '-1'}, {'optionContent': 'D.public byte add(byte i,byte j){ return i+j; } \n', 'isCorrect': '-1'}, {'optionContent': 'E.public char add(long i,long j){ return i+j; } \n', 'isCorrect': '-1'}]","【答案解析】void方法没有返回值。普通方法需要定义返回值类型。D和E选项方法返回值都是int，类型接受不对
","【正确答案】B
"
"
多选题 （共计 3 题，总计 6分）
2、
下列方法中能和方法int max(int a, int b, double c)构成重载关系的是( )
","[{'optionContent': 'A.private double max(int a, int b, double c) \n', 'isCorrect': '-1'}, {'optionContent': 'B.void max(int a, double c, int b) \n', 'isCorrect': '-1'}, {'optionContent': 'C.int max(double a, int b) \n', 'isCorrect': '-1'}, {'optionContent': 'D.int max(int x, int y, double z) \n', 'isCorrect': '-1'}]","【答案解析】方法名一致，参数列表不一致
","【正确答案】B,C
"
"
3、
对于代码 
public class Test{ 
public void show(int x, int y, int z) {
 } //1 
} 
下列各项中添加在// 1处编译不会出错的是：
","[{'optionContent': 'A.public int show(int x,int y,float z){return 0;} \n', 'isCorrect': '-1'}, {'optionContent': 'B.public int show(int x,int y,int z){return 0;} \n', 'isCorrect': '-1'}, {'optionContent': 'C.public void show(int x,int z){} \n', 'isCorrect': '-1'}, {'optionContent': 'D.public void show(int z,int y,int x){} \n', 'isCorrect': '-1'}]","【答案解析】要出现重载，方法名一致参数列表不一致
","【正确答案】A,C
"
"
4、
下列关于java中的方法描述正确的是
","[{'optionContent': 'A.Java中定义方法的格式是，修饰符 返回值类型 方法名(参数列表){方法体} \n', 'isCorrect': '-1'}, {'optionContent': 'B.Java中的方法，如果有返回值，方法中必须有return语句 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Java中定义方法，参数列表中必须有形参变量 \n', 'isCorrect': '-1'}, {'optionContent': 'D.Java中的方法，可以无限的被反复调用 \n', 'isCorrect': '-1'}]","【答案解析】方法可以没有参数
","【正确答案】A,B,D
"
"






数组
1、
对于代码： public class Test {
	public static void main(String[] args) {
		int[] a = { 12, 20, 5, 16, 15, 1, 30, 45, 23, 9 };
		int start = 0;
		int end = a.length - 1;
		sort(a, start, end);
		for (int i = 0; i < a.length; i++) {
			System.out.println(a[i]);
		}
	}

	public static void sort(int[] a, int low, int high) {
		int start = low;
		int end = high;
		int key = a[low];
		while (end > start) {
			while (end > start && a[end] >= key)
				end--;
			if (a[end] <= key) {
				int temp = a[end];
				a[end] = a[start];
				a[start] = temp;
			}
			while (end > start && a[start] <= key)
				start++;
			if (a[start] >= key) {
				int temp = a[start];
				a[start] = a[end];
				a[end] = temp;
			}
		}
		if (start > low)
			sort(a, low, start - 1);
		if (end < high)
			sort(a, end + 1, high);
	}
}实现的效果是
","[{'optionContent': 'A.获取数组的最大值 \n', 'isCorrect': '-1'}, {'optionContent': 'B.获取数组的最小值 \n', 'isCorrect': '-1'}, {'optionContent': 'C.将数组降序排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.将数组升序排序 \n', 'isCorrect': '-1'}, {'optionContent': 'E.将数组扩为两倍 \n', 'isCorrect': '-1'}]","【答案解析】如果数组后面小于前面的就交换，前面大于了后面的也交换，最后就是按照升序进行排序
","【正确答案】D
"
"
2、
下列Java代码输出的结果是 public class T14 {
	public static void main(String[] args) {
		int[] ary1 = { 3, 4, 5 };
		int[] ary2 = { 3, 4 };
		int[] ary3 = f(ary1, ary2);
		System.out.println(Arrays.toString(ary3));
	}

	public static int[] f(int[] ary1, int[] ary2) {
		int[] ary = Arrays.copyOf(ary1, ary1.length + ary2.length);
		System.arraycopy(ary2, 0, ary, ary1.length, ary2.length);
		return ary;
	}
}
","[{'optionContent': 'A.[3, 4, 5] \n', 'isCorrect': '-1'}, {'optionContent': 'B.[3, 4, 5, 0, 0] \n', 'isCorrect': '-1'}, {'optionContent': 'C.[3, 4, 5, 3, 4] \n', 'isCorrect': '-1'}, {'optionContent': 'D.[3, 4, 3, 4, 5] \n', 'isCorrect': '-1'}]","【答案解析】第一次数组扩容是让ary指向前面数值是ary1的值长度为5的新数组。第二次扩容是把ary2里的值从ary1值后继续赋值
","【正确答案】C
"
"
3、
对于代码：
public void test(int[] arr) {
		int i, j, note;
		for (i = 1; i < arr.length; i++) {
			note = arr[i];
			j = i - 1;
			while (j >= 0 && note < arr[j]) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = note;
		}
	} 所实现的功能是
","[{'optionContent': 'A.获取最大值 \n', 'isCorrect': '-1'}, {'optionContent': 'B.获取最小值 \n', 'isCorrect': '-1'}, {'optionContent': 'C.升序排序 \n', 'isCorrect': '-1'}, {'optionContent': 'D.降序排序 \n', 'isCorrect': '-1'}, {'optionContent': 'E.反转数组 \n', 'isCorrect': '-1'}]","【答案解析】如果后面的值比前面的小就把前面的值赋值给后面
","【正确答案】C
"
"
4、
数组的声明错误的是:
","[{'optionContent': 'A.int[] a=new int[3]; \n', 'isCorrect': '-1'}, {'optionContent': 'B.int[] a=new int[]{1,2,3}; \n', 'isCorrect': '-1'}, {'optionContent': 'C.int[] a={1,2,3}; \n', 'isCorrect': '-1'}, {'optionContent': 'D.int[] a=new int[3]{1,2,3}; \n', 'isCorrect': '-1'}]","【答案解析】定义数组直接给定元素值时长度就以及确定了无法再次指定
","【正确答案】D
"
"
多选题 （共计 1 题，总计 2分）
5、
下列数组格式定义正确的是
","[{'optionContent': 'A.int[][] a = new int[][]; \n', 'isCorrect': '-1'}, {'optionContent': 'B.int[4][4] a = new int[][]; \n', 'isCorrect': '-1'}, {'optionContent': 'C.int[4][] a = new int[][]; \n', 'isCorrect': '-1'}, {'optionContent': 'D.int[][] a = new int[4][]; \n', 'isCorrect': '-1'}, {'optionContent': 'E.int[][] a = new int[4][4]; \n', 'isCorrect': '-1'}]","【答案解析】二维一定要指定长度。声明的[]不能有值
","【正确答案】D,E
"
"





流程控制语句
1、
下面程序执行的结果是(） 
classDemo{ 
public static void main(String [] args) {
 int a=10; if(a++>10) { a=20; 
} System.out.println(a); 
}
 }
","[{'optionContent': 'A.10 \n', 'isCorrect': '-1'}, {'optionContent': 'B.11 \n', 'isCorrect': '-1'}, {'optionContent': 'C.20 \n', 'isCorrect': '-1'}, {'optionContent': 'D.21 \n', 'isCorrect': '-1'}]","【答案解析】判断为false不执行语句体，但是a已经自加为11
","【正确答案】B
"
"
2、
关于于以下程序代码的说明正确的是( ) 
@Test public void testMethod(){ 
int i = 0 , j = -1;
 switch (i++) { 
case 0 :
 j=0; 
case 1 :
 j=1; 
case 2 :
 j=2;
 } 
System.out.println(j);
 }
","[{'optionContent': 'A.-1 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0 \n', 'isCorrect': '-1'}, {'optionContent': 'C.1 \n', 'isCorrect': '-1'}, {'optionContent': 'D.2 \n', 'isCorrect': '-1'}]","【答案解析】i++的值是0会匹配到case 0，j=-1，但是后面都没有break会发生case穿透效果，所以会一直往下执行到代码最后一行最后j=2
","【正确答案】D
"
"
多选题 （共计 2 题，总计 4分）
3、
对于代码 public class Test {
	public static void main(String[] args){ 
		Outer:for(int i=0;i<2;i++){
			Inner:for(int j=0;j<3;j++){ 
				if(j==2){ 
				continue Outer; 
				} 
				System.out.println(i+"",""+j);
				}
	}
	}
}的输出结果为
","[{'optionContent': 'A.0，0 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0，1 \n', 'isCorrect': '-1'}, {'optionContent': 'C.0，2 \n', 'isCorrect': '-1'}, {'optionContent': 'D.1，0 \n', 'isCorrect': '-1'}, {'optionContent': 'E.1，1 \n', 'isCorrect': '-1'}]","【答案解析】Continue是跳过当此循环，针对的是外层循环
","【正确答案】A,B,D,E
"
"
4、
如下变量的定义，double d = 1.5;int x=1,y=2,z=3;则正确的switch语句是
","[{'optionContent': 'A.switch((int)d){ case 1: System.out.println(x); break; case 2: System.out.println(y); break; }\n', 'isCorrect': '-1'}, {'optionContent': 'B.switch(d){ case 1.5: System.out.println(x); break; case 2.0: System.out.println(y); break; }\n', 'isCorrect': '-1'}, {'optionContent': 'C.switch(x+y){ case 1: System.out.println(x); break; case 2: System.out.println(y);break; }\n', 'isCorrect': '-1'}, {'optionContent': 'D.switch(x+y){ case 1: System.out.println(x); break; case z: System.out.println(y); break; }\n', 'isCorrect': '-1'}]","【答案解析】Switch表达式不支持double类型。Case后的值是常量不能是变量
","【正确答案】A,C
"
"





运算符
1、
下面程序的输出结果是() int i = 3;	System.out.println(i+=i-=i*=i);
","[{'optionContent': 'A.2 \n', 'isCorrect': '-1'}, {'optionContent': 'B.9 \n', 'isCorrect': '-1'}, {'optionContent': 'C.0 \n', 'isCorrect': '-1'}, {'optionContent': 'D.-3 \n', 'isCorrect': '-1'}]","【答案解析】整体是一个连等赋值，用到了扩展赋值需要把整体展开从等号右边先计算再给左边赋值。第一个扩展赋值就是3乘于3作为结果值再和前面的3进行求差为-6，最后在和最前面的3进行求和结果就是-3
","【正确答案】D
"
"
2、
下列语句的输出结果是:（）。 System.out.println(5+7+'I'+""tarena""+5+7);
","[{'optionContent': 'A.84tarena57 \n', 'isCorrect': '-1'}, {'optionContent': 'B.57tarena12 \n', 'isCorrect': '-1'}, {'optionContent': 'C.57tarena57 \n', 'isCorrect': '-1'}, {'optionContent': 'D.85tarena57 \n', 'isCorrect': '-1'}]","【答案解析】代码从右往左依次执行，5和7进行求和，遇见字符需要把字符转成对应的编码值进行求和最后的结果是85，再和字符串直接量以及后面的所有内容进行拼接
","【正确答案】D
"
"
3、
运算符的的优先级顺序正确的是
","[{'optionContent': 'A.()>!>算术运算符>关系运算符>&&>||> = \n', 'isCorrect': '-1'}, {'optionContent': 'B.()>算数运算符>关系运算符>!>&&>||>= \n', 'isCorrect': '-1'}, {'optionContent': 'C.()>关系运算符>算数运算符>&&>!>||>= \n', 'isCorrect': '-1'}, {'optionContent': 'D.()>!>关系运算符>算数运算符>&&>||>=(错误答案) \n', 'isCorrect': '-1'}]","【答案解析】() ~ ++ -- ! * / % + - << >> >>> 关系 逻辑 & | ^ 三元 赋值
","【正确答案】A
"
"
4、
执行语句int i=12;System.out.println(i+=i-=i*=i);的结果是
","[{'optionContent': 'A.100 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0 \n', 'isCorrect': '-1'}, {'optionContent': 'C.-120 \n', 'isCorrect': '-1'}, {'optionContent': 'D.程序无法编译 \n', 'isCorrect': '-1'}]","【答案解析】扩展赋值运算符需要进行展开12+=12-=12*12=144---12+=12-144=-132----132-12
","【正确答案】C
"
"
5、
下列str1,str2输出的结果正确的是？ String str1 = 'a' + 3 + ""Hello""; 　　 String str2 = ""Hello"" + 'a' + 3;
","[{'optionContent': 'A.str1 = 100Hello str2 = Helloa3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.str1 = a3Hello str2 = Helloa3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.str1 = 100Hello str2 = Hello100 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译异常 \n', 'isCorrect': '-1'}]","【答案解析】字符和整数进行求和会把字符转成对于的编码值进行求和结果为100再和字符串直接量进行拼接结果为100Hello。字符串直接量可以拼接任意数据后面的所有数据直接进行拼接结果为Helloa3
","【正确答案】A
"
"
6、
以下运行结果正确的是
 public class Test3 { 
public static void main(String[] args) {
 boolean b = true ? false : true == true ? false : true; boolean d = false ? false : true == false ? true : false; 
System.out.println(b); 
System.out.println(d); 
}
 }
","[{'optionContent': 'A.true true \n', 'isCorrect': '-1'}, {'optionContent': 'B.true false \n', 'isCorrect': '-1'}, {'optionContent': 'C.false true \n', 'isCorrect': '-1'}, {'optionContent': 'D.false false \n', 'isCorrect': '-1'}]","【答案解析】三目运算符表达式值为true就执行？后面的语句所有b的返回值是false。d的三目运算符表达式是false需要执行：后面的内容相当于又要执行一个三目运算符，此时这个三目运算符的表达式比较完是false接着执行:后面的返回false
","【正确答案】D
"
"  
7、
编译运行以下程序后，关于输出结果的说明正确的是（） public class Text04 { public static void main(String args[]) { int x = 4; System.out.println(""value  is"" + ((x > 4) ? 99.9 : 9)); } }
","[{'optionContent': 'A.输出结果为：value  is  99.9 \n', 'isCorrect': '-1'}, {'optionContent': 'B.输出结果为：value  is  9 \n', 'isCorrect': '-1'}, {'optionContent': 'C.value  is  9.0 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译错误 \n', 'isCorrect': '-1'}]","【答案解析】执行三目运算符表达式值为false执行:后面的值，如果是基本类型之间可以类型提升java会默认保证:前后类型一致
","【正确答案】C
"
"
8、
以下代码的运行结果正确的是（） public static void main(String[] args) {
		byte a;
		int b, c, d;
		a = 5;
		b = a += a -= a *= a++;
		c = b *= b += b += --b;
		d = c + 2;
		System.out.println(d > b ? a : c);
	}
","[{'optionContent': 'A.-15 \n', 'isCorrect': '-1'}, {'optionContent': 'B.15 \n', 'isCorrect': '-1'}, {'optionContent': 'C.100 \n', 'isCorrect': '-1'}, {'optionContent': 'D.35 \n', 'isCorrect': '-1'}]","【答案解析】进行连等赋值时需要进行展开先把最右边值计算才能传值给左边，a++的值是5和左边的5进行相乘为25，再和左边的5进行求差为-20，再和左边的5进行求和最后b的值为-15。同理可得--b为-16和左边的-15进行求和为-31，再和左边的-15进行求和为-46再和左边的-15进行相乘最后c的值为690再加上2为d的值。d比b大最后三目返回的是a的值为-15
","【正确答案】A
"
"
9、
以下程序的输出结果为：为： 
public static void main(String args[]) {
		int a = 10;
		int b = 20;
		boolean flag = a++ > b-- && b++ > a--;
		System.out.println(flag + "",a="" + a + "",b="" + b);
	}
","[{'optionContent': 'A.false,a=11,b=19 \n', 'isCorrect': '-1'}, {'optionContent': 'B.false,a=10,b=20 \n', 'isCorrect': '-1'}, {'optionContent': 'C.true,a=11,b=19 \n', 'isCorrect': '-1'}, {'optionContent': 'D.true,a=10,b=20 \n', 'isCorrect': '-1'}]","【答案解析】a++为10，b--为20，比较结果为false出现短路右边不执行，所以a自加了依次，b自减了一次
","【正确答案】A
"
"10
、
对于代码 import java.util.Scanner; public class Demo{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); int i=sc.nextInt(); int j=sc.nextInt(); i+=i*=i-=j; System.out.println(i); } } 如果输入的值是-5 3,则输出结果为：
","[{'optionContent': 'A.-5 \n', 'isCorrect': '-1'}, {'optionContent': 'B.5 \n', 'isCorrect': '-1'}, {'optionContent': 'C.15 \n', 'isCorrect': '-1'}, {'optionContent': 'D.25 \n', 'isCorrect': '-1'}, {'optionContent': 'E.35 \n', 'isCorrect': '-1'}]","【答案解析】因为是扩展赋值，所以需要展开从右往左进行计算。
","【正确答案】E
"
"
多选题 （共计 6 题，总计 12分）
11、
两段if执行完之后，各自C的输出值正确的是 int a = 1,b = 2,c = 3; 　　if(a > b && c++ > b) 　　int a = 1,b = 2,c = 3; 　　if(a > b & c++ > b)
","[{'optionContent': 'A.3，4 \n', 'isCorrect': '-1'}, {'optionContent': 'B.3，3 \n', 'isCorrect': '-1'}, {'optionContent': 'C.4，4 \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译异常 \n', 'isCorrect': '-1'}]","【答案解析】&&左边的值为false会出现短路右边默认不执行，&无论左边是什么布尔值右边都要执行
","【正确答案】A
"
"
12、
根据下面的代码： String s = null; 会抛出NullPointerException异常的有
","[{'optionContent': 'A.if((s!=null)&(s.length()>0)) \n', 'isCorrect': '-1'}, {'optionContent': 'B.if((s!=null)&&(s.length()>0)) \n', 'isCorrect': '-1'}, {'optionContent': 'C.if((s==null)|(s.length()==0)) \n', 'isCorrect': '-1'}, {'optionContent': 'D.if((s==null)||(s.length()==0)) \n', 'isCorrect': '-1'}]","【答案解析】Null调用方法会出现空指针异常。&和|都没有短路所以会让null调用到方法
","【正确答案】A,C
"
"
13、
int x=1 int y =1; boolean b = x++>3||true&&y++>3||x++>=3&&y++>=3 x=? , y=? b=?
","[{'optionContent': 'A.x=3 \n', 'isCorrect': '-1'}, {'optionContent': 'B.y=2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.b=false \n', 'isCorrect': '-1'}, {'optionContent': 'D.y=3 \n', 'isCorrect': '-1'}, {'optionContent': 'E.x=2 \n', 'isCorrect': '-1'}]","【答案解析】x++值为1、x自加1为2、第一个||左边为false，第一个||右边是true整体运算结果是true作为第一个&&左边的布尔值。y++值为1、y自加1为2、第一个&&的右边布尔值为false整体运算结果为false作为第二个||左边的布尔值。x++为2、自加1为3、第二个||的右边为false，第二||整体运算结果为false作为第二个&&的左边出现短路后面内容不执行，所有最后x为3、y为2、b为false
","【正确答案】A,B,C
"
"
14、
在//insert code here 处填写下列哪行代码可以实现交换a,b的值？ public class CodeDemo { public static void main(String[] args) { int a = 5 , b = 8 ; //insert code here System.out.println(a + “,” + b); } }
","[{'optionContent': 'A.int t = a ; b = a ; a = t ; \n', 'isCorrect': '-1'}, {'optionContent': 'B.int t = b ; a = b ; b = t; \n', 'isCorrect': '-1'}, {'optionContent': 'C.int a = a + b ; b = a - b ; a = a - b; \n', 'isCorrect': '-1'}, {'optionContent': 'D.int t = a ; a = b ; b = t; \n', 'isCorrect': '-1'}, {'optionContent': 'E.a = a ^ b ; b = a ^ b ; a = a ^ b; \n', 'isCorrect': '-1'}]","【答案解析】笔记有三种交换方式的详细解释，请参考第三天笔记
","【正确答案】C,D,E
"
"
15、
下列程序中不会出现编译错误的是
","[{'optionContent': 'A.short s1 = 3; short s2 = 5; s1 += s2; \n', 'isCorrect': '-1'}, {'optionContent': 'B.short s1 = 3; short s2 = 5; s1 = s1+s2; \n', 'isCorrect': '-1'}, {'optionContent': 'C.short s1 = 3; short s2 = 5; s1 = s1 * s2; \n', 'isCorrect': '-1'}, {'optionContent': 'D.short s1 = 3; short s2 = 5; s1 *= s2 ; \n', 'isCorrect': '-1'}]","【答案解析】扩展赋值运算默认底层有强制类型转换不会出现编译错误
","【正确答案】A,D
"
"
16、
下列各项可能会出现空指针异常的是
","[{'optionContent': 'A.s != null & !s.equals(“”); \n', 'isCorrect': '-1'}, {'optionContent': 'B.s != null && !s.equals(“”); \n', 'isCorrect': '-1'}, {'optionContent': 'C.s != null | !s.equals(“”); \n', 'isCorrect': '-1'}, {'optionContent': 'D.s != null || !s.equals(“”); \n', 'isCorrect': '-1'}, {'optionContent': 'E.s == null || s.equals(“”) \n', 'isCorrect': '-1'}]","【答案解析】只要逻辑运算符的左边是false而且能执行右边内容就会出现空指针异常
","【正确答案】A,C,D
"
"
7、public class test{ public static void main (String args[]){ int i＝0×FFFFFFF1; int j＝~i; } } 当程序运行到第五行的时候i和j分别是多少
","[{'optionContent': 'A.i为-15 j为14 \n', 'isCorrect': '-1'}, {'optionContent': 'B.i为-14 j为15 \n', 'isCorrect': '-1'}, {'optionContent': 'C.编译异常 \n', 'isCorrect': '-1'}, {'optionContent': 'D.运行异常 \n', 'isCorrect': '-1'}]","【答案解析】0xfffffff1是十六进制的补码形式，每个f转变成二进制都是4个1，所以转成二进制的形式就是前面28位都是1中间3位是0最后1位是1，想要得到i的值需要把补码转成原码，最后就是-15。j按位取反就是前28位都是0中间3位是1最后一位是0最后结果就是14
","【正确答案】A
"
"



常量与变量
1、
下列标识符定义不正确的是
","[{'optionContent': 'A.HelloWord \n', 'isCorrect': '-1'}, {'optionContent': 'B.main \n', 'isCorrect': '-1'}, {'optionContent': 'C.char \n', 'isCorrect': '-1'}, {'optionContent': 'D._123 \n', 'isCorrect': '-1'}]","【答案解析】标识符不能是关键字
","【正确答案】C
"
"
2、
以下运行结果正确的是 
public class Demo1{ 　	　
public static void main(String[] args){ 　
　　　	double total = 2.0; 　　　　
        	double used = 1.1; 　　　　 
               double result = total - used;
 　　　  System.out.println(""result : "" + result);
","[{'optionContent': 'A.0.8999999999999999 \n', 'isCorrect': '-1'}, {'optionContent': 'B.0 \n', 'isCorrect': '-1'}, {'optionContent': 'C.Null \n', 'isCorrect': '-1'}, {'optionContent': 'D.编译异常 \n', 'isCorrect': '-1'}]","【答案解析】大部分小数底层二进制补码形式都是无限位数但是double数据类型的存储范围是一定的，所以小数在进行运算时会有无法精确运算小数位的情况
","【正确答案】A
"
"
3、
下列各项中是java中的关键字的是
","[{'optionContent': 'A.System \n', 'isCorrect': '-1'}, {'optionContent': 'B.out \n', 'isCorrect': '-1'}, {'optionContent': 'C.Scanner \n', 'isCorrect': '-1'}, {'optionContent': 'D.true \n', 'isCorrect': '-1'}]","【答案解析】查看关键字表即可
","【正确答案】D
"
"
多选题 （共计 9 题，总计 18分）
4、
下列各项中可以正确赋值的是：
","[{'optionContent': 'A.byte=0b01111111; \n', 'isCorrect': '-1'}, {'optionContent': ""B.short s='测' \n"", 'isCorrect': '-1'}, {'optionContent': 'C.float f=3000; \n', 'isCorrect': '-1'}, {'optionContent': 'D.double d=0x3p2 \n', 'isCorrect': '-1'}, {'optionContent': 'E.int i=2e4; \n', 'isCorrect': '-1'}]","【答案解析】2e4是属于科学计数法，只能小数是这样表示
","【正确答案】A,B,C,D
"
"
5、
下列各项中能正确编译运行的是
","[{'optionContent': 'A.byte b=120+8; \n', 'isCorrect': '-1'}, {'optionContent': 'B.char c=’d’;c++; \n', 'isCorrect': '-1'}, {'optionContent': 'C.byte b=3;b*=2; \n', 'isCorrect': '-1'}, {'optionContent': 'D.short s=’a’;s=s+5; \n', 'isCorrect': '-1'}, {'optionContent': 'E.short s1=3,s2=6;short s=s1+s2; \n', 'isCorrect': '-1'}]","【答案解析】扩展赋值运算符默认含有强制类型转换，BC两个选项都是
","【正确答案】B,C
"
"
6、
下列各项中能正确编译运行的是
","[{'optionContent': ""A.byte b='0'; \n"", 'isCorrect': '-1'}, {'optionContent': 'B.char c=0x20; \n', 'isCorrect': '-1'}, {'optionContent': 'C.long l=213452093726; \n', 'isCorrect': '-1'}, {'optionContent': 'D.float f=-12; \n', 'isCorrect': '-1'}, {'optionContent': 'E.int i=3e5; \n', 'isCorrect': '-1'}]","【答案解析】C选项的右边整数值默认是int类型，数值超过了interesting范围。E选项的初始值是科学记数法表示的，只有小数才能这样表示
","【正确答案】A,B,D
"
"
7、
下列对Java变量的使用说法正确的是
","[{'optionContent': 'A.声明变量可以指定数据类型，也可以不指定 \n', 'isCorrect': '-1'}, {'optionContent': 'B.变量名采用任意命名的方式，尽量做到见名知意 \n', 'isCorrect': '-1'}, {'optionContent': 'C.局部变量声明后，要为其赋一个确定的初值后再使用 \n', 'isCorrect': '-1'}, {'optionContent': 'D.变量是指在内存中开辟的存储空间中存放的运算过程中需要用到的数据 \n', 'isCorrect': '-1'}]","【答案解析】变量声明必须指定类型。变量名要符合标识符语法
","【正确答案】C,D
"
"
8、
下列各项中可以正确编译运行的是:
","[{'optionContent': 'A.byte b = 3 + 5； \n', 'isCorrect': '-1'}, {'optionContent': 'B.char c = 98; c++; \n', 'isCorrect': '-1'}, {'optionContent': ""C.float f = 'a'; \n"", 'isCorrect': '-1'}, {'optionContent': 'D.double d = 123456789012; \n', 'isCorrect': '-1'}, {'optionContent': ""E.byte b = 'a'; \n"", 'isCorrect': '-1'}]","【答案解析】A选项是只有直接量计算会进行编译优化直接计算结果进行赋值。B选项++会默认进行强制类型转换。D选项的值超过了int范围
","【正确答案】A,B,C,E
"
"
9、
下列各项中对于正确赋值的是
","[{'optionContent': ""A.byte b ='a'; \n"", 'isCorrect': '-1'}, {'optionContent': 'B.short s = 2 << 5; \n', 'isCorrect': '-1'}, {'optionContent': 'C.float f = -5; \n', 'isCorrect': '-1'}, {'optionContent': 'D.float f = 3.2f / 1; \n', 'isCorrect': '-1'}]","【答案解析】上述四种赋值都是正确赋值
","【正确答案】A,B,C,D
"
"
10、
下列选项中不会出现语法编译错误的是：
","[{'optionContent': 'A.long l = 999999; \n', 'isCorrect': '-1'}, {'optionContent': 'B.long l = 9999999999L; \n', 'isCorrect': '-1'}, {'optionContent': 'C.byte b = 90+40; \n', 'isCorrect': '-1'}, {'optionContent': ""D.int i = 'A'+'中'; \n"", 'isCorrect': '-1'}]","【答案解析】90+40是属于都是直接量参与运算所以直接计算结果值，结果值大于byte范围就会报错
","【正确答案】A,B,D
"
"
11、
下面哪些是合法的标志符
","[{'optionContent': 'A.2variable \n', 'isCorrect': '-1'}, {'optionContent': 'B.String2 \n', 'isCorrect': '-1'}, {'optionContent': 'C.what$ \n', 'isCorrect': '-1'}, {'optionContent': 'D._3_ \n', 'isCorrect': '-1'}]","【答案解析】不能以数字开头
","【正确答案】B,C,D
"
"
12、
下列各项中可以用作java的标识符的是：
","[{'optionContent': 'A.测试 \n', 'isCorrect': '-1'}, {'optionContent': 'B.T2T \n', 'isCorrect': '-1'}, {'optionContent': 'C.$_$ \n', 'isCorrect': '-1'}, {'optionContent': 'D.cn.tedu \n', 'isCorrect': '-1'}, {'optionContent': 'E.202 \n', 'isCorrect': '-1'}]","【答案解析】标识符不包括.这个符号。标识符不能以数字开头
","【正确答案】A,B,C
"
"



Java的引入
1、
下列命令可以正确编译Java文件的是
","[{'optionContent': 'A.java Test.java \n', 'isCorrect': '-1'}, {'optionContent': 'B.javac cn.tedu.Test.java \n', 'isCorrect': '-1'}, {'optionContent': 'C.javac Test \n', 'isCorrect': '-1'}, {'optionContent': 'D.java Test \n', 'isCorrect': '-1'}, {'optionContent': 'E.javac Test.java \n', 'isCorrect': '-1'}]","【答案解析】javac命令是执行编译命令要跟上.java文件名
","【正确答案】E
"
"
多选题 （共计 3 题，总计 6分）
2、
如果当前路径在C:\User\Test下，则下列各项命令中，能够直接跳转到根目录下的是：
","[{'optionContent': 'A.cd C:// \n', 'isCorrect': '-1'}, {'optionContent': 'B.cd . \n', 'isCorrect': '-1'}, {'optionContent': 'C.cd .. \n', 'isCorrect': '-1'}, {'optionContent': 'D.cd ~ \n', 'isCorrect': '-1'}, {'optionContent': 'E.cd / \n', 'isCorrect': '-1'}]","【答案解析】BCD三个选项都是跳转到其他目录不一定是根目录
","【正确答案】A,E
"
"
3、
对于代码： 
package cn.tedu.test;
 public class Demo{ 
public static void main(String[] args){ 
System.out.println(""Test~~"");
 } 下列说法正确的是：
","[{'optionContent': 'A.可以通过javac Demo.java来编译这个java文件 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以通过javac -d . Demo.java来编译这个文件 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以通过java cn.tedu.test.Demo 来运行这段代码 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以通过java Demo.class来运行对应的class文件 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以通过javadoc Demo来运行这段代码 \n', 'isCorrect': '-1'}]","【答案解析】.class文件不能直接运行。Javadoc不是运行的命令
","【正确答案】A,B,C
"
"
4、
对于代码： package cn.tedu.text; public class Text{ public static void main(String args[]){ System.out.println(“Text”); } } 的说法正确的是
","[{'optionContent': 'A.可以将程序放入Demo.java编译运行 \n', 'isCorrect': '-1'}, {'optionContent': 'B.可以利用javac Text.java编译此段代码 \n', 'isCorrect': '-1'}, {'optionContent': 'C.可以利用javac -d . Text.java来编译此段代码 \n', 'isCorrect': '-1'}, {'optionContent': 'D.可以利用java Text来运行此段代码 \n', 'isCorrect': '-1'}, {'optionContent': 'E.可以利用java -cp . cn.tedu.text.Text来运行此段代码 \n', 'isCorrect': '-1'}]","【答案解析】公共类的类名要和.java文件名称保持一致。Java命令不能直接运行带包的类
","【正确答案】B,C,D
"
(单选题)不是Mybatis配置文件中的主要元素是（ ）,"[{'optionContent': 'A.properties', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'properties'}, {'optionContent': 'B.transactionManager', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'transactionManager'}, {'optionContent': 'C.mappers', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'mappers'}, {'optionContent': 'D.bean', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'bean'}]",Bean是Spring里的主要元素,D
(单选题)Java是从（）语言改进重新设计,"[{'optionContent': 'A.Ada ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Ada '}, {'optionContent': 'B.C++', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'C++'}, {'optionContent': 'C.Pasacal ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Pasacal '}, {'optionContent': 'D.BASIC', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'BASIC'}]","ADA: 美国军方为了整合不同语言开发的系统而发明的一种语言,最大的特点是实时性,在ADA95中已加入面向对象内容. Pascal: 为提倡结构化编程而发明的语言,结构化特色非常明显,函数体内允许任意层次的嵌套. BASIC: 为了让大学生简单容易控制电脑开发的语言,特点是简单易懂,且可以用解释和编译两种方法执行.",B
(单选题)在Java中，以下描述错误的是（ ）,"[{'optionContent': 'A..class是源文件', 'isCorrect': '-1', 'option': 'A', 'optionValue': '.class是源文件'}, {'optionContent': 'B..java是编译前的源文件', 'isCorrect': '-1', 'option': 'B', 'optionValue': '.java是编译前的源文件'}, {'optionContent': 'C..class是编译后的文件', 'isCorrect': '-1', 'option': 'C', 'optionValue': '.class是编译后的文件'}, {'optionContent': 'D.Java程序需编译后方可运行', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Java程序需编译后方可运行'}]","此题目考查的是Java程序的开发过程。Java程序开发需要经过三个步骤：编写（.java）、编译（.class）、运行。编写的源程序为.java后缀的，编译后为.class的字节码文件，因此选项B、C是正确的，A是错误的。Java文件都需要进行编译，编译后的.class文件可以""一次编译、多次运行""，即体现了Java的特点""Write Once,Run more""。因此D是正确的选项。",A
(单选题)Java编程语言之父是（）,"[{'optionContent': 'A.James Gosling', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'James Gosling'}, {'optionContent': 'B.Abigail', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Abigail'}, {'optionContent': 'C.Brutus', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Brutus'}, {'optionContent': 'D.以上选项都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上选项都不对'}]",詹姆斯·高斯林 （James Gosling，1955年5月19日－，出生于加拿大），软件专家，Java编程语言的共同创始人之一，一般公认他为“Java之父”。,A
"(单选题)在控制台运行一个 Java 程序 TestDemo . class ，使用的命令正确的是（ ）
","[{'optionContent': 'A.java TestDemo. class\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'java TestDemo. class\n'}, {'optionContent': 'B.javac TestDemo. class\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'javac TestDemo. class\n'}, {'optionContent': 'C.java TestDemo\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'java TestDemo\n'}, {'optionContent': 'D.javac TestDemo\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'javac TestDemo\n'}]",java命令程序执行字节码文件时不能跟文件后缀名 因此C是正确的选项。,C
(多选题)下列描述中，哪些符合 Java 语言的特征（ ）,"[{'optionContent': 'A.支持跨平台(Windows,Linux,Unix等)', 'isCorrect': '-1', 'option': 'A', 'optionValue': '支持跨平台(Windows,Linux,Unix等)'}, {'optionContent': 'B.GC(自动垃圾回收)，提高了代码安全性', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'GC(自动垃圾回收)，提高了代码安全性'}, {'optionContent': 'C.支持类 C 的指针运算操作', 'isCorrect': '-1', 'option': 'C', 'optionValue': '支持类 C 的指针运算操作'}, {'optionContent': 'D.不支持与其它语言书写的程序进行通讯', 'isCorrect': '-1', 'option': 'D', 'optionValue': '不支持与其它语言书写的程序进行通讯'}]",java语言支持跨平台，没有指针的概念，拥有GC垃圾自动回收机制。,"A,B"
(多选题)下列哪些选项属于Java技术体系（）,"[{'optionContent': 'A.Java Me', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Java Me'}, {'optionContent': 'B.Java Se', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Java Se'}, {'optionContent': 'C.Java EE', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Java EE'}, {'optionContent': 'D.Java Card', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Java Card'}]",Java Card、Java Me、Java Se、Java EE都属于Java技术体系,"A,B,C,D"
(多选题)下列对Java语言的叙述中，正确的是（）,"[{'optionContent': 'A.Java虚拟机解释执行字节码', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Java虚拟机解释执行字节码'}, {'optionContent': 'B.Java的类是对具有相同行为对象的一种抽象', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Java的类是对具有相同行为对象的一种抽象'}, {'optionContent': 'C.Java中的垃圾回收机制是一个系统级的线程', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Java中的垃圾回收机制是一个系统级的线程'}, {'optionContent': 'D.JDK的库文件目录是bin', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'JDK的库文件目录是bin'}]",在JDK目录结构中，lib目录下存放的都是库文件，而bin目录下有编译器、解释器和许多工具（如服务器工具、IDL、package工具和jdb等）。,"A,B,C"
"(多选题)下列有关变量的声明正确的是
","[{'optionContent': 'A.a = 100;\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'a = 100;\n'}, {'optionContent': 'B.int number;\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int number;\n'}, {'optionContent': 'C.double d1, d2;\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'double d1, d2;\n'}, {'optionContent': 'D.int number1, number2;\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'int number1, number2;\n'}]","A选项中的a没有经过声明,未经声明的变量不能使用,B选项是声明一个int型的number变量, C选项同时声明了两个双精度浮点数(小数)变量,D选项同时声明了两个整型变量 因此BCD是正确的选项。","B,C,D"
(多选题)从下列选项中选择正确的是（ ）,"[{'optionContent': 'A.int k=new String(""aa"");', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int k=new String(""aa"");'}, {'optionContent': 'B.String str=new String(""bb"");', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String str=new String(""bb"");'}, {'optionContent': 'C.char c=74;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'char c=74;'}, {'optionContent': 'D.long j=8888;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'long j=8888;'}]",A选项创建的是String对象，变量k应为String类型。,"B,C,D"
"(单选题)在控制台显示消息的语句正确的是（ ）
","[{'optionContent': 'A.System.out.println( 欢迎来到达内！) ;\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'System.out.println( 欢迎来到达内！) ;\n'}, {'optionContent': 'B.System.Out.Println( ""欢迎来到达内！"" );\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'System.Out.Println( ""欢迎来到达内！"" );\n'}, {'optionContent': 'C.system.out.println( ""欢迎来到达内！"" );\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'system.out.println( ""欢迎来到达内！"" );\n'}, {'optionContent': 'D.System.out.println( ""欢迎来到达内！"" );\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'System.out.println( ""欢迎来到达内！"" );\n'}]","JAVA关键字严格区分大小写,输出内容语句为System.out.println( ""XXX"" ); 因此D是正确的选项。",D
(单选题)下列的标识符符合Java命名约定的是（）,"[{'optionContent': 'A.package com.Bi.hr', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'package com.Bi.hr'}, {'optionContent': 'B.public class xyz', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public class xyz'}, {'optionContent': 'C.int I', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int I'}, {'optionContent': 'D.void setCustomerName()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'void setCustomerName()'}]",包的名字应该都是由小写单词组成。它们全都是小写字母，即便中间的单词亦是如此，所以A选项错误。 类名的第一个字母一定要大写，所以B选项错误； 变量的第一个字母应该为小写，所以C选项错误； 与属性相对应的get、set方法为：set(get)+属性名，属性名第一个字母为大写，所以D选项正确。,D
"(多选题)下列有关于变量的命名正确的是
","[{'optionContent': 'A.可以由字母、数字、下划线、”$”组成;\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以由字母、数字、下划线、”$”组成;\n'}, {'optionContent': 'B.首字母能以数字开头\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '首字母能以数字开头\n'}, {'optionContent': 'C.首字母不能以数字开头\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '首字母不能以数字开头\n'}, {'optionContent': 'D.Java大小写敏感,命名变量时需要注意\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Java大小写敏感,命名变量时需要注意\n'}]","变量的命名首字母不能是数组开头,其他选项均正确 因此ACD是正确的选项。","A,C,D"
"(多选题)下列变量书写正确的是
","[{'optionContent': 'A.int 3year;\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int 3year;\n'}, {'optionContent': 'B.int float;\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int float;\n'}, {'optionContent': 'C.int Denis;\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int Denis;\n'}, {'optionContent': 'D.int cLanguageScor\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'int cLanguageScor\n'}]","此题目考查的是变量的命名规范,A选项以数字开头,B选项与关键字冲突,所以AB均错误,C选项是正常命名,D选项是多个单词组合使用驼峰命名法 因此CD是正确的选项。","C,D"
(单选题)在Java语言中，被称为内存分配的运算符是（）,"[{'optionContent': 'A.（）', 'isCorrect': '-1', 'option': 'A', 'optionValue': '（）'}, {'optionContent': 'B.[]', 'isCorrect': '-1', 'option': 'B', 'optionValue': '[]'}, {'optionContent': 'C.new', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'new'}, {'optionContent': 'D.==', 'isCorrect': '-1', 'option': 'D', 'optionValue': '=='}]",Java语言中，程序为对象动态分配内存。Java中内存分配的运算符是new。,C
"(单选题)阅读下列代码;
public class Test{
String s=""One World One Dream"";
public static void main(String args[]){
System.out.println(s);
}
}
其运行结果是（）","[{'optionContent': 'A.args', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'args'}, {'optionContent': 'B.One World One Dream', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'One World One Dream'}, {'optionContent': 'C.s', 'isCorrect': '-1', 'option': 'C', 'optionValue': 's'}, {'optionContent': 'D.编译错误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '编译错误'}]","main方法是程序执行的入口，在本程序中main方法中的语句""System.out.println(s);""无法调用在main方法外声明的变量，所以编译时出错。",D
(单选题)存储一个24X24点阵的汉字（每个点1bit），需要多少字节（ ）,"[{'optionContent': 'A.24', 'isCorrect': '-1', 'option': 'A', 'optionValue': '24'}, {'optionContent': 'B.48', 'isCorrect': '-1', 'option': 'B', 'optionValue': '48'}, {'optionContent': 'C.72', 'isCorrect': '-1', 'option': 'C', 'optionValue': '72'}, {'optionContent': 'D.144', 'isCorrect': '-1', 'option': 'D', 'optionValue': '144'}]",24*24/8=72。意思是：24*24的结果是二进制位，而八个二进制位等于 一个字节，所以再除以八是所得的字节数。,C
(单选题)能够给一个byte型变量赋值的范围是(   )。,"[{'optionContent': 'A. 0～65535', 'isCorrect': '-1', 'option': 'A', 'optionValue': ' 0～65535'}, {'optionContent': 'B.(-128)～127 ', 'isCorrect': '-1', 'option': 'B', 'optionValue': '(-128)～127 '}, {'optionContent': 'C.（-32, 768)～32, 767', 'isCorrect': '-1', 'option': 'C', 'optionValue': '（-32, 768)～32, 767'}, {'optionContent': 'D. (-256)～255 ', 'isCorrect': '-1', 'option': 'D', 'optionValue': ' (-256)～255 '}]",Byte的取值范围是(-128)～127。,B
(多选题)选择 Java 语言中的基本数据类型（ ）,"[{'optionContent': 'A.byte', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'byte'}, {'optionContent': 'B.Integer', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Integer'}, {'optionContent': 'C.char', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'char'}, {'optionContent': 'D.Boolean', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Boolean'}]","java中的8种基本数据类型：byte,short,int,long,char,boolean,float,double","A,C"
(单选题)java语言中int类型数据占用多少位?(   )。,"[{'optionContent': 'A.32', 'isCorrect': '-1', 'option': 'A', 'optionValue': '32'}, {'optionContent': 'B.20', 'isCorrect': '-1', 'option': 'B', 'optionValue': '20'}, {'optionContent': 'C.16', 'isCorrect': '-1', 'option': 'C', 'optionValue': '16'}, {'optionContent': 'D.64', 'isCorrect': '-1', 'option': 'D', 'optionValue': '64'}]",Byte类型占8位short类型占16位Int类型占32位long类型占64位,A
(多选题)下面的哪些声明是合法的（ ）,"[{'optionContent': 'A.long l = 4990', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'long l = 4990'}, {'optionContent': 'B.int i = 4L', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int i = 4L'}, {'optionContent': 'C.float f =1.1', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'float f =1.1'}, {'optionContent': 'D.double d = 34.4', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'double d = 34.4'}]",B.4L应该是long类型的写法。C.1.1是double类型，float f=1.1f是正确写法。,"A,D"
(单选题)java中char类型的取值范围是（）,"[{'optionContent': 'A.0 ... 32767', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0 ... 32767'}, {'optionContent': 'B.0 ... 65535', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0 ... 65535'}, {'optionContent': 'C.–256 ... 255', 'isCorrect': '-1', 'option': 'C', 'optionValue': '–256 ... 255'}, {'optionContent': 'D.–32768 ... 32767', 'isCorrect': '-1', 'option': 'D', 'optionValue': '–32768 ... 32767'}]",在java中，char是一个无符号16位类型，取值范围为0到65535。,B
(单选题)隐式类型转换是由按优先关系从低到高的顺序，下列描述正确的顺序为（ ）,"[{'optionContent': 'A.char-int-long-float-double ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'char-int-long-float-double '}, {'optionContent': 'B.int-long-float-double-char ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int-long-float-double-char '}, {'optionContent': 'C.long-float-int-double-char', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'long-float-int-double-char'}, {'optionContent': 'D.以上都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上都不对'}]",隐式类型转换规则是： byte→short(char)→int→long→float→double,A
"(多选题)byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/
b7=(b2+b5);  /*语句4*/
System.out.println(b3+b6);
下列代码片段中，存在编辑错误的语句是()","[{'optionContent': 'A.语句2\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '语句2\n'}, {'optionContent': 'B.语句1', 'isCorrect': '-1', 'option': 'B', 'optionValue': '语句1'}, {'optionContent': 'C.语句3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '语句3'}, {'optionContent': 'D.语句4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '语句4'}]",语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。,"B,C,D"
"(单选题)找出下列代码哪行有错误
1.public class HelloWorld{
2.    public static void main(String[] args) {
3.		double avg1=78.5;
4.		int rise=5;
5.		int avg2=avg1+rise;
6.		System.out.println(""考试平均分：""+avg1);
7.		System.out.println(""调整后的平均分：""+avg2);
8.	}
9.}
","[{'optionContent': 'A.3', 'isCorrect': '-1', 'option': 'A', 'optionValue': '3'}, {'optionContent': 'B.4', 'isCorrect': '-1', 'option': 'B', 'optionValue': '4'}, {'optionContent': 'C.5', 'isCorrect': '-1', 'option': 'C', 'optionValue': '5'}, {'optionContent': 'D.6', 'isCorrect': '-1', 'option': 'D', 'optionValue': '6'}]","在 Java 程序中，不同的基本数据类型的数据之间经常需要进行相互转换, 目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了 因此C是正确的选项。",C
"(单选题)若a为整型变量，a=12,则表达式：a-=2的值为
","[{'optionContent': 'A.10', 'isCorrect': '-1', 'option': 'A', 'optionValue': '10'}, {'optionContent': 'B.12', 'isCorrect': '-1', 'option': 'B', 'optionValue': '12'}, {'optionContent': 'C.14', 'isCorrect': '-1', 'option': 'C', 'optionValue': '14'}, {'optionContent': 'D.-10', 'isCorrect': '-1', 'option': 'D', 'optionValue': '-10'}]","此题的运算结果a=12-2,即a=10. 因此A是正确的选项.",A
(单选题)下列运算符合法的是(),"[{'optionContent': 'A.&&', 'isCorrect': '-1', 'option': 'A', 'optionValue': '&&'}, {'optionContent': 'B.<>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<>'}, {'optionContent': 'C.if', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'if'}, {'optionContent': 'D.:=', 'isCorrect': '-1', 'option': 'D', 'optionValue': ':='}]",java 中没有<> := 这种运算符， if else不算运算符,A
"(单选题)下列程序的运行结果正确的是
int a = 5;
int b = ++a;
System.out.println(“a=”+a);
System.out.println(“b=”+b);
","[{'optionContent': 'A.a=5,b=5\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'a=5,b=5\n'}, {'optionContent': 'B.a=6,b=5\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'a=6,b=5\n'}, {'optionContent': 'C.a=5,b=6\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'a=5,b=6\n'}, {'optionContent': 'D.a=6,b=6\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'a=6,b=6\n'}]","++和—可以出现操作数的左边也可以是右边,此题++出现在左边,让a先执行自增运算,然后将值赋值给变量b 因此D是正确的选项。",D
"(单选题)若定义int a=2,b=2,下列表达式中值不为4的是（）","[{'optionContent': 'A.a+b', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'a+b'}, {'optionContent': 'B.a*b', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'a*b'}, {'optionContent': 'C.a*(b++)', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'a*(b++)'}, {'optionContent': 'D.a*(++b)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'a*(++b)'}]",C选项里b是后++，先运算，后+1，不影响表达式。 D选项里b是前++，先+1，后运算，所以D输出的结果是6！,D
(单选题)以下表达式那个是不合法的（）,"[{'optionContent': 'A.String  x=""Hello"";  \nint  y=9;  x+=y; ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String  x=""Hello"";  \nint  y=9;  x+=y; '}, {'optionContent': 'B.String  x=""Hello"";  \nint  y=9;  \nif(x==y)  { }', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String  x=""Hello"";  \nint  y=9;  \nif(x==y)  { }'}, {'optionContent': 'C.String  x=""Hello"";  \nint  y=9;  x=x+y; ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'String  x=""Hello"";  \nint  y=9;  x=x+y; '}, {'optionContent': 'D.String  x=null; \nint  y=(x!=null)&&(x.length()>0) ? x.length() : 0;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'String  x=null; \nint  y=(x!=null)&&(x.length()>0) ? x.length() : 0;'}]","java对""+""进行了扩展，不仅可以连接字符串，而且还能将字符串与其它类型数据进行连接，结果是字符串。 若""+""的第一个操作数是字符串，Java会自动将后面的操作数类型转换成字符串类型。 本题选项A中，x+=y即x=x+y，则计算结果x的值为字符串Hello9； 选项C与此类似，故此选项也是正确的； 选项D主要考查的是三目运算符""?:""，即把表达式(x!=null)&&(x.length()>0) ? x.length() : 0的值赋给整型变量y，运行结果y的值是0； 而选项B是因为""==""两边的类型不匹配，无法比较，所以此表达式是错误的。",B
"(单选题)若a为整型变量，a=12,则表达式：a * =2+3的值为
","[{'optionContent': 'A.12', 'isCorrect': '-1', 'option': 'A', 'optionValue': '12'}, {'optionContent': 'B.24', 'isCorrect': '-1', 'option': 'B', 'optionValue': '24'}, {'optionContent': 'C.36', 'isCorrect': '-1', 'option': 'C', 'optionValue': '36'}, {'optionContent': 'D.60', 'isCorrect': '-1', 'option': 'D', 'optionValue': '60'}]","此题的计算结果a=(2+3)*12,即a=60. 因此D选项是正确的选项.",D
"(多选题)下列有关算数运算符描述正确的是
","[{'optionContent': 'A.“/”代表除法运算符\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '“/”代表除法运算符\n'}, {'optionContent': 'B.“/”代表求余运算符\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '“/”代表求余运算符\n'}, {'optionContent': 'C.“%”代表除法运算符\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '“%”代表除法运算符\n'}, {'optionContent': 'D.“%”代表求余运算符\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '“%”代表求余运算符\n'}]","/代表除法运算符,%代表%求余运算符 因此AD是正确的选项。","A,D"
"(单选题)下列有关逻辑运算符的描述错误的是
","[{'optionContent': 'A.使用“||”运算, 两者只要有其一为真，逻辑表达式结果就为真\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '使用“||”运算, 两者只要有其一为真，逻辑表达式结果就为真\n'}, {'optionContent': 'B.使用""!""运算,对关系表达式进行取反\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '使用""!""运算,对关系表达式进行取反\n'}, {'optionContent': 'C.短路与:若第一个表达式的值为假，后面的表达式不再计算\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '短路与:若第一个表达式的值为假，后面的表达式不再计算\n'}, {'optionContent': 'D.短路或:若第一个表达式的值为假，后面的表达式不再计算\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '短路或:若第一个表达式的值为假，后面的表达式不再计算\n'}]","此题目考查的是辑运算符的概念性知识,ABC均正确, 短路或:若第一个表达式的值为假，还需要看后面的表达式是真还是假,因此D选项错误 因此D是正确的选项。",D
"(单选题)一下运算结果为true的是
","[{'optionContent': 'A.( 5 > 2 ) && ( false )\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '( 5 > 2 ) && ( false )\n'}, {'optionContent': 'B.( false ) || ( 5 < 2 )\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '( false ) || ( 5 < 2 )\n'}, {'optionContent': 'C.( true ) && ( 2 < 5 )\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '( true ) && ( 2 < 5 )\n'}, {'optionContent': 'D.! ( 2 < 5 )\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '! ( 2 < 5 )\n'}]","C选项&&运算符左右两侧均为true,因此正确",C
"(多选题)下列有关逻辑运算符描述正确的是
","[{'optionContent': 'A.&& 与\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '&& 与\n'}, {'optionContent': 'B.|| 或\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '|| 或\n'}, {'optionContent': 'C.! 非\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '! 非\n'}, {'optionContent': 'D.^ 异或\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '^ 异或\n'}]","此题目考查的是对逻辑运算符的掌握,以上选项均正确. 因此ABCD是正确的选项。","A,B,C,D"
"(单选题)程序运算输出结果下面正确的是
public class HelloWorld{
    public static void main(String[] args) {
	    int one = 10 ;
        int two = 20 ;
        two /= one;
        System.out.println(two);
    }
}
","[{'optionContent': 'A.20', 'isCorrect': '-1', 'option': 'A', 'optionValue': '20'}, {'optionContent': 'B.10', 'isCorrect': '-1', 'option': 'B', 'optionValue': '10'}, {'optionContent': 'C.2', 'isCorrect': '-1', 'option': 'C', 'optionValue': '2'}, {'optionContent': 'D.0', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0'}]","“/=”运算符名字叫做除等于,two/=one等价于two=two/one 因此C是正确的选项。",C
(单选题)在字符串前面加上（ ）符号，则字符串中的转义字符将不被处理。,"[{'optionContent': 'A.@', 'isCorrect': '-1', 'option': 'A', 'optionValue': '@'}, {'optionContent': 'B.\\', 'isCorrect': '-1', 'option': 'B', 'optionValue': '\\'}, {'optionContent': 'C.#', 'isCorrect': '-1', 'option': 'C', 'optionValue': '#'}, {'optionContent': 'D.%', 'isCorrect': '-1', 'option': 'D', 'optionValue': '%'}]","JAVA中使用""\""符号进行转移",B
"(单选题)设整型变量a为5，使b不为2的表达式是（）
","[{'optionContent': 'A.b=a%2\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'b=a%2\n'}, {'optionContent': 'B.b=a/2\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'b=a/2\n'}, {'optionContent': 'C.b=a>3?2:1\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'b=a>3?2:1\n'}, {'optionContent': 'D.b=6-4\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'b=6-4\n'}]",首先对于B，除法的结果是保留整数，因此结果b为2。C中使用的是三目表达式，当？之前表达式结果为真的话则取数字2为结果，否则数字1为结果，对于本题5>3 为真，所以b的值为2。D中6-4等于2，所以b为2。取余运算得到的结果是一步计算的余数，因此A中5%2的商是2余数是1，因此b为1。所以本题A是正确选项。,A
"(单选题)下面有关于三目运算符的语法格式描述正确的是
","[{'optionContent': 'A.条件表达式?表达式1:表达式2;\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '条件表达式?表达式1:表达式2;\n'}, {'optionContent': 'B.条件表达式?条件表达式,表达式1:表达式2;\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '条件表达式?条件表达式,表达式1:表达式2;\n'}, {'optionContent': 'C.条件表达式!表达式1:表达式2;\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '条件表达式!表达式1:表达式2;\n'}, {'optionContent': 'D.条件表达式!条件表达式,表达式1:表达式2;\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '条件表达式!条件表达式,表达式1:表达式2;\n'}]",此题目考查的是三目运算符的语法格式: 条件表达式?表达式1:表达式2; 因此A是正确的选项。,A
"(单选题)表达式3>5?1:0的值是多少
","[{'optionContent': 'A.0', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0'}, {'optionContent': 'B.1', 'isCorrect': '-1', 'option': 'B', 'optionValue': '1'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.5', 'isCorrect': '-1', 'option': 'D', 'optionValue': '5'}]","此题目考查的是三目运算符的使用,当条件表达式3>5成立时返回1的值, 当条件表达式3>5不成立时返回0的值 因此A是正确的选项。",A
"(单选题)编译运行以下程序后，关于输出结果的说明正确的是（ ）
publicclass Conditional{
  publicstaticvoid main(String args[]){
    int x=4;
    System.out.println(""value is ""+ ((x>4) ? 99.9 : 9));
  }
}","[{'optionContent': 'A.输出结果为：value is 99.99', 'isCorrect': '-1', 'option': 'A', 'optionValue': '输出结果为：value is 99.99'}, {'optionContent': 'B.输出结果为：value is 9', 'isCorrect': '-1', 'option': 'B', 'optionValue': '输出结果为：value is 9'}, {'optionContent': 'C.输出结果为：value is 9.0', 'isCorrect': '-1', 'option': 'C', 'optionValue': '输出结果为：value is 9.0'}, {'optionContent': 'D.编译错误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '编译错误'}]",三目运算符中：第二个表达式和第三个表达式中如果都为基本数据类型，整个表达式的运算结果由容量高的决定。99.9是double类型而9是int类型， double 容量高。,C
"(单选题)Java 中关于 if 语句描述错误的是（ ）
","[{'optionContent': 'A.if 语句是根据条件判断之后再做处理的一种语法结构\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'if 语句是根据条件判断之后再做处理的一种语法结构\n'}, {'optionContent': 'B.关键字 if 后小括号里面条件表达式的值必须为布尔类型\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '关键字 if 后小括号里面条件表达式的值必须为布尔类型\n'}, {'optionContent': 'C.if 后小括号里的表达式的值为 false 时，程序需要执行后面大括号里的语句\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'if 后小括号里的表达式的值为 false 时，程序需要执行后面大括号里的语句\n'}, {'optionContent': 'D.if 语句可以和 else 一起使用\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'if 语句可以和 else 一起使用\n'}]",if 后小括号里必须是一个条件表达式，结果为布尔值，如果为 true ，则执行后面大括号中的代码，如果为 false，则不执行 因此C是正确选项,C
"(单选题)下面的方法，当输入为2的时候返回值是多少?（） 
public static int getValue(int i) {         
int result = 0;         
switch (i) {        
case 1: 
            result = result + i;         
case 2: 
            result = result + i * 2;        
 case 3: 
            result = result + i * 3;         
} 
return result;    
} ","[{'optionContent': 'A.0', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0'}, {'optionContent': 'B.2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2'}, {'optionContent': 'C.4', 'isCorrect': '-1', 'option': 'C', 'optionValue': '4'}, {'optionContent': 'D.10', 'isCorrect': '-1', 'option': 'D', 'optionValue': '10'}]",注意这里case后面没有加break，所以从case 2开始一直往下运行。 result=0+2*2;//4 result=4+2*3;//10,D
"(单选题)给定代码：
public class SwitchTest{//1
    public static void main(String[] args) {//2
        System.out.println(""value=""+switchit(4));//3
    }//4
    public static int switchit(int x) {
        int j=1;
        switch (x) {
        case 1:j++;
        case 2:j++;
        case 3:j++;
        case 4:j++;
        case 5:j++;
        default:j++;
        }
        return j+x;
    }
}
第三行将输出什么？","[{'optionContent': 'A.value=6', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'value=6'}, {'optionContent': 'B.value=8', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'value=8'}, {'optionContent': 'C.value=3', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'value=3'}, {'optionContent': 'D.value=5', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'value=5'}]","没有break，从case 4开始一直执行到最后，j自加3次变成了4,结果返回8",B
"(单选题)以下程序的执行结果是（）：
public class SwitchTest {
  public static void main (String [] args) { 
    System.out.println (""value = "" + switchIt(4));
  }
  public static int switchIt(int x) {
    int j = 1;
    switch (x) {
      case 1: j++;
      case 2: j++; 
      case 3: j++; 
      case 4: j++; 
      case 5: j++; 
      default:j++;
    }
    return j + x;
  }
}","[{'optionContent': 'A.value = 5', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'value = 5'}, {'optionContent': 'B.value = 6', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'value = 6'}, {'optionContent': 'C.value = 7', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'value = 7'}, {'optionContent': 'D.value = 8', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'value = 8'}]",由于case语句没有最后没有break语句，那么从case 4：以下的代码都会被 执行。,D
"(单选题)选择下面代码的运行结果：（ ）
public class Test{
  public void method(){
    for(int i = 0; i < 3; i++){
      System.out.print(i);
    }
    System.out.print(i);
  }
}","[{'optionContent': 'A.0122', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0122'}, {'optionContent': 'B.0123', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0123'}, {'optionContent': 'C.编译错误', 'isCorrect': '-1', 'option': 'C', 'optionValue': '编译错误'}, {'optionContent': 'D.没有任何输出', 'isCorrect': '-1', 'option': 'D', 'optionValue': '没有任何输出'}]",i变量的作用范围是整个for循环中。,C
"(单选题)以下for循环的执行次数是（ ）。
for（int x=0,y=0;(y!=0)&&(x<4);x++）;
","[{'optionContent': 'A.无限次', 'isCorrect': '-1', 'option': 'A', 'optionValue': '无限次'}, {'optionContent': 'B.一次也不执行', 'isCorrect': '-1', 'option': 'B', 'optionValue': '一次也不执行'}, {'optionContent': 'C.执行四次', 'isCorrect': '-1', 'option': 'C', 'optionValue': '执行四次'}, {'optionContent': 'D.执行三次', 'isCorrect': '-1', 'option': 'D', 'optionValue': '执行三次'}]",(y!=0)&&(x,B
"(单选题)int j,k;
for(j=0,k=0;j<=9&&k!=876;j++){ 
System.out.println(""欢迎来到达内学习""); 
} 
此for循环语句执行的最大次数
","[{'optionContent': 'A.8', 'isCorrect': '-1', 'option': 'A', 'optionValue': '8'}, {'optionContent': 'B.9', 'isCorrect': '-1', 'option': 'B', 'optionValue': '9'}, {'optionContent': 'C.10', 'isCorrect': '-1', 'option': 'C', 'optionValue': '10'}, {'optionContent': 'D.0', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0'}]","此题目考查的是for循环,",C
"(单选题)下列代码哪行会出错（）
 1)  public void modify() {
 2)    int i, j, k;
 3)    i = 100;
 4)    while ( i > 0 ) {
 5)      j = i * 2;
 6)      System.out.println(""The value of j is "" + j);
 7)      k = k + 1;
 8)      i--;
 9)    }
10)  }","[{'optionContent': 'A.4', 'isCorrect': '-1', 'option': 'A', 'optionValue': '4'}, {'optionContent': 'B.6', 'isCorrect': '-1', 'option': 'B', 'optionValue': '6'}, {'optionContent': 'C.7', 'isCorrect': '-1', 'option': 'C', 'optionValue': '7'}, {'optionContent': 'D.8', 'isCorrect': '-1', 'option': 'D', 'optionValue': '8'}]",变量k没有被初始化,C
"(单选题)下列关于循环说法错误的是（ ）
","[{'optionContent': 'A.while 循环先判断后执行，do...while 先执行后判断\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'while 循环先判断后执行，do...while 先执行后判断\n'}, {'optionContent': 'B.do...while 循环结束的条件是 while 后的条件成立\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'do...while 循环结束的条件是 while 后的条件成立\n'}, {'optionContent': 'C.do...while 循环的循环体至少无条件执行一次\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'do...while 循环的循环体至少无条件执行一次\n'}, {'optionContent': 'D.for 语句构成的循环可以用其他循环语句替换\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'for 语句构成的循环可以用其他循环语句替换\n'}]",do...while 循环结束的条件是 while 后的条件不成立 因此B是正确选项,B
"(多选题)已知如下代码：
public class Test{
  public static void main(String arg[] ){
    int i = 5; 
    do{ 
      System.out.print(i);
    }while(--i>5);
    System.out.print(“finished”);
  }
}
执行后会输出（ ）","[{'optionContent': 'A.5', 'isCorrect': '-1', 'option': 'A', 'optionValue': '5'}, {'optionContent': 'B.4', 'isCorrect': '-1', 'option': 'B', 'optionValue': '4'}, {'optionContent': 'C.6', 'isCorrect': '-1', 'option': 'C', 'optionValue': '6'}, {'optionContent': 'D.finished', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'finished'}]",do?while循环中循环体一定会先执行一次,"A,D"
"(单选题)已知表达式 int m [ ] = {0, 1, 2, 3, 4, 5, 6}; 下面哪个表达式的值与数组下标量总数相等（ ）","[{'optionContent': 'A.m.length()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'm.length()'}, {'optionContent': 'B.m.length', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'm.length'}, {'optionContent': 'C.m.length()+1', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'm.length()+1'}, {'optionContent': 'D.m.length+1', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'm.length+1'}]",数组下标是从零开始的，但是数据下标的总量和数据长度相同。,B
(单选题)下面哪个是正确的（ ）,"[{'optionContent': 'A.String temp [] = new String {""a""""b""""c""};', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String temp [] = new String {""a""""b""""c""};'}, {'optionContent': 'B.String temp [] = {""a""""b""""c""};', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String temp [] = {""a""""b""""c""};'}, {'optionContent': 'C.String temp = {""a"", ""b"", ""c""};', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'String temp = {""a"", ""b"", ""c""};'}, {'optionContent': 'D.String temp [] = {""a"", ""b"", ""c""};', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'String temp [] = {""a"", ""b"", ""c""};'}]","数组声明初始化时前面的接收变量类型应该是数组类型，需要具有""[]""号， 且数组中每个元素都必须是统一指定类型，并且元素间需要使用"",""号分隔。",D
(多选题)下列选项中创建数组能够编译通过的是（ ）,"[{'optionContent': 'A.int[] ia = new int [15];', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int[] ia = new int [15];'}, {'optionContent': 'B.float fa = new float [20];', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'float fa = new float [20];'}, {'optionContent': 'C.char[] ca = ""Some String"";', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'char[] ca = ""Some String"";'}, {'optionContent': 'D.Object oa = new float[20];', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Object oa = new float[20];'}]",任何类的父类都是 Object，数组属于引用类型，Object oa = new float[20];这种写法相当于父类的引用指向子类的实例。,"A,D"
(多选题)下列说法错误的有(),"[{'optionContent': 'A.数组是一种对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': '数组是一种对象'}, {'optionContent': 'B.数组属于一种原生类', 'isCorrect': '-1', 'option': 'B', 'optionValue': '数组属于一种原生类'}, {'optionContent': 'C.int number=[]={31,23,33,43,35,63}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int number=[]={31,23,33,43,35,63}'}, {'optionContent': 'D.数组的大小可以任意改变', 'isCorrect': '-1', 'option': 'D', 'optionValue': '数组的大小可以任意改变'}]",数组不是原生类：int double boolean float byte short long char ，初始化多大就是多大,"B,C,D"
"(单选题)以下代码的执行结果是（）
public class Test {
  private static float[] f = new float[2]; 
  public static void main(String args[]) {
    System.out.println(""f[0] = "" + f[0]);
  }
}","[{'optionContent': 'A.f[0] = 0', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'f[0] = 0'}, {'optionContent': 'B.f[0] = 0.0', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'f[0] = 0.0'}, {'optionContent': 'C.代码不能通过编译', 'isCorrect': '-1', 'option': 'C', 'optionValue': '代码不能通过编译'}, {'optionContent': 'D.程序运行时出错', 'isCorrect': '-1', 'option': 'D', 'optionValue': '程序运行时出错'}]",float型数组中的元素都是float，默认初始值是0.0。,B
"(单选题)执行完以下代码 int [ ]	x = new	int[25]; 后，
以下哪项说明是正确的（ ）","[{'optionContent': 'A.x[24]为 0', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'x[24]为 0'}, {'optionContent': 'B.x[24]未定义', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'x[24]未定义'}, {'optionContent': 'C.x[25]为 0', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'x[25]为 0'}, {'optionContent': 'D.x[0]为空', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'x[0]为空'}]",x属于引用类型，该引用类型的每一个成员是int类型，默认值为：0,A
"(单选题)下列数组的初始化正确的是（）
","[{'optionContent': 'A.int[ ] score = new int[ ];\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int[ ] score = new int[ ];\n'}, {'optionContent': 'B.int score[ ] = new int[ ] { 34, 90, 87, 54, 24 };\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int score[ ] = new int[ ] { 34, 90, 87, 54, 24 };\n'}, {'optionContent': 'C.int[ ] score = new int[ 4 ] { 90, 12, 34, 77 };\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int[ ] score = new int[ 4 ] { 90, 12, 34, 77 };\n'}, {'optionContent': 'D.int score = { 78, 23, 44, 78 }；\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'int score = { 78, 23, 44, 78 }；\n'}]","选项 A 需要指定数组的长度；选项 C 在声明数组的同时赋值时不能指定数组长度；选项 D 声明数组的语法错误，应为int[ ] score={ 78, 23, 44, 78 }； 因此选择 B",B
"(单选题)当编译并运行下面程序时会出现什么结果( )
public class MyAr{ 
     public static void main(String argv[]){
           int[] i = new int[5];
            System.out.println(i[5]);
      } 
} ","[{'optionContent': 'A.编译错误', 'isCorrect': '-1', 'option': 'A', 'optionValue': '编译错误'}, {'optionContent': 'B.运行错误', 'isCorrect': '-1', 'option': 'B', 'optionValue': '运行错误'}, {'optionContent': 'C.输出0', 'isCorrect': '-1', 'option': 'C', 'optionValue': '输出0'}, {'optionContent': 'D.输出“null”', 'isCorrect': '-1', 'option': 'D', 'optionValue': '输出“null”'}]",这里会发生运行错误，错误原因是访问数组下标越界了,B
"(单选题)定义一个数组 int[ ] scores = { 1, 2, 3, 4, 5, 6, 7 } ，数组中的 score[3] 指的是
","[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '4'}]",数组下标从 0 开始，因此 score[3] 表示数组中的第 4 个元素 因此D是正切选项,D
"(单选题)对记录序列{314，298，508，123，486，145}按从小到大的顺序进行插入排
序，经过两趟排序后的结果为（）","[{'optionContent': 'A.{314，298，508，123，145，486}', 'isCorrect': '-1', 'option': 'A', 'optionValue': '{314，298，508，123，145，486}'}, {'optionContent': 'B.{298，314，508，123，486，145}', 'isCorrect': '-1', 'option': 'B', 'optionValue': '{298，314，508，123，486，145}'}, {'optionContent': 'C.{298，123，314，508，486，145}', 'isCorrect': '-1', 'option': 'C', 'optionValue': '{298，123，314，508，486，145}'}, {'optionContent': 'D.{123、298，314，508，486，145}', 'isCorrect': '-1', 'option': 'D', 'optionValue': '{123、298，314，508，486，145}'}]",此题为插入排序算法，代码如下： public static void injectionSort(int[] number) { // 第一个元素作为一部分，对后面的部分进行循环 for (int j = 1; j < number.length; j++) { int tmp = number[j]; int i = j - 1; while (tmp < number[i]) { number[i + 1] = number[i]; i--; if (i == -1) break; } number[i + 1] = tmp; } },B
(单选题)下列有关实参和形参说法正确的是（）,"[{'optionContent': 'A.形参是指在定义方法时参数列表中的参数\n实参是指在调用方法时所传入的实际数据', 'isCorrect': '-1', 'option': 'A', 'optionValue': '形参是指在定义方法时参数列表中的参数\n实参是指在调用方法时所传入的实际数据'}, {'optionContent': 'B.形参变量的作用域是在整个类中都可以使用', 'isCorrect': '-1', 'option': 'B', 'optionValue': '形参变量的作用域是在整个类中都可以使用'}, {'optionContent': 'C.实参只能是字面量值不可以是变量', 'isCorrect': '-1', 'option': 'C', 'optionValue': '实参只能是字面量值不可以是变量'}, {'optionContent': 'D.形参不可以用 final 修饰', 'isCorrect': '-1', 'option': 'D', 'optionValue': '形参不可以用 final 修饰'}]",形参是指在定义方法时参数列表中的参数，实参是指在调用方法时所传入的实际数据。 形参是局部变量，作用域在方法体内，出了方法后不可见。 实参可以是字面量常量值也可以是变量，只要是可以在调用方法时传入的数据就是实参。 形参是可以用 final 来修饰的，被 final 修饰的形参被赋初值后值不可以再改变。 所以 A 正确。,A
"(单选题)关于 Java 类中带参数的方法，下列选项中说法错误的是
","[{'optionContent': 'A.使用带参数的方法分为两步：定义带参数的方法，调用带参数的方法\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '使用带参数的方法分为两步：定义带参数的方法，调用带参数的方法\n'}, {'optionContent': 'B.带参数方法的返回值不能为 void\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '带参数方法的返回值不能为 void\n'}, {'optionContent': 'C.带参数方法的参数个数可以为一个或多个\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '带参数方法的参数个数可以为一个或多个\n'}, {'optionContent': 'D.带参数方法的参数可以是任意的基本类型数据或引用类型数据\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '带参数方法的参数可以是任意的基本类型数据或引用类型数据\n'}]",带参数方法的返回值可以为 void 因此B是正确的选项。,B
"(单选题)判断方法重载的依据，错误的是：
","[{'optionContent': 'A.必须在同一个类中\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '必须在同一个类中\n'}, {'optionContent': 'B.方法名不同\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '方法名不同\n'}, {'optionContent': 'C.方法参数的个数、顺序或类型不同\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '方法参数的个数、顺序或类型不同\n'}, {'optionContent': 'D.与方法的修饰符或返回值没有关系\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '与方法的修饰符或返回值没有关系\n'}]",方法重载必须是相同的方法名 因此B是正确的选项。,B
(单选题)Spring的组成一共有（ ）块组成,"[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.3', 'isCorrect': '-1', 'option': 'B', 'optionValue': '3'}, {'optionContent': 'C.5', 'isCorrect': '-1', 'option': 'C', 'optionValue': '5'}, {'optionContent': 'D.7', 'isCorrect': '-1', 'option': 'D', 'optionValue': '7'}]","Spring框架有七个模块组成，分别是：
Spring 核心容器（Core）
Spring AOP
Spring ORM
Spring DAO
Spring WEB
Spring上下文（Context）
Spring MVC",D
(单选题)下面关于spring描述错误的是：（ ）,"[{'optionContent': 'A.Spring支持可插入的事务管理器，使事务划分更轻松，同时无需处理底层的问题。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Spring支持可插入的事务管理器，使事务划分更轻松，同时无需处理底层的问题。'}, {'optionContent': 'B.Spring事务管理的通用抽象层还包括JTA策略和一个JDBC DataSource。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Spring事务管理的通用抽象层还包括JTA策略和一个JDBC DataSource。'}, {'optionContent': 'C.Spring的事务支持且依赖于Java EE环境。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Spring的事务支持且依赖于Java EE环境。'}, {'optionContent': 'D.Spring事务语义通过AOP应用于 POJO，通过XML或Java SE 5注释进行配置。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Spring事务语义通过AOP应用于 POJO，通过XML或Java SE 5注释进行配置。'}]",Spring的事务支持并不依赖于Java EE环境,C
(多选题)下面关于Spring的说法正确的是（ ）,"[{'optionContent': 'A.Spring是一个重量级的框架', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Spring是一个重量级的框架'}, {'optionContent': 'B.Spring是一个轻量级的框架', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Spring是一个轻量级的框架'}, {'optionContent': 'C.Spring是一个包含IOC和AOP两大特性的容器', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Spring是一个包含IOC和AOP两大特性的容器'}, {'optionContent': 'D.Spring是一个入侵式的框架', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Spring是一个入侵式的框架'}]",Spring是一个轻量级框架，主要的两个模块是Spring IOC和Spring AOP,"B,C"
(多选题)下列关于Spring说法正确的有（ ）。,"[{'optionContent': 'A.Spring是一个开源的轻量级的应用开发框架。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Spring是一个开源的轻量级的应用开发框架。'}, {'optionContent': 'B.Spring为系统提供了一个整体解决方案。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Spring为系统提供了一个整体解决方案。'}, {'optionContent': 'C.Spring是一种开发语言。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Spring是一种开发语言。'}, {'optionContent': 'D.Spring提供的IOC和AOP功能，可以将组件的耦合度降至最低，即解耦，便于系统日后的维护和升级。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Spring提供的IOC和AOP功能，可以将组件的耦合度降至最低，即解耦，便于系统日后的维护和升级。'}]","此题目考查的是对Spring框架的基本认识。
Spring是应用开发框架，而不一种编程语言，所以C是错误的。其它选项是从不同角度描述Spring框架的优点，都是正确的。","A,B,D"
"(多选题)对于以下配置，说法正确的是（ ）。
<bean id=""cal"" class=""java.util.GregorianCalendar""/>
<bean id=""dateObj"" factory-bean=""cal""
	factory-method=""getTime""/>","[{'optionContent': 'A.id用于指定Bean名称。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'id用于指定Bean名称。'}, {'optionContent': 'B.factory-bean属性用于指定工厂Bean对象。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'factory-bean属性用于指定工厂Bean对象。'}, {'optionContent': 'C.factory-method属性用于指定工厂中创建Bean对象的方法。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'factory-method属性用于指定工厂中创建Bean对象的方法。'}, {'optionContent': 'D.factory-method指定的方法必须是静态方法。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'factory-method指定的方法必须是静态方法。'}]","此题目考查的是对实例工厂方法创建bean实例的基本知识的掌握。
答案D有一定干扰作用，静态工厂方法才有此要求。","A,B,C"
(多选题)下列关于Spring容器说法正确的是（ ）。,"[{'optionContent': 'A.在Spring中，任何的Java类和JavaBean都可以被当成Bean处理，这些Bean通过容器管理和使用。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '在Spring中，任何的Java类和JavaBean都可以被当成Bean处理，这些Bean通过容器管理和使用。'}, {'optionContent': 'B.Spring容器实现了IOC和AOP机制，这些机制可以简化Bean对象创建和Bean对象之间的解耦。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Spring容器实现了IOC和AOP机制，这些机制可以简化Bean对象创建和Bean对象之间的解耦。'}, {'optionContent': 'C.Spring容器提供了运行Servlet所需要的环境。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Spring容器提供了运行Servlet所需要的环境。'}, {'optionContent': 'D.Spring容器有BeanFactory和ApplicationContext等类型。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Spring容器有BeanFactory和ApplicationContext等类型。'}]",此题目考查的是对Spring容器的基本认识。运行Servlet需要符合Servlet规范的容器，比如Tomcat。 Spring容器是Spring框架的核心组成模块，其它选项从各个方面描述了Spring容器的一些特点，故是正确的。,"A,B,D"
"(多选题)对于以下配置，说法正确的是（ ）。
<bean id=""eb1"" class=""ioc.ExampleBean"" 
		init-method=""init"" 
destroy-method=""destroy"" lazy-init=""true""></bean>","[{'optionContent': 'A.init-method用于指定初始化方法。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'init-method用于指定初始化方法。'}, {'optionContent': 'B.destroy-method用于指定销毁方法。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'destroy-method用于指定销毁方法。'}, {'optionContent': 'C.所有bean中的初始化方法名必须命名为init。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '所有bean中的初始化方法名必须命名为init。'}, {'optionContent': 'D.lazy-init如果为true,表示延迟实例化。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'lazy-init如果为true,表示延迟实例化。'}]",考查容器如何管理bean的生命周期。初始化方法和销毁方法的命名无特定要求，故C是错误的。,"A,B,D"
(多选题)下列关于bean的作用域，说法正确的是（ ）。,"[{'optionContent': 'A.singleton表示一个bean定义对应一个实例。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'singleton表示一个bean定义对应一个实例。'}, {'optionContent': 'B.prototype表示一个bean定义对应多个实例。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'prototype表示一个bean定义对应多个实例。'}, {'optionContent': 'C.prototype是缺省值。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'prototype是缺省值。'}, {'optionContent': 'D.singleton是缺省值。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'singleton是缺省值。'}]",容器在默认情况下，一个bean定义只会创建一个实例，即缺省值为singleton。,"A,B,D"
(多选题)下列关于bean的生命周期，说法正确的是（ ）。,"[{'optionContent': 'A.每个bean都必须提供相应的生命周期方法。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '每个bean都必须提供相应的生命周期方法。'}, {'optionContent': 'B.销毁方法只适用于singleton模式的bean。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '销毁方法只适用于singleton模式的bean。'}, {'optionContent': 'C.销毁方法可以运行多次。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '销毁方法可以运行多次。'}, {'optionContent': 'D.初始化方法只会执行一次。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '初始化方法只会执行一次。'}]",考查容器如何管理bean的生命周期。在设计bean时，依据实际业务的需要，可以为bean提供相应的生命周期方法，比如在初始化方法当中完成资源加载等类似的逻辑，在销毁方法中释放资源。因此bean当中是否有生命周期相关的方法，完成取决于实际业务需要，并不是必须的，所以答案A是错误的。销毁方法用于释放资源，只需要执行一次，所以答案C也是错误的。,"B,D"
(单选题)下列关于Spring特性中IOC描述错误的是：（）,"[{'optionContent': 'A.IOC就是指程序之间的关系由程序代码直接操控。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'IOC就是指程序之间的关系由程序代码直接操控。'}, {'optionContent': 'B.所谓“控制反转”,是指控制权由应用代码转到外部容器，控制权的转移', 'isCorrect': '-1', 'option': 'B', 'optionValue': '所谓“控制反转”,是指控制权由应用代码转到外部容器，控制权的转移'}, {'optionContent': 'C.IOC将控制创建的职责搬进了框架中；并把它从应用代码脱离开来', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'IOC将控制创建的职责搬进了框架中；并把它从应用代码脱离开来'}, {'optionContent': 'D.当使用Spring的IOC容器时只需指出组件需要的对象，在运行时Spring的IOC容器会根据XML配置数据提供给它。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '当使用Spring的IOC容器时只需指出组件需要的对象，在运行时Spring的IOC容器会根据XML配置数据提供给它。'}]",IOC是控制反转，是将代码中的操控权转到容器里去控制,A
(多选题)下面关于IOC的理解，正确的是（ ）,"[{'optionContent': 'A.控制反转', 'isCorrect': '-1', 'option': 'A', 'optionValue': '控制反转'}, {'optionContent': 'B.对象被动的接受依赖类', 'isCorrect': '-1', 'option': 'B', 'optionValue': '对象被动的接受依赖类'}, {'optionContent': 'C.对象主动的去找依赖类', 'isCorrect': '-1', 'option': 'C', 'optionValue': '对象主动的去找依赖类'}, {'optionContent': 'D.一定要用接口', 'isCorrect': '-1', 'option': 'D', 'optionValue': '一定要用接口'}]",Spring IOP即“控制反转”，对象只是被动的接收依赖对象,"A,B"
(单选题)下列哪些语句关于内存回收的说明是正确的（ ）,"[{'optionContent': 'A.程序员必须创建一个线程来释放内存', 'isCorrect': '-1', 'option': 'A', 'optionValue': '程序员必须创建一个线程来释放内存'}, {'optionContent': 'B.内存回收程序负责释放无用内存', 'isCorrect': '-1', 'option': 'B', 'optionValue': '内存回收程序负责释放无用内存'}, {'optionContent': 'C.内存回收程序允许程序员直接释放内存', 'isCorrect': '-1', 'option': 'C', 'optionValue': '内存回收程序允许程序员直接释放内存'}, {'optionContent': 'D.内存回收程序可以在指定的时间释放内存对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '内存回收程序可以在指定的时间释放内存对象'}]","垃圾收集器在一个 Java 程序中的执行是自动的，不能强制执行，即使程序员能明确地判断出有一块内存已经无用了，是应该回收的，程序员也不能强制垃圾收集器回收该内存块。程序员唯一能做的就是通过调用 System.gc()方法来""建议""垃圾收集器去进行垃圾回收处理，但其是否可以执行，什么时候执行却都是不可知的。",B
(单选题)栈是一种（ ）,"[{'optionContent': 'A.存取受限的线性结构', 'isCorrect': '-1', 'option': 'A', 'optionValue': '存取受限的线性结构'}, {'optionContent': 'B.存取不受限的线性结构', 'isCorrect': '-1', 'option': 'B', 'optionValue': '存取不受限的线性结构'}, {'optionContent': 'C.存取受限的非线性结构', 'isCorrect': '-1', 'option': 'C', 'optionValue': '存取受限的非线性结构'}, {'optionContent': 'D.存取不受限的非线性结构', 'isCorrect': '-1', 'option': 'D', 'optionValue': '存取不受限的非线性结构'}]",栈（stack）在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。,A
(单选题)在Java语言中，被称为内存分配的运算符是（）,"[{'optionContent': 'A.new', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'new'}, {'optionContent': 'B.instance of', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'instance of'}, {'optionContent': 'C.[]', 'isCorrect': '-1', 'option': 'C', 'optionValue': '[]'}, {'optionContent': 'D.()', 'isCorrect': '-1', 'option': 'D', 'optionValue': '()'}]",Java语言中，程序为对象动态分配内存。Java中内存分配的运算符是new。,A
(单选题)NAT三种实现方式不包含哪个？,"[{'optionContent': 'A.静态转换\n\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '静态转换\n\n'}, {'optionContent': 'B.动态转换\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '动态转换\n'}, {'optionContent': 'C.端口多路复用\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '端口多路复用\n'}, {'optionContent': 'D.多对一转换', 'isCorrect': '-1', 'option': 'D', 'optionValue': '多对一转换'}]",静态转换，一对一，不节省IP，但隐藏主机真实ip；动态转换，多对多，一定程度上节省了ip，但是当内部网路用户大于真实外部转换ip时就不适用了；端口多路复用，多对一，使内部主机共享一个外部IP，最大程度上节省了IP。,D
(单选题)子网掩码的作用是？,"[{'optionContent': 'A.判断某一ip属于哪一个网络\n\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '判断某一ip属于哪一个网络\n\n'}, {'optionContent': 'B.查看主机位\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '查看主机位\n'}, {'optionContent': 'C.查看网络位\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '查看网络位\n'}, {'optionContent': 'D.无作用', 'isCorrect': '-1', 'option': 'D', 'optionValue': '无作用'}]",子网掩码在二进制表示下，网络位全为1，主机位全为0，用于判断某一个IP属于哪一个网络。,A
(单选题)NAT（网络地址转换）的优点不正确的是？,"[{'optionContent': 'A.节省IP资源\n\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '节省IP资源\n\n'}, {'optionContent': 'B.灵活性强\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '灵活性强\n'}, {'optionContent': 'C.安全\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '安全\n'}, {'optionContent': 'D.配置简单', 'isCorrect': '-1', 'option': 'D', 'optionValue': '配置简单'}]",NAT地址转换优点在于节省IP资源、灵活、安全、处理地址重叠，但是配置复杂。,D
(单选题)新窗口打开网页，用到以下哪个值（）。,"[{'optionContent': 'A._self\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '_self\n'}, {'optionContent': 'B._blank', 'isCorrect': '-1', 'option': 'B', 'optionValue': '_blank'}, {'optionContent': 'C._top', 'isCorrect': '-1', 'option': 'C', 'optionValue': '_top'}, {'optionContent': 'D._parent', 'isCorrect': '-1', 'option': 'D', 'optionValue': '_parent'}]","_self 在当前窗口打开网页
_blank 在新窗口打开网页
_top 在当前窗口打开网页，并且替换当前窗口的整个网页
_parent 在父窗口中打开网页",B
(单选题)下列属性中，不是 <a> 元素有效属性的是（）。,"[{'optionContent': 'A.src', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'src'}, {'optionContent': 'B.href', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'href'}, {'optionContent': 'C.name', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'name'}, {'optionContent': 'D.target', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'target'}]",基本概念题，标签中没有src这个属性,A
(多选题)以下关于hashCode说法正确的是（ ）,"[{'optionContent': 'A.两个对象如果hashCode值不同，则两个对象可能相同。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '两个对象如果hashCode值不同，则两个对象可能相同。'}, {'optionContent': 'B.两个对象如果hashCode值相同，则两个对象必定相同。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '两个对象如果hashCode值相同，则两个对象必定相同。'}, {'optionContent': 'C.两个对象如果hashCode值相同，则两个对象可能相同。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '两个对象如果hashCode值相同，则两个对象可能相同。'}, {'optionContent': 'D.两个对象如果hashCode值不同，则两个对象必定不同。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '两个对象如果hashCode值不同，则两个对象必定不同。'}]",先通过 hashcode 来判断某个对象是否存放某个桶里，但这个桶里可能有很多对象，那么我们就需要再通过 equals 来在这个桶里找到我们要的对象。,"C,D"
(单选题)列表分为两类，一是无序列表，一是有序列表，以下哪个是无序列表？,"[{'optionContent': 'A.<UL>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<UL>'}, {'optionContent': 'B.<OL>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<OL>'}, {'optionContent': 'C.<DIR>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<DIR>'}, {'optionContent': 'D.<DL>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<DL>'}]",无序列表；有序列表。,A
(单选题)列表分为两类，一是无序列表，一是有序列表，以下哪个是有序列表？,"[{'optionContent': 'A.ul', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'ul'}, {'optionContent': 'B.dl', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'dl'}, {'optionContent': 'C.li', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'li'}, {'optionContent': 'D.ol', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ol'}]","ul 无序列表 
ol 有序列表 
li 定义列表项目 
dl 定义列表",D
"(单选题)两实体类代码如下：
public class Wage{ //月工资实体类
private Long wid;
private String empName; //雇员姓名
private String month; //月份
//Getter & Setter
……
}
public class WageItem{ //工资项
private Wage wage;
private Long iid;
private String itemName; //项目名称,如基本工资、职位津贴等
private String amount; //数额
//Getter & Setter
……
}
其中的WageItem 实体类有如下配置，其中空白处应填入的代码是（ ）。
<class name=""WageItem"" table=""fin_wage_item""
<id name=""iid"" column=""wi_id"" type=""java.lang.Long"">
<generator class=""native"" ></generator>
</id>
<property name=""itemName"" column=""wi_name""
type=""java.lang.String"" ></property>
<property name=""amount"" column=""wi_amount""
type=""java.lang.Double"" ></property>
<!--配置wage 属性-->
______________________
</class>","[{'optionContent': 'A.<many-to-one name=""wage"" column=""wi_wage_id"" class=""Wage"" ></many>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<many-to-one name=""wage"" column=""wi_wage_id"" class=""Wage"" ></many>'}, {'optionContent': 'B.<one-to-many name=""wage"" column=""wi_wage_id"" class=""Wage"" ></one>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<one-to-many name=""wage"" column=""wi_wage_id"" class=""Wage"" ></one>'}, {'optionContent': 'C.<set name=""wage"">\n<key column=""wi_wage_id"" ></key>\n<one-to-many class=""Wage"" ></one>\n</set>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<set name=""wage"">\n<key column=""wi_wage_id"" ></key>\n<one-to-many class=""Wage"" ></one>\n</set>'}, {'optionContent': 'D.<set name=""wage"">\n<key column="" wi_wage_id"" ></key>\n<many-to-one class=""Wage"" ></many>\n</set>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<set name=""wage"">\n<key column="" wi_wage_id"" ></key>\n<many-to-one class=""Wage"" ></many>\n</set>'}]","many-to-one属性是多对一映射
one-to-many属性是一对多映射
题干中并没有说wage是需要用set去存所以cd是错的",A
"(单选题)下面是某系统中的两个实体类，依此可以得知（ ）。
public class Wage{ //月工资实体类
private Long wid;
private String empName; //雇员姓名
private String month; //月份
//Getter & Setter
……
}
public class WageItem{ //工资项
private Wage wage;
private Long iid;
private String itemName; //项目名称,如基本工资、职位津贴等
private String amount; //数额
//Getter & Setter
……
}","[{'optionContent': 'A.Wage 和WageItem 间存在单向一对多的关联', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Wage 和WageItem 间存在单向一对多的关联'}, {'optionContent': 'B.Wage 和WageItem 间存在单向多对一的关联', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Wage 和WageItem 间存在单向多对一的关联'}, {'optionContent': 'C.Wage 和WageItem间存在双向一对多的关联', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Wage 和WageItem间存在双向一对多的关联'}, {'optionContent': 'D.Wage 和WageItem间存在双向多对一的关联', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Wage 和WageItem间存在双向多对一的关联'}]",仔细看题干，wage与WageItem中关联的属性是多对一,B
(多选题)下列属于多对一关系的是（ ）。,"[{'optionContent': 'A.书和作者', 'isCorrect': '-1', 'option': 'A', 'optionValue': '书和作者'}, {'optionContent': 'B.手机和生产厂家', 'isCorrect': '-1', 'option': 'B', 'optionValue': '手机和生产厂家'}, {'optionContent': 'C.用户和发布的出租信息', 'isCorrect': '-1', 'option': 'C', 'optionValue': '用户和发布的出租信息'}, {'optionContent': 'D.士兵和班长', 'isCorrect': '-1', 'option': 'D', 'optionValue': '士兵和班长'}]",AC是一对多,"B,D"
"(多选题)针对以下配置，说法正确的是（ ）。
<context:component-scan 
              base-package=""com.tarena""/> ","[{'optionContent': 'A.这是配置组件扫描。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '这是配置组件扫描。'}, {'optionContent': 'B.容器只会扫描com.tarena的包下面的类。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '容器只会扫描com.tarena的包下面的类。'}, {'optionContent': 'C.容器会扫描com.tarena包及其子包下面的类。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '容器会扫描com.tarena包及其子包下面的类。'}, {'optionContent': 'D.组件扫描可以替代大量XML配置的<bean>定义。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '组件扫描可以替代大量XML配置的<bean>定义。'}]",本题考查组件扫描的基本配置，要注意，容器会扫描指定包及其子包下面的所有类，如果这些类包含了特定的注解，容器会将其纳入容器进行管理，所以B是错误的。注解的好处之一，就是简化了配置文件，所以D是正确的。,"A,C,D"
(单选题)<table>标签中，哪个是表格边框线的粗细？,"[{'optionContent': 'A.bordercolor', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'bordercolor'}, {'optionContent': 'B.border', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'border'}, {'optionContent': 'C.cellspacing', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'cellspacing'}, {'optionContent': 'D.cellpadding', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'cellpadding'}]",bordercolor表示边框颜色； cellspacing表示单元格之间的间隔； cellpadding表示单元格内边距。,B
(单选题)网页开发中，一般需判断浏览器类型，需通过userAgent中获取浏览器内核来判断，下列说法错误的是？,"[{'optionContent': 'A.一直到IE9，都是Trident内核', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一直到IE9，都是Trident内核'}, {'optionContent': 'B.firefox是Gecko内核', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'firefox是Gecko内核'}, {'optionContent': 'C.chrome是webkit内核', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'chrome是webkit内核'}, {'optionContent': 'D.IE是目前最快的浏览器', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'IE是目前最快的浏览器'}]",主流浏览器内核 ie:Trient内核 chrome safari：webkit内核 firefox：Gecko内核 opera：presto内核 经排除所以选D,D
"(单选题)下列哪个样式定义后,内联(非块状)元素可以定义宽度和高度","[{'optionContent': 'A.display:inline', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'display:inline'}, {'optionContent': 'B.display:none', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'display:none'}, {'optionContent': 'C.display:block', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'display:block'}, {'optionContent': 'D.display:inherit', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'display:inherit'}]",display属性 : block :　CSS1 块对象的默认值。将对象强制作为块对象呈递，为对象之后添加新行 可以定义高度和宽度 none :　CSS1 隐藏对象。与 visibility 属性的hidden值不同，其不为被隐藏的对象保留其物理空间 inline :　CSS1 内联对象的默认值。将对象强制作为内联对象呈递，从对象中删除行 inline-block :　IE5.5 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内 inherit: 看display默认是不具备继承性的，使用inherit可以让其继承父对象的display属性。,C
(单选题)css中clear的作用是什么？,"[{'optionContent': 'A.清除该元素所有样式', 'isCorrect': '-1', 'option': 'A', 'optionValue': '清除该元素所有样式'}, {'optionContent': 'B.清楚该元素父元素的所有样式', 'isCorrect': '-1', 'option': 'B', 'optionValue': '清楚该元素父元素的所有样式'}, {'optionContent': 'C.指明该元素周围不可出现浮动元素', 'isCorrect': '-1', 'option': 'C', 'optionValue': '指明该元素周围不可出现浮动元素'}, {'optionContent': 'D.指明该元素的父元素周围不可出现浮动元素', 'isCorrect': '-1', 'option': 'D', 'optionValue': '指明该元素的父元素周围不可出现浮动元素'}]",对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。,C
(单选题)如何在CSS文件中插入注释？,"[{'optionContent': 'A.//this is a comment', 'isCorrect': '-1', 'option': 'A', 'optionValue': '//this is a comment'}, {'optionContent': 'B.//this is a comment//', 'isCorrect': '-1', 'option': 'B', 'optionValue': '//this is a comment//'}, {'optionContent': 'C./*this is a comment*/', 'isCorrect': '-1', 'option': 'C', 'optionValue': '/*this is a comment*/'}, {'optionContent': 'D.’this is a comment', 'isCorrect': '-1', 'option': 'D', 'optionValue': '’this is a comment'}]",一般在CSS文件中，注释是采用/**/的方式。,C
(多选题)关于html的盒模型，下列说法正确的是？,"[{'optionContent': 'A.margin是内边距', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'margin是内边距'}, {'optionContent': 'B.padding是外边距', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'padding是外边距'}, {'optionContent': 'C.border是边框', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'border是边框'}, {'optionContent': 'D.border-radius是css3标准，因此IE并不支持border-radius属性', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'border-radius是css3标准，因此IE并不支持border-radius属性'}]",margin:外边距； padding：内边距； border：边框； IE不支持边框圆角border-radius属性,"C,D"
"(单选题)下面span标签中Hello World字体的颜色是：（）
<style type=""text/css"">
span {
    color: green;
}
.red {
    color: red;
}
#blue {
    color: blue;
}
</style>
 
<span id=""blue"" class=""red"" style=""color:black;"">Hello World</span>","[{'optionContent': 'A.green', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'green'}, {'optionContent': 'B.red', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'red'}, {'optionContent': 'C.blue', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'blue'}, {'optionContent': 'D.black', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'black'}]","因为最后是有“style=""color:black;""”所决定的。",D
(单选题)下面哪条声明能固定背景图片（）,"[{'optionContent': 'A.background-attachment:fixed;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'background-attachment:fixed;'}, {'optionContent': 'B.background-attachment:scroll;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'background-attachment:scroll;'}, {'optionContent': 'C.background-origin: initial;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'background-origin: initial;'}, {'optionContent': 'D.background-clip: initial;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'background-clip: initial;'}]",background-attachment 有三个值，scroll是默认值，背景图像会随着页面其余部分的滚动而移动。 fixed当页面的其余部分滚动时，背景图像不会移动。 inherit规定应该从父元素继承 background-attachment 属性的设置。 background-origin 属性规定 background-position 属性相对于什么位置来定位。 background-clip 属性规定背景的绘制区域。,A
(单选题)英文字母全部转为大写正确的是（）,"[{'optionContent': 'A.text-transform: capitalize;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'text-transform: capitalize;'}, {'optionContent': 'B.text-transform: lowercase;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'text-transform: lowercase;'}, {'optionContent': 'C.text-transform: uppercase;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'text-transform: uppercase;'}, {'optionContent': 'D.font-weight: bold;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'font-weight: bold;'}]",text-transform:capitalize是首字母大写 text-transfrom:lowercase是全部字母为小写 text-transfrom:uppercase是全部字母为大写 font-weight: bold;字体为粗体，,C
(多选题)在使用table表现数据时，有时候表现出来的会比自己实际设置的宽度要宽，为此需要设置下面哪些属性值？,"[{'optionContent': 'A.cellpadding=”0″', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'cellpadding=”0″'}, {'optionContent': 'B.padding:0', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'padding:0'}, {'optionContent': 'C.margin:0', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'margin:0'}, {'optionContent': 'D.cellspacing=”0″', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'cellspacing=”0″'}]","单元格边距(表格填充)(cellpadding) -- 代表单元格外面的一个距离,用于隔开单元格与单元格空间单； 元格间距(表格间距)(cellspacing) -- 代表表格边框与单元格补白的距离,也是单元格补白之间的距离。","A,D"
(单选题)以下哪一条Javascript语句会产生运行错误？,"[{'optionContent': 'A.var obj=( );', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'var obj=( );'}, {'optionContent': 'B.var obj=[ ];', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'var obj=[ ];'}, {'optionContent': 'C.var obj={ };', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'var obj={ };'}, {'optionContent': 'D.var obj=/ /;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'var obj=/ /;'}]",A，错误 B，声明obj为数组对象 C，声明obj为对象 D，声明obj为正则对象,A
(单选题)关于javascript的原始类型（primitive type），错误的是,"[{'optionContent': 'A.有5种primitive type，\n分别是Undefined、Null、Boolean、Number 和 String。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '有5种primitive type，\n分别是Undefined、Null、Boolean、Number 和 String。'}, {'optionContent': 'B.var sTemp = ""test string"";\nalert (typeof sTemp);\n结果为string', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'var sTemp = ""test string"";\nalert (typeof sTemp);\n结果为string'}, {'optionContent': 'C.var oTemp;\nalert(oTemp == undefined);\n结果为true', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'var oTemp;\nalert(oTemp == undefined);\n结果为true'}, {'optionContent': 'D.alert(null == undefined);\n结果为false', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'alert(null == undefined);\n结果为false'}]",undefined值是通过null派生出来的，==时它会自动转化为null，所以返回true。不过如果用严格比较符===，不发生转化，将返回false。,D
(多选题)下面属于javascript基本数据类型的有？,"[{'optionContent': 'A.字符串', 'isCorrect': '-1', 'option': 'A', 'optionValue': '字符串'}, {'optionContent': 'B.数字', 'isCorrect': '-1', 'option': 'B', 'optionValue': '数字'}, {'optionContent': 'C.null', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'null'}, {'optionContent': 'D.undefined', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'undefined'}]",js五种基本类型：String Boolean Number null undefined,"A,B,C,D"
"(单选题)以下为一段浏览器中可运行的Javascript 代码，则运行该段Javascript代码的页面弹出框中显示的结果是：（）
var obj = {""key"":""1"",""value"":""2""};
var newObj = obj;
newObj.value += obj.key;
alert(obj.value);","[{'optionContent': 'A.2', 'isCorrect': '-1', 'option': 'A', 'optionValue': '2'}, {'optionContent': 'B.12', 'isCorrect': '-1', 'option': 'B', 'optionValue': '12'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.21', 'isCorrect': '-1', 'option': 'D', 'optionValue': '21'}]",newObj.value = 2; obj.key = '1'; newObj.value += obj.key; 相当于 newObj.value = newObj.value + obj.key; 所以 '2' + 1 在javascript中自动转化为字符串拼接操作得到 '21',D
(单选题)代码：var result = NaN < 0; 结果为( ),"[{'optionContent': 'A.0', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0'}, {'optionContent': 'B.NaN', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'NaN'}, {'optionContent': 'C.false', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'false'}, {'optionContent': 'D.true', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'true'}]","NaN与任何操作数进行关系比较,结果都是false。 所以选C",C
(单选题)下列JS的判断语句中正确的是（ ）,"[{'optionContent': 'A.if(i==0)', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'if(i==0)'}, {'optionContent': 'B.if(i=0)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'if(i=0)'}, {'optionContent': 'C.if i==0 then', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'if i==0 then'}, {'optionContent': 'D.if i=0 then', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'if i=0 then'}]",js中判断值相等使用==或=== ==会默认将两个比较数据的类型转为相同后比较值是否相等 ===会先比较类型 类型不同直接返回false A选项正确,A
"(单选题)下列代码：
var person={fname:""John"",lname:""Doe"",age:25};
var txt="""";
for (x in person){
  txt=txt + person[x];
}
alert(txt);
输出为？","[{'optionContent': 'A.JohnDoe25', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'JohnDoe25'}, {'optionContent': 'B.fname:""John"",lname:""Doe"",age:25', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'fname:""John"",lname:""Doe"",age:25'}, {'optionContent': 'C.fname:John,lname:Doe,age:25', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'fname:John,lname:Doe,age:25'}, {'optionContent': 'D.fnamelnameage', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'fnamelnameage'}]",for in 中 x代表key值，所以取出的值为value,A
(单选题)下列JavaScript的循环语句中正确的是（ ）,"[{'optionContent': 'A.if(i<10;i++)', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'if(i<10;i++)'}, {'optionContent': 'B.if(i<10;i++)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'if(i<10;i++)'}, {'optionContent': 'C.for i=1 to 10', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'for i=1 to 10'}, {'optionContent': 'D.for(i=0;i<=10;i++)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'for(i=0;i<=10;i++)'}]",js中for循环语句D选项正确,D
(单选题)如何判断一个js对象是否是Array，arr为要判断的对象，其中最准确的方法是？,"[{'optionContent': 'A.typeof(arr)', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'typeof(arr)'}, {'optionContent': 'B.arr instanceof Array', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'arr instanceof Array'}, {'optionContent': ""C.arr.toString==='[object Array]';"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""arr.toString==='[object Array]';""}, {'optionContent': ""D.Object.prototype.toString.call(arr) === '[object Array]';"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""Object.prototype.toString.call(arr) === '[object Array]';""}]",typeof(arr) 返回的是 Object instanceof 在跨 frame 对象构建的场景下会失效 arr.toString 没有这种用法，正确的用法是 arr.toString() 返回的是数组的内容,D
"(单选题)分析下面的JavaScript代码段
arr=new Array(2,3,4,5,6);
sum=0;  
for(i=1;i<arr.length;i++) 
    sum += arr[i]; 
document.write(sum);  
输出结果是( )","[{'optionContent': 'A.20', 'isCorrect': '-1', 'option': 'A', 'optionValue': '20'}, {'optionContent': 'B.18', 'isCorrect': '-1', 'option': 'B', 'optionValue': '18'}, {'optionContent': 'C.14', 'isCorrect': '-1', 'option': 'C', 'optionValue': '14'}, {'optionContent': 'D.12', 'isCorrect': '-1', 'option': 'D', 'optionValue': '12'}]","代码""a=new Array(2,3,4,5,6);""表示创建数组,数组内有5个元素,分别是2,3,4,5,6 代码""for(i=1;i",B
(单选题)如何把 7.25 四舍五入为最接近的整数？,"[{'optionContent': 'A.round(7.25)', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'round(7.25)'}, {'optionContent': 'B.rnd(7.25)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'rnd(7.25)'}, {'optionContent': 'C.Math.rnd(7.25)', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Math.rnd(7.25)'}, {'optionContent': 'D.Math.round(7.25)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Math.round(7.25)'}]",◎Math.ceil()向上取整，即它总是将数值向上舍入为最接近的整数； ◎Math.floor()向下取整，即它总是将数值向下舍入为最接近的整数； ◎Math.round()标准取整，即它总是将数值四舍五入为最接近的整数(这也是我们在数学课上学到的舍入规则),D
(单选题)可以把对象的值转换为数字的函数是( ),"[{'optionContent': 'A.Date()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Date()'}, {'optionContent': 'B.max()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'max()'}, {'optionContent': 'C.Number()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Number()'}, {'optionContent': 'D.random()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'random()'}]",A.Date是对象。 BD.max()和random()是Math对象的方法。 Number() 函数可以把对象的值转换为数字。 所以选C,C
(单选题)下面哪个对象是javaScript中的常用内置对象：,"[{'optionContent': 'A.Number', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Number'}, {'optionContent': 'B.Integer', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Integer'}, {'optionContent': 'C.Double', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Double'}, {'optionContent': 'D.Long', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Long'}]",js中的常用内置对象有：String、Number、Boolean、Array、Math、 Date、RegExp、Function,A
(多选题)以下哪些是javascript的数据类型（）,"[{'optionContent': 'A.String', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String'}, {'optionContent': 'B.Number', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Number'}, {'optionContent': 'C.Undefined', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Undefined'}, {'optionContent': 'D.Date', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Date'}]",JavaScript中的数据类型有： 字符串、数字、布尔、数组、对象、Null、Undefined Date是对象,"A,B,C"
"(单选题)以下代码的输出结果是
var f = function g() {
    return 23;
};
typeof g();","[{'optionContent': 'A.""number""', 'isCorrect': '-1', 'option': 'A', 'optionValue': '""number""'}, {'optionContent': 'B.""undefined""', 'isCorrect': '-1', 'option': 'B', 'optionValue': '""undefined""'}, {'optionContent': 'C.""function""', 'isCorrect': '-1', 'option': 'C', 'optionValue': '""function""'}, {'optionContent': 'D.Error', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Error'}]",如果是typeof f，结果是function 如果是typeof f()，结果是number 如果是typeof g，结果是undefined 如果是typeof g()，结果是ReferenceError，g is not defined,D
"(单选题)写出如下代码弹出的结果:
<script> 
    var m= 1, j = k = 0; 
    function add(n) { 
        return n = n+1; 
　 } 
    y = add(m); 
    function add(n) { 
        return n = n + 3; 
    } 
z = add(m); 
</script> 
y和z的最终结果为:","[{'optionContent': 'A.2,4', 'isCorrect': '-1', 'option': 'A', 'optionValue': '2,4'}, {'optionContent': 'B.4,4', 'isCorrect': '-1', 'option': 'B', 'optionValue': '4,4'}, {'optionContent': 'C.2,2', 'isCorrect': '-1', 'option': 'C', 'optionValue': '2,2'}, {'optionContent': 'D.报异常', 'isCorrect': '-1', 'option': 'D', 'optionValue': '报异常'}]","js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数， 只要传入的参数数量或者类型不同即可。在js中，定义了两个同名函数后， 后面的函数会覆盖前面定义的函数。结合这道题来说，由于函数声明提升， 所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数， 所以两次调用add()返回的值是相同的。也就是y,z都为4.",B
"(单选题)写出下面代码的运行结果
var a,b;
(function(){
    alert(a);
    alert(b);
    var a=b=3;
    alert(a);
    alert(b);
})();
alert(a);
alert(b);","[{'optionContent': 'A.undefined，undefined，3,3，undefined，3', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'undefined，undefined，3,3，undefined，3'}, {'optionContent': 'B.undefined，undefined，3,3，undefined，undefined', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'undefined，undefined，3,3，undefined，undefined'}, {'optionContent': 'C.0，0，3,3，undefined，undefined', 'isCorrect': '-1', 'option': 'C', 'optionValue': '0，0，3,3，undefined，undefined'}, {'optionContent': 'D.undefined，undefined，3,3，0，0', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'undefined，undefined，3,3，0，0'}]","这段代码其实等价于 var a,b; //undefined (function(){ alert(a);//undefined alert(b); //undefined b=3; //3 var a; //undefined a = b; //3 alert(a); //3 alert(b); //3 })(); alert(a); //undefined alert(b); //3 变量的作用域问题。",A
"(单选题)打开名为 ""window2"" 的新窗口的 JavaScript 语法是？","[{'optionContent': 'A.open.new(""http://www.w3school.com.cn"",""window2"")', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'open.new(""http://www.w3school.com.cn"",""window2"")'}, {'optionContent': 'B.new.window(""http://www.w3school.com.cn"",""window2"")', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'new.window(""http://www.w3school.com.cn"",""window2"")'}, {'optionContent': 'C.new.window(""http://www.w3school.com.cn"",""window2"")', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'new.window(""http://www.w3school.com.cn"",""window2"")'}, {'optionContent': 'D.window.open(""http://www.w3school.com.cn"",""window2"")', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'window.open(""http://www.w3school.com.cn"",""window2"")'}]","open() 方法可以查找一个已经存在或者新建的浏览器窗口。
语法：
window.open([URL], [窗口名称], [参数字符串])
参数说明:
URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2.""_top""、""_blank""、""_selft""具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
    4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。",D
(单选题)要在10秒后调用checkState，下列哪个是正确的（）,"[{'optionContent': 'A.window.setTimeout(checkState, 10);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'window.setTimeout(checkState, 10);'}, {'optionContent': 'B.window.setTimeout(checkState, 10000);', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'window.setTimeout(checkState, 10000);'}, {'optionContent': 'C.window.setTimeout(checkState(), 10);', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'window.setTimeout(checkState(), 10);'}, {'optionContent': 'D.window.setTimeout(checkState(), 10000);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'window.setTimeout(checkState(), 10000);'}]",checkState加了圆括弧相当于函数表达式，会立即执行，执行的结果作为返回值传递给settimeout。 不加圆括弧是将函数对象引用作为参数传入setTimeout函数内，然后通过引用调用执行checkState函数。 在setTimeout函数中传入的时间参数是毫秒值，1秒=1000毫秒，题目中要求10秒后执行checkState函数，也就是10 * 1000毫秒。 所以B选项正确。,B
(单选题)把鼠标移到按钮上时，会产生哪些事件？,"[{'optionContent': 'A.hove click', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'hove click'}, {'optionContent': 'B.foucs keyup', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'foucs keyup'}, {'optionContent': 'C.keydown foucus', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'keydown foucus'}, {'optionContent': 'D.focus hover', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'focus hover'}]",focus -> hover 聚焦 -> 悬停,D
(单选题)在JavaEE中属于Web层的组件有。（ ）,"[{'optionContent': 'A.Servlet ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Servlet '}, {'optionContent': 'B.EJB', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'EJB'}, {'optionContent': 'C.Applet', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Applet'}, {'optionContent': 'D.HTML', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'HTML'}]",此题目考查的是JavaEE组件，Servlet属性Web组件的一种 故选项A正确。,A
(单选题)javax.Servlet的包中，属于类的是。（ ）,"[{'optionContent': 'A.Servlet', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Servlet'}, {'optionContent': 'B.GenericServlet', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'GenericServlet'}, {'optionContent': 'C.ServletRequest', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ServletRequest'}, {'optionContent': 'D.ServletContext', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ServletContext'}]",此题目考查的是Servlet相关的类和接口 Servlet是接口，定义了Servlet规范的方法 故选项B正确。,B
(单选题)假设web应用的文档根目录为MyApp，那么可以从（ ）找到database.jar文件。,"[{'optionContent': 'A.MyApp目录下     ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'MyApp目录下     '}, {'optionContent': 'B.MyApp\\images目录下', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'MyApp\\images目录下'}, {'optionContent': 'C.MyApp\\WEB-INF目录下', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'MyApp\\WEB-INF目录下'}, {'optionContent': 'D.MyApp\\WEB-INF\\lib目录下', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'MyApp\\WEB-INF\\lib目录下'}]",此题目考查的是WEB应用的目录结构，jar文件会被保存在项目中 WEB-INF/lib目录中，故选项D正确。,D
(单选题)以下 web.xml 片断正确地声明 servlet 初始化参数的是（ ）,"[{'optionContent': 'A.<init-param>\n  <param-name>MAX</param-name>\n  <param-value>100</param-value>\n</init-param>\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<init-param>\n  <param-name>MAX</param-name>\n  <param-value>100</param-value>\n</init-param>\n'}, {'optionContent': 'B.<context-param>\n  <param name=""MAX"" value=""100"" />\n<context-param>\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<context-param>\n  <param name=""MAX"" value=""100"" />\n<context-param>\n'}, {'optionContent': 'C.<context>\n  <param name=""MAX"" value=""100"" />\n<context>\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<context>\n  <param name=""MAX"" value=""100"" />\n<context>\n'}, {'optionContent': 'D.<context-param>\n  <param-name>MAX</param-name>\n  <param-value>100</param-value>\n<context-param>\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<context-param>\n  <param-name>MAX</param-name>\n  <param-value>100</param-value>\n<context-param>\n'}]",init-param为指定Servlet初始化参数，只对应一个Servlet。 context-param对应整个web应用。,A
(单选题)ServletConfig接口默认是哪里实现的？,"[{'optionContent': 'A.Servlet', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Servlet'}, {'optionContent': 'B.GenericServlet', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'GenericServlet'}, {'optionContent': 'C.HttpServlet', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'HttpServlet'}, {'optionContent': 'D.用户自定义servlet', 'isCorrect': '-1', 'option': 'D', 'optionValue': '用户自定义servlet'}]",GenericServlet类的实现接口中包括了ServletConfig接口，但是它自身的init(ServletConfig config)方法又需要外界给它传递一个实现ServletConfig的对象，就是说GenericServlet和ServletConfig的依赖关系既是继承关系，也是一种关联关系。,B
(多选题)动态网站需要的技术为（ ）  ,"[{'optionContent': 'A.HTTP', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HTTP'}, {'optionContent': 'B.CGI ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'CGI '}, {'optionContent': 'C.PHP', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'PHP'}, {'optionContent': 'D.ASP', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ASP'}]",HTTP是超文本传输协议。 选项BCD正确。,"B,C,D"
(多选题)下列哪些是 J2EE 的体系（ ）,"[{'optionContent': 'A.JSP', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'JSP'}, {'optionContent': 'B.JAVA', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'JAVA'}, {'optionContent': 'C.Servlet', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Servlet'}, {'optionContent': 'D.WebService', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'WebService'}]",J2EE 现在更多使用的名字是 Java EE JSP 是 JavaEE 设计模式 MVC 中的显示部分，Servlet 是控制部 分，WebService 是 JavaEE 的服务器。,"A,C,D"
(单选题)在Web应用的根目录中，可以存放的文件为。（ ）,"[{'optionContent': 'A.class文件  ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'class文件  '}, {'optionContent': 'B.web.xml', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'web.xml'}, {'optionContent': 'C.jar文件', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'jar文件'}, {'optionContent': 'D.html文件', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'html文件'}]","此题目考查的是Web应用的目录结构。根目录中可以存放html,jsp,css文件，js文件等等，故选项D正确。",D
(单选题)HTTP状态码中表示请求资源不存在的是（）。,"[{'optionContent': 'A.100', 'isCorrect': '-1', 'option': 'A', 'optionValue': '100'}, {'optionContent': 'B.200', 'isCorrect': '-1', 'option': 'B', 'optionValue': '200'}, {'optionContent': 'C.300', 'isCorrect': '-1', 'option': 'C', 'optionValue': '300'}, {'optionContent': 'D.404', 'isCorrect': '-1', 'option': 'D', 'optionValue': '404'}]",此题目考查的是404表示资源不存在的状态码 故本题选项D正确。,D
(单选题)在HTTP协议中，可以通过Intenet发送大量数据，而且没有长度的限制，可以使用请求消息的方法是（）,"[{'optionContent': 'A.get', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'get'}, {'optionContent': 'B.post', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'post'}, {'optionContent': 'C.put', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'put'}, {'optionContent': 'D.head', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'head'}]",此题目考查的是POST方式提交请求，数据长度没有限制，可以发送大量数据 故选项B正确。,B
(单选题)在HTTP协议中，用于发送大量数据的方法是（）。,"[{'optionContent': 'A.get', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'get'}, {'optionContent': 'B.post', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'post'}, {'optionContent': 'C.put', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'put'}, {'optionContent': 'D.options', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'options'}]",此题目考查的是Post请求方式。发送数据量大小没限制，可以 用来发送大量数据，故选项B正确。,B
(单选题)下面哪个不属于HttpServletResponse接口完成的功能？,"[{'optionContent': 'A.设置HTTP头标', 'isCorrect': '-1', 'option': 'A', 'optionValue': '设置HTTP头标'}, {'optionContent': 'B.设置cookie', 'isCorrect': '-1', 'option': 'B', 'optionValue': '设置cookie'}, {'optionContent': 'C.读取路径信息', 'isCorrect': '-1', 'option': 'C', 'optionValue': '读取路径信息'}, {'optionContent': 'D.输出返回数据', 'isCorrect': '-1', 'option': 'D', 'optionValue': '输出返回数据'}]","A：设置HTTP头标 response.setHeader(""Refresh"",""3""); //三秒刷新页面一次 B：设置cookie Cookie c1 = new Cookie(""username"",""only""); response.addCookie(c1); C（错误）：读取路径信息,request读取路径信息 从request获取各种路径总结 request.getRealPath(""url""); // 虚拟目录映射为实际目录 request.getRealPath(""./""); // 网页所在的目录 request.getRealPath(""../""); // 网页所在目录的上一层目录 request.getContextPath(); // 应用的web目录的名称 D：输出返回数据 HttpServleteResponse.getOutputStream().write();",C
(单选题)Web.xml文件中的Servlet映射代码片段，正确的是：(  ),"[{'optionContent': 'A.<servlet-mapping>\n  <servlet-name>Login</servlet-name>\n  <url-pattern>/login/*</url-pattern>\n</servlet-mapping>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<servlet-mapping>\n  <servlet-name>Login</servlet-name>\n  <url-pattern>/login/*</url-pattern>\n</servlet-mapping>'}, {'optionContent': 'B.<servlet-name>\n  <servlet-mapping>login</servlet-mapping>\n  <url-pattern>/Login</url-pattern>\n</servlet-name>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<servlet-name>\n  <servlet-mapping>login</servlet-mapping>\n  <url-pattern>/Login</url-pattern>\n</servlet-name>'}, {'optionContent': 'C.<servlet-mapping>\n  <servlet>Login</servlet>\n  <url-pattern>/login</url-pattern>\n</servlet-mapping>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<servlet-mapping>\n  <servlet>Login</servlet>\n  <url-pattern>/login</url-pattern>\n</servlet-mapping>'}, {'optionContent': 'D.<servlet >\n  <servlet-name>Login</servlet-name>\n  <url-pattern>/login/*</url-pattern>\n</servlet>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<servlet >\n  <servlet-name>Login</servlet-name>\n  <url-pattern>/login/*</url-pattern>\n</servlet>'}]",此题目考查的是Servlet映射的配置。 语法如下： servletName /url 故选项A正确。,A
(多选题)在部署Servlet时，web.xml文件中<servlet>标签应该包含（ ）标签。,"[{'optionContent': 'A.<servlet-mapping>    ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<servlet-mapping>    '}, {'optionContent': 'B.<servlet-name>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<servlet-name>'}, {'optionContent': 'C.<url-pattern>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<url-pattern>'}, {'optionContent': 'D.<servlet-class>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<servlet-class>'}]",此题目考查的是Servlet的配置 应该包含servlet-name和servlet-class元素 选项BD正确。,"B,D"
(单选题)Servlet 中，可以保存数据的三个不同的作用域是（）。,"[{'optionContent': 'A.request、response和上下文对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'request、response和上下文对象'}, {'optionContent': 'B.response、session和上下文对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'response、session和上下文对象'}, {'optionContent': 'C.request、response和session对象', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'request、response和session对象'}, {'optionContent': 'D.request、session和上下文对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'request、session和上下文对象'}]","此题目考查的是能够用来保存的数据的作用域分别是request,session.application 故选项D正确。",D
"(单选题)在Java Web应用程序中，给定某Servlet程序的代码如下所示：
public class ServletFoo extends HttpServlet{
  public void doGet
  (HttpServletRequest request,HttpServletResponse response)
  throws ServletException IOException{
    System.out.println(""hello"");
  }
  public void doPost
  (HttpServletRequestrequest.HttpServletResponse response)
  throws ServletException,IOException{
    System.out.println(""tedu"");
    doGet(reauest,response);
  }
}
用户在浏览器地址栏中键入正确的请求URL并回车后，在控制台上显示的结果是（ ）。","[{'optionContent': 'A.hello', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'hello'}, {'optionContent': 'B.tedu', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'tedu'}, {'optionContent': 'C.hello\ntedu', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'hello\ntedu'}, {'optionContent': 'D.tedu\nhello', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'tedu\nhello'}]",此题目考查的是doGet()函数和doPost()函数 浏览器键入路径发送请求，请求方式为get请求，会调用Servlet 中的doGet()函数，所以打印结果为hello 故选项A正确。,A
(单选题)Servlet 程序中，处理请求的方法入口是（ ）,"[{'optionContent': 'A.init()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'init()'}, {'optionContent': 'B.main()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'main()'}, {'optionContent': 'C.service()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'service()'}, {'optionContent': 'D.doGet()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'doGet()'}]",在默认情况下，无论是get还是post请求，都会经过service方法。,C
(单选题)为了获得用户提交的表单参数，可以从（ ）接口中得到。,"[{'optionContent': 'A.HttpServletResponse', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HttpServletResponse'}, {'optionContent': 'B.Servlet', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Servlet'}, {'optionContent': 'C.RequestDispatcher  ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'RequestDispatcher  '}, {'optionContent': 'D.HttpServletRequest', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'HttpServletRequest'}]",此题目考查的是HttpServletRequest可以用来获取表单参数 故选项D正确。,D
(单选题)哪一个对象可以用于获得浏览器发送的请求中所携带的参数数据（ ）,"[{'optionContent': 'A.HttpServletRequest', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HttpServletRequest'}, {'optionContent': 'B.HttpServletResponse', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'HttpServletResponse'}, {'optionContent': 'C.HttpServlet', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'HttpServlet'}, {'optionContent': 'D.Http', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Http'}]",HttpServletRequest 中有一些方法可以获取浏览器向服务端发送的参数数据。,A
(单选题)表示URL重定向的状态码是（ ）,"[{'optionContent': 'A.200', 'isCorrect': '-1', 'option': 'A', 'optionValue': '200'}, {'optionContent': 'B.302', 'isCorrect': '-1', 'option': 'B', 'optionValue': '302'}, {'optionContent': 'C.400', 'isCorrect': '-1', 'option': 'C', 'optionValue': '400'}, {'optionContent': 'D.500', 'isCorrect': '-1', 'option': 'D', 'optionValue': '500'}]",此题目考查的是重定向状态码。 重定向后，服务器会向浏览器发送302状态码。 故选项B正确,B
"(单选题)给定一个 Servlet 的doPost方法中的代码片段，如下：
request.setAttribute(""color"",""red"");
request.getRequestDispatcher(""/myservlet"").forward(request, response);
//转发到MyServlet 以下说法正确的是：（）。","[{'optionContent': 'A.在 MyServlet 中，可以使用String str=(String)request.getAttribute(""color""); 把属性 color的值取出来', 'isCorrect': '-1', 'option': 'A', 'optionValue': '在 MyServlet 中，可以使用String str=(String)request.getAttribute(""color""); 把属性 color的值取出来'}, {'optionContent': 'B.在 MyServlet 中，可以使用 String str=request.getAttribute(""color""); 把属性 color的值取出来', 'isCorrect': '-1', 'option': 'B', 'optionValue': '在 MyServlet 中，可以使用 String str=request.getAttribute(""color""); 把属性 color的值取出来'}, {'optionContent': 'C.在 MyServlet 中，可以使用String str=request.getParameter (""color""); 把属性 color的值取出来', 'isCorrect': '-1', 'option': 'C', 'optionValue': '在 MyServlet 中，可以使用String str=request.getParameter (""color""); 把属性 color的值取出来'}, {'optionContent': 'D.在 MyServlet 中，无法取出属性color的值', 'isCorrect': '-1', 'option': 'D', 'optionValue': '在 MyServlet 中，无法取出属性color的值'}]",此题目考查的是获取request对象中的属性值。 通过request.getAttribute()获取属性值，该方法返回Object类型 需要强制转换到String类型 故选项A正确。,A
(单选题)下列不能控制一个Servlet的生命周期方法的是：,"[{'optionContent': 'A.service', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'service'}, {'optionContent': 'B.destroy', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'destroy'}, {'optionContent': 'C.doPost', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'doPost'}, {'optionContent': 'D.init', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'init'}]",doPost方法是用来处理表单post方式提交的表单,C
(单选题)Servlet在容器中经历的阶段，按顺序为（ ）,"[{'optionContent': 'A.服务、加载、初始化、卸载、销毁  ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '服务、加载、初始化、卸载、销毁  '}, {'optionContent': 'B.加载、初始化、服务、销毁、卸载', 'isCorrect': '-1', 'option': 'B', 'optionValue': '加载、初始化、服务、销毁、卸载'}, {'optionContent': 'C.初始化、服务、销毁、加载、卸载', 'isCorrect': '-1', 'option': 'C', 'optionValue': '初始化、服务、销毁、加载、卸载'}, {'optionContent': 'D.服务、卸载、加载、初始化、销毁', 'isCorrect': '-1', 'option': 'D', 'optionValue': '服务、卸载、加载、初始化、销毁'}]",此题目考查的是Servlet的生命周期。 容器依次会对一个Servlet进行加载实例，初始化，服务，销毁，卸载 故选项B正确。,B
(多选题)有关 Servlet 的生命周期说法正确的有（ ）,"[{'optionContent': 'A.Servlet 的生命周期由 Servlet 实例控制。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Servlet 的生命周期由 Servlet 实例控制。'}, {'optionContent': 'B.init() 方法在创建完Servlet实例后对其进行初始化，传递的参数为实现ServletContext 接口的对象。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'init() 方法在创建完Servlet实例后对其进行初始化，传递的参数为实现ServletContext 接口的对象。'}, {'optionContent': 'C.service()方法响应客户端发出的请求。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'service()方法响应客户端发出的请求。'}, {'optionContent': 'D.destroy()方法释放 Servlet 实例。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'destroy()方法释放 Servlet 实例。'}]","Servlet 生命周期就是指创建 Servlet 实例化后响应客户请求直至销毁的全过程。 Serlvet 生命周期的三个方法:init()-->service()-->destroy()。 Servlet 生命周期的各个阶段: 实例化:Servlet 容器创建Servlet 类的实例对象； 初始化:Servlet 容器调用 Servlet 的 init()方法； 服 务:如果请求 Servlet,则容器调用 service()方法； 销 毁:销毁实例之前调用 destroy()方法。 Servlet生命周期是由Servlet容器管理的。 调用初始化init()方法时需要传入实现了ServletConfig接口的实例。 所以A、B不正确。 正确答案CD","C,D"
(单选题)从以下（ ）个选项中可以获得Servlet的初始化参数,"[{'optionContent': 'A.Servlet ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Servlet '}, {'optionContent': 'B.ServletContext', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'ServletContext'}, {'optionContent': 'C.ServletConfig', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ServletConfig'}, {'optionContent': 'D.GenericServlet', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'GenericServlet'}]",此题目考查的是获取Servlet初始化参数，可以通过ServletConfig对象 故选项C正确。,C
(单选题)下列哪个为 JSP 的小脚本的标签（ ）,"[{'optionContent': 'A.<% %>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<% %>'}, {'optionContent': 'B.<@ %>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<@ %>'}, {'optionContent': 'C.<%! %>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%! %>'}, {'optionContent': 'D.<%-- %>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<%-- %>'}]",为jsp中java代码片段标签,A
"(单选题)在a.jsp中有代码片段如下：
<from action=""b.jsp"" method=""POST"" name=""form1"">
  loginName:<input type=""text"" name=""loginName"" />
  <input type=""submit"" name=""submit"" />
</form>
在b.jsp 中加入下列哪个代码，可以直接在界面上输出由a.jsp页面输入的loginName的值（ ）
","[{'optionContent': 'A.<%=(String) request.getParameter(""loginName"")%>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<%=(String) request.getParameter(""loginName"")%>'}, {'optionContent': 'B.<%=(String) request.getAttribute(""loginName"")%>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<%=(String) request.getAttribute(""loginName"")%>'}, {'optionContent': 'C.<%String name=request.getParameter(""loginName""); out.println(name);%>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%String name=request.getParameter(""loginName""); out.println(name);%>'}, {'optionContent': 'D.<%String name=request.getAttribute (""loginName""); out.println(name);%>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<%String name=request.getAttribute (""loginName""); out.println(name);%>'}]","应该使用request.getParameter(""loginName"")获取表单参数，且应该使用java代码片段。",C
(单选题)Page指令用于定义JSP文件中的全局属性，下列关于该指令用法的描述不正确的是（）,"[{'optionContent': 'A.可以在一个页面中使用多个<%@ page %>指令。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以在一个页面中使用多个<%@ page %>指令。'}, {'optionContent': 'B.<%@ page %>作用于整个JSP页面。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<%@ page %>作用于整个JSP页面。'}, {'optionContent': 'C.<%@ page %>指令中的所有的属性都只能出现一次。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%@ page %>指令中的所有的属性都只能出现一次。'}, {'optionContent': 'D.为增强程序的可读性，建议将<%@ page %>指令放在JSP文件的开头，但不是必须的。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '为增强程序的可读性，建议将<%@ page %>指令放在JSP文件的开头，但不是必须的。'}]",指令中除import属性外，其他属性都只能出现一次。,C
(单选题)下列哪个为JSP的注释标签？（ ）,"[{'optionContent': 'A.<%@%>    ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<%@%>    '}, {'optionContent': 'B.<%!%>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<%!%>'}, {'optionContent': 'C.<%%>  ', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%%>  '}, {'optionContent': 'D.<%-- 被注释的内容 --%>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<%-- 被注释的内容 --%>'}]","此题目考查的是JSP中的注释，语法为,故选项D正确。",D
(单选题)下列哪个为JSP的内置对象？（ ）,"[{'optionContent': 'A.env', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'env'}, {'optionContent': 'B.page', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'page'}, {'optionContent': 'C.jspinfo', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'jspinfo'}, {'optionContent': 'D.context', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'context'}]",此题目考查的是JSP内置对象，四个选项中只有选项B，page是 JSP的内置对象，故选项B正确。,B
(单选题)下列有关JSP内置对象中的response描述正确的是（）,"[{'optionContent': 'A.网页传回用户端的回应', 'isCorrect': '-1', 'option': 'A', 'optionValue': '网页传回用户端的回应'}, {'optionContent': 'B.用户端请求，此请求会包含来自GET/POST请求的参数', 'isCorrect': '-1', 'option': 'B', 'optionValue': '用户端请求，此请求会包含来自GET/POST请求的参数'}, {'optionContent': 'C.用来传送回应的输出', 'isCorrect': '-1', 'option': 'C', 'optionValue': '用来传送回应的输出'}, {'optionContent': 'D.针对错误网页，未捕捉的例外', 'isCorrect': '-1', 'option': 'D', 'optionValue': '针对错误网页，未捕捉的例外'}]",response是用来网页传回用户端的回应,A
"(单选题)可以实现不同网页之间的数据共享，而且还可以实现跨机共享数据的JSP对象是（ ）
","[{'optionContent': 'A.Response对象\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Response对象\n'}, {'optionContent': 'B.Session对象\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Session对象\n'}, {'optionContent': 'C.Application对象\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Application对象\n'}, {'optionContent': 'D.Request对象\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Request对象\n'}]",Application对象 :application对应了Servlet中的ServletContext类的对象。它在每个Web项目中只有一个实例，常被用来实现不同用户之间的数据共享。因为不同的用户在访问application的时候，都是访问的同一个对象，这样的话，一个用户可以把需要共享的数据放到application对象中，然后 其他用户就可以在这个对象中获得想要的共享数据了。,C
(多选题)下列哪些为JSP 的隐含对象（ ）,"[{'optionContent': 'A.env', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'env'}, {'optionContent': 'B.application', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'application'}, {'optionContent': 'C.jspinfo', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'jspinfo'}, {'optionContent': 'D.config', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'config'}]","JSP 有九个隐藏对象： request 对象：保存了很多客户端请求的信息； response 对象：生成服务器端响应，然后将响应结果发送到客户端； out 对象：表示输出流，此输出流将作为请求发送到客户端； session 对象：我们写个对象放在这个 session 对象中,这个对象就在我们的会话中都存在； application 对象：我们写个对象放在这个 application 对象中，这个对象就在整个应用程序中都存在； pageContext 对象：相当于当前页面的容器，可以访问当前页面的所有对象；paget 对象：一般我们使用 Page 指令来替代使用这个对象； exception 对象：用来处理异常的； config 对象：一样的我们在页面中是使用很少的，一般会在 Servlet 中使用这个。","B,D"
(多选题)有关 JSP 隐式对象，以下（ ）描述正确,"[{'optionContent': 'A.隐式对象是 WEB 容器加载的一组类的实例，可以直接在 JSP 页面使用', 'isCorrect': '-1', 'option': 'A', 'optionValue': '隐式对象是 WEB 容器加载的一组类的实例，可以直接在 JSP 页面使用'}, {'optionContent': 'B.不能通过 config 对象获取 ServletContext 对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': '不能通过 config 对象获取 ServletContext 对象'}, {'optionContent': 'C.response 对象通过 sendRedirect 方法实现重定向', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'response 对象通过 sendRedirect 方法实现重定向'}, {'optionContent': 'D.只有在出错处理页面才有 exception 对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '只有在出错处理页面才有 exception 对象'}]",可以通过 config 对象获取 ServletContext 对象。,"A,C,D"
(单选题)（ ）对象可以用于获得浏览器发送的请求。,"[{'optionContent': 'A.HttpServletRequest     ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HttpServletRequest     '}, {'optionContent': 'B.HttpServletResponse', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'HttpServletResponse'}, {'optionContent': 'C.HttpServletHttp', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'HttpServletHttp'}, {'optionContent': 'D.Http', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Http'}]","此题目考查的是HttpServletRequest,对象用来封装客户端所有的请求。 可以用来在Servlet中获取请求数据， 故选项A正确。",A
(单选题)对于每一个网站访问用户都要访问的变量，应该将它设为变量（ ）,"[{'optionContent': 'A.Session', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Session'}, {'optionContent': 'B.Reques', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Reques'}, {'optionContent': 'C.Response', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Response'}, {'optionContent': 'D.Application', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Application'}]",Application 应用程序级变量,D
"(单选题)在JSP中使用<jsp:forward  page = ""newworld.jsp"" />后浏览器地址栏内的内容（）","[{'optionContent': 'A.发生变化', 'isCorrect': '-1', 'option': 'A', 'optionValue': '发生变化'}, {'optionContent': 'B.不发生变化', 'isCorrect': '-1', 'option': 'B', 'optionValue': '不发生变化'}, {'optionContent': 'C.错误用法', 'isCorrect': '-1', 'option': 'C', 'optionValue': '错误用法'}, {'optionContent': 'D.可能变化', 'isCorrect': '-1', 'option': 'D', 'optionValue': '可能变化'}]",jsp:forward可以实现页面跳转的效果 作用是转发 所以浏览器地址不会发生变化,B
(单选题)在JSP中不能在不同用户之间共享数据的方法是(   )。,"[{'optionContent': 'A.通过cookie', 'isCorrect': '-1', 'option': 'A', 'optionValue': '通过cookie'}, {'optionContent': 'B.利用文件系统', 'isCorrect': '-1', 'option': 'B', 'optionValue': '利用文件系统'}, {'optionContent': 'C.利用数据库', 'isCorrect': '-1', 'option': 'C', 'optionValue': '利用数据库'}, {'optionContent': 'D.通过ServletContext对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '通过ServletContext对象'}]",Cookie是用来记录客户端数据的，不能共享,A
"(单选题)在J2EE中，test.jsp文件中有如下一行代码：  <jsp:useBean id=""user"" scope=""_____"" type=""com.UserBean""/> 要使user对象中一直存在于会话中，直至其终止或被删除为止，下划线中应填入（ ）","[{'optionContent': 'A.page', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'page'}, {'optionContent': 'B.request', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'request'}, {'optionContent': 'C.session', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'session'}, {'optionContent': 'D.application', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'application'}]",session对象属于会话级别的对象 当手动清除或是session对象超时都会被清除,C
(单选题)J2EE中，HttpSession接口位于（ ）包中。,"[{'optionContent': 'A.javax.servlet', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'javax.servlet'}, {'optionContent': 'B.javax.servlet.session', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'javax.servlet.session'}, {'optionContent': 'C.javax.servlet.http.session', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'javax.servlet.http.session'}, {'optionContent': 'D.javax.servlet.http', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'javax.servlet.http'}]",HttpSession接口全限定名是javax.servlet.http.HttpSession,D
(单选题)J2EE中，JSP EL 表达式：${user.loginName}执行效果等同于（ ）,"[{'optionContent': 'A.<%=user.loginName%> ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<%=user.loginName%> '}, {'optionContent': 'B.<%user.getLoginName();%>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<%user.getLoginName();%>'}, {'optionContent': 'C.<%=user.getLoginName()%> ', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%=user.getLoginName()%> '}, {'optionContent': 'D.<%user.loginName;%>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<%user.loginName;%>'}]",${user.loginName}会调用user对象的getLoginName()方法 规则是将loginName的首字母变大写 然后再前面加上get 然后调用user对象中与该名字相同方法,C
(单选题)以下哪个技术不是Ajax技术体系的组成部分（ ）,"[{'optionContent': 'A.XMLHttpRequest', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'XMLHttpRequest'}, {'optionContent': 'B.DHTML', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DHTML'}, {'optionContent': 'C.CSS', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'CSS'}, {'optionContent': 'D.DOM', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'DOM'}]",此题目考查的是AJAX技术的范畴 DHTML不属于AJAX范畴，本题选B,B
(单选题)在Ajax的四种技术中，控制通信的是哪一个（ ）,"[{'optionContent': 'A.DOM', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DOM'}, {'optionContent': 'B.CSS', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'CSS'}, {'optionContent': 'C.javascript', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'javascript'}, {'optionContent': 'D.XMLHttpRequest', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'XMLHttpRequest'}]",XMLHttpRequest是用来负责通信的 D选项正确,D
(单选题)关于在IE浏览器上创建XMLHttpRequest对象的说法正确的是（）,"[{'optionContent': 'A.需要通过new ActiveXObject(""Microsoft.XMLHTTP"")来创建', 'isCorrect': '-1', 'option': 'A', 'optionValue': '需要通过new ActiveXObject(""Microsoft.XMLHTTP"")来创建'}, {'optionContent': 'B.需要通过new XMLHttpRequest()来创建', 'isCorrect': '-1', 'option': 'B', 'optionValue': '需要通过new XMLHttpRequest()来创建'}, {'optionContent': 'C.以上两种方式都正确', 'isCorrect': '-1', 'option': 'C', 'optionValue': '以上两种方式都正确'}, {'optionContent': 'D.以上两种方式都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上两种方式都不对'}]","IE浏览器上创建XMLHttpRequest对象的方式是new ActiveXObject(""Microsoft.XMLHTTP"") 固定写法 选项A正确",A
"(单选题)XMLHttpRequest 对象的 status 属性表示当前请求的 http 状态码，
其中（ ）表示正确返回。","[{'optionContent': 'A.200', 'isCorrect': '-1', 'option': 'A', 'optionValue': '200'}, {'optionContent': 'B.302', 'isCorrect': '-1', 'option': 'B', 'optionValue': '302'}, {'optionContent': 'C.500', 'isCorrect': '-1', 'option': 'C', 'optionValue': '500'}, {'optionContent': 'D.404', 'isCorrect': '-1', 'option': 'D', 'optionValue': '404'}]",此题目考查的是http请求状态码 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。,A
"(单选题)在处理响应中，如果我们想要处理服务器响应回来的文本，
我们需要如何访问（ ）","[{'optionContent': 'A.xhr.responseText', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'xhr.responseText'}, {'optionContent': 'B.xhr.responseXML', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'xhr.responseXML'}, {'optionContent': 'C.xhr.requestText', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'xhr.requestText'}, {'optionContent': 'D.xhr.requestXML', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'xhr.requestXML'}]",此题目考查的是XMLHttpRequest对象的responseText属性 获取响应回来的文本信息需要使用XMLHttpRequest对象的responseText属性获取 选项A正确,A
(单选题)XMLHttpRequest对象的status属性值为500时表示（ ）。,"[{'optionContent': 'A.表示请求正在处理中', 'isCorrect': '-1', 'option': 'A', 'optionValue': '表示请求正在处理中'}, {'optionContent': 'B.表示找不到资源文件', 'isCorrect': '-1', 'option': 'B', 'optionValue': '表示找不到资源文件'}, {'optionContent': 'C.表示服务器处理成功', 'isCorrect': '-1', 'option': 'C', 'optionValue': '表示服务器处理成功'}, {'optionContent': 'D.表示服务器内部错误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '表示服务器内部错误'}]",此题目考查的是XMLHttpRequest对象的status属性 500（服务器内部错误） 服务器遇到错误，无法完成请求。 D选项正确,D
"(单选题)下面哪个方法用来初始化 HTTP 请求参数,但是并不发送请求（ ）","[{'optionContent': 'A.send()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'send()'}, {'optionContent': 'B.open()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'open()'}, {'optionContent': 'C.readyState()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'readyState()'}, {'optionContent': 'D.XMLHttpRequest()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'XMLHttpRequest()'}]","open() 方法用来初始化 HTTP 请求参数,但是并不发送请求。 选项B正确",B
"(单选题)创建 XMLHttpRequest 对象的部分代码如下，请在空白处填入关键代码( )。 
//„省略的代码  
if(window.XMLHttpRequest)
{  xmlHttpRequest=________________ }
else{  xmlHttpRequest=_________________ }  ","[{'optionContent': 'A.new XMLHttpRequest();\nnew ActiveXObject(""Microsoft.XMLHTTP"");', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'new XMLHttpRequest();\nnew ActiveXObject(""Microsoft.XMLHTTP"");'}, {'optionContent': 'B.new XMLHttpRequest();\nnew ActiveXObject();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'new XMLHttpRequest();\nnew ActiveXObject();'}, {'optionContent': 'C.new ActiveXObject(""Microsoft.XMLHTTP"");\nnew XMLHttpRequest();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'new ActiveXObject(""Microsoft.XMLHTTP"");\nnew XMLHttpRequest();'}, {'optionContent': 'D.new ActiveXObject();\nnew XMLHttpRequest();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'new ActiveXObject();\nnew XMLHttpRequest();'}]",此题目考查的是XMLHttpRequest 对象的创建。 固定写法，只有A选项正确,A
(单选题)XMLHttpRequest 对象的 readyState 属性值为（ ）时，代表请求成功数据接收完毕。,"[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '4'}]",此题目考查的是AJAX的readyState属性的状态 0 － （未初始化）还没有调用send()方法 1 － （载入）已调用send()方法，正在发送请求 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 3 － （交互）正在解析响应内容 4 － （完成）响应内容解析完成，可以在客户端调用了,D
(单选题)XmlHttpRequest对象的readyState状态，当xhr.readyState==1表示：（ ）,"[{'optionContent': 'A.正在发送请求', 'isCorrect': '-1', 'option': 'A', 'optionValue': '正在发送请求'}, {'optionContent': 'B.请求完成', 'isCorrect': '-1', 'option': 'B', 'optionValue': '请求完成'}, {'optionContent': 'C.请求成功，服务器正在接收数据', 'isCorrect': '-1', 'option': 'C', 'optionValue': '请求成功，服务器正在接收数据'}, {'optionContent': 'D.浏览器接收数据成功', 'isCorrect': '-1', 'option': 'D', 'optionValue': '浏览器接收数据成功'}]",此题目考查的是AJAX的readyState属性的状态 0 － （未初始化）还没有调用send()方法 1 － （载入）已调用send()方法，正在发送请求 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 3 － （交互）正在解析响应内容 4 － （完成）响应内容解析完成，可以在客户端调用了,A
(多选题)下面（ ）不是 XMLHttpRequest 对象的方法。,"[{'optionContent': 'A.open()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'open()'}, {'optionContent': 'B.send()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'send()'}, {'optionContent': 'C.readState', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'readState'}, {'optionContent': 'D.responseText', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'responseText'}]",此题目考查的是XMLHttpRequest 对象 选项CD属于XMLHttpRequest 对象的属性，不是方法，本题选CD,"C,D"
(多选题)以下是 Ajax 的 XMLHttpRequest 对象属性的有（ ）。 ,"[{'optionContent': 'A.onreadystatechange', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'onreadystatechange'}, {'optionContent': 'B.abort', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'abort'}, {'optionContent': 'C.responseText', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'responseText'}, {'optionContent': 'D.status', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'status'}]",此题目考查的是XMLHttpRequest 对象属性 abort不属于XMLHttpRequest 对象的属性,"A,C,D"
(单选题)在jquery中想要实现通过远程http get请求载入信息功能的是下面的哪一个事件？,"[{'optionContent': 'A.$.ajax()', 'isCorrect': '-1', 'option': 'A', 'optionValue': '$.ajax()'}, {'optionContent': 'B.load(url)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'load(url)'}, {'optionContent': 'C.$.get(url)', 'isCorrect': '-1', 'option': 'C', 'optionValue': '$.get(url)'}, {'optionContent': 'D.getScript(url)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'getScript(url)'}]","A.ajax() 方法通过 HTTP 请求加载远程数据。 $.ajax(opts); opts为json格式，常见参数url、type、data等。 B.load() 方法从服务器加载数据，并把返回的数据放入被选元素中。$(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是 load() 方法完成后所执行的函数名称。 C.$.get() 方法通过 HTTP GET 请求从服务器上请求数据。 $.get(URL,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 callback 参数是请求成功后所执行的函数名。 D.getScript() 方法通过 HTTP GET 请求载入并执行 JavaScript 文件。 jQuery.getScript(url,success(response,status));",C
(单选题)请按XMLHttpRequest发送请求的一般步骤的顺序从以下选项中选择正确的答案：（ ）,"[{'optionContent': 'A.create XMLHttpRequest xhr\nxhr.open()\nxhr.onreadstatechange\nxhr.send()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'create XMLHttpRequest xhr\nxhr.open()\nxhr.onreadstatechange\nxhr.send()'}, {'optionContent': 'B.create XMLHttpRequest xhr\nxhr.onreadstatechange\nxhr.send()\nxhr.open()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'create XMLHttpRequest xhr\nxhr.onreadstatechange\nxhr.send()\nxhr.open()'}, {'optionContent': 'C.create XMLHttpRequest xhr\nxhr.onreadstatechange\nxhr.open()\nxhr.send()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'create XMLHttpRequest xhr\nxhr.onreadstatechange\nxhr.open()\nxhr.send()'}, {'optionContent': 'D.create XMLHttpRequest xhr\nxhr.open()\nxhr.send()\nxhr.onreadstatechange', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'create XMLHttpRequest xhr\nxhr.open()\nxhr.send()\nxhr.onreadstatechange'}]",此题目考查的是XMLHttpRequest发送请求的步骤 只要当readyState属性的值由一个值变成另一个值时，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 虽然A选项执行也可以正常通过，但此操作仍会存在问题隐患。 所以C选项正确,C
"(单选题)下面哪个对象用于在后台与服务器交换数据,能够在不重新加载整个网页（刷新）的情况下,对网页进行部分刷新（ ）","[{'optionContent': 'A.HttpRequest', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HttpRequest'}, {'optionContent': 'B.ActiveXObject', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'ActiveXObject'}, {'optionContent': 'C.statusText', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'statusText'}, {'optionContent': 'D.XMLHttpRequest', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'XMLHttpRequest'}]","XMLHttpRequest 对象用于在后台与服务器交换数据,能够在不重新加载整个网页（刷新）的情况下,对网页进行部分更新。 选项D正确",D
"(多选题)关于下列代码描述正确的是：（）。
$.ajax({
  url:'findById',    
  type:'GET',     
  data:{'id':$('#cb1').val()},
  dataType:'json',
  success:function(data,statusText){
    //待补充
  },
  error:function(xhr,e1,e2){
    alert('系统错误');
  }
});","[{'optionContent': 'A.发送请求的类型是GET', 'isCorrect': '-1', 'option': 'A', 'optionValue': '发送请求的类型是GET'}, {'optionContent': 'B.预期服务器返回XML格式数据', 'isCorrect': '-1', 'option': 'B', 'optionValue': '预期服务器返回XML格式数据'}, {'optionContent': 'C.发送到服务器的参数名字是id', 'isCorrect': '-1', 'option': 'C', 'optionValue': '发送到服务器的参数名字是id'}, {'optionContent': 'D.代码function(data,statusText)中的data表示服务器返回的数据', 'isCorrect': '-1', 'option': 'D', 'optionValue': '代码function(data,statusText)中的data表示服务器返回的数据'}]",此题目考查的是jQuery中的ajax()函数。 ajax()函数中，type属性表示发送请求的方式，data属性表示发送到服务器的参数 dataType属性表示服务器返回数据处理后的类型，success属性表示请求成功处理后调用的函数。 本题中，预期服务器返回的数据需要符合json格式 故选项B错误，ACD均正确。,"A,C,D"
(多选题)以下（）函数是jQuery内置的与AJAX相关的函数。 ,"[{'optionContent': 'A.$.ajax()', 'isCorrect': '-1', 'option': 'A', 'optionValue': '$.ajax()'}, {'optionContent': 'B.$.get()', 'isCorrect': '-1', 'option': 'B', 'optionValue': '$.get()'}, {'optionContent': 'C.$.post()', 'isCorrect': '-1', 'option': 'C', 'optionValue': '$.post()'}, {'optionContent': 'D.$.each()', 'isCorrect': '-1', 'option': 'D', 'optionValue': '$.each()'}]",此题目考查的是jQuery函数 与AJAX相关的jQuery内置函数有： $.Ajax()、$.get()、$.post()、$.load()、$.getJSON() D选项错误,"A,B,C"
(多选题)下面哪几个不属于jQuery的事件处理函数（ ）,"[{'optionContent': 'A.bind()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'bind()'}, {'optionContent': 'B.click()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'click()'}, {'optionContent': 'C.change()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'change()'}, {'optionContent': 'D.one()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'one()'}]","事件处理函数包括： bind(type, [data], fn) one(type, [data], fn) trigger(type, [data]) triggerHandler(type, [data]) unbind([type], [data]) BC选项属于事件","B,C"
"(多选题)以下这段配置，说法正确的是（ ）。
<bean id=""bar1"" class=""ioc.autowire.Bar"" autowire=""byName""/>","[{'optionContent': 'A.容器会采取自动装配的方式来建立依赖关系。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '容器会采取自动装配的方式来建立依赖关系。'}, {'optionContent': 'B.byName指定的是查找与属性名称一致的bean，调用set方法来完成注入。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'byName指定的是查找与属性名称一致的bean，调用set方法来完成注入。'}, {'optionContent': 'C.byName有可能找到多个符合条件的bean，会出错。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'byName有可能找到多个符合条件的bean，会出错。'}, {'optionContent': 'D.autowire的值还可以是byType和constructor。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'autowire的值还可以是byType和constructor。'}]","考查DI的基础知识，容器可以依据属性名称或者类型来完成自动装配，如果值为byName,容器会查找与属性名称一致的bean，并调用对应的set方法来完成注入。 因为本题中bar1是bean的id，所以是唯一的，所以不可能找到多个符合要求的bean。","A,B,D"
"(多选题)以下这段配置，说法正确的是（ ）。
<bean id=""mp"" class=""ioc.set.MobilePhone"">
		<property name=""brand"" value=""华为mate8""/>
		<property name=""cpu"" value=""麒麟""/>
		<property name=""ram"" value=""2G""/>
</bean>","[{'optionContent': 'A.这里采用了set方式注入。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '这里采用了set方式注入。'}, {'optionContent': 'B.这里采用了构造器方式注入。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '这里采用了构造器方式注入。'}, {'optionContent': 'C.MobilePhone类一定有setBrand方法。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'MobilePhone类一定有setBrand方法。'}, {'optionContent': 'D.MobilePhone类一定有brand属生。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'MobilePhone类一定有brand属生。'}]",注意，依据以上配置，spring容器会去调用setBrand方法，但并不表名MobilePhone类一定具有brand属性。以上配置不属于构造方法注入方式。,"A,C"
(多选题)IOC有哪几种注入方式(),"[{'optionContent': 'A.构造函数注入', 'isCorrect': '-1', 'option': 'A', 'optionValue': '构造函数注入'}, {'optionContent': 'B.属性注入', 'isCorrect': '-1', 'option': 'B', 'optionValue': '属性注入'}, {'optionContent': 'C.接口注入', 'isCorrect': '-1', 'option': 'C', 'optionValue': '接口注入'}, {'optionContent': 'D.以上都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上都不对'}]",IOC具有三种注入方式，分别是构造函数注入、属性注入和接口注入。,"A,B,C"
"(多选题)以下这段配置，说法正确的是（ ）。
<util:properties id=""config"" location=""classpath:config.properties""/>
<bean id=""db"" class=""ioc.common.DemoBean"">
		<property name=""brand"" value=""#{mp.brand}""/>
		<property name=""interest"" value=""#{user.interest[1]}""/>
		<property name=""city"" value=""#{user.cities[1]}""/>
		<property name=""score"" value=""#{user.scores.english}""/>
		<property name=""pwd"" value=""#{user.info.pwd}""/>
		<property name=""pagesize"" value=""#{config.pagesize}""/>
		<property name=""type"" value=""""/>
</bean>","[{'optionContent': 'A.spring表达式语法非常类似el表达式。', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'spring表达式语法非常类似el表达式。'}, {'optionContent': 'B.spring表达式可以读取bean或者集合中的数据。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'spring表达式可以读取bean或者集合中的数据。'}, {'optionContent': 'C.#{user.interest[1]} 表示读取id为user的bean的inerest属性，该属性值是一个List集合，1表示集合中的下标。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '#{user.interest[1]} 表示读取id为user的bean的inerest属性，该属性值是一个List集合，1表示集合中的下标。'}, {'optionContent': 'D.value=""""是错误的用法。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'value=""""是错误的用法。'}]","考查spring表达式的用法，value=""""表示赋值为空字符串，是正确的。","A,B,C"
(多选题)以下几个注解，描述正确的是（ ）。,"[{'optionContent': 'A.@Component是业务层注解。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '@Component是业务层注解。'}, {'optionContent': 'B.@Repository是持久化层组件注解。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '@Repository是持久化层组件注解。'}, {'optionContent': 'C.@Service 是通用组件注解。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '@Service 是通用组件注解。'}, {'optionContent': 'D.@Controller是控制层组件注解。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '@Controller是控制层组件注解。'}]",在使用自动扫描时，应按照分层架构来选择合适的注解，@Component是通用注解，@Service是业务层组件注解。,"B,D"
(单选题)Spring AOP是什么（）,"[{'optionContent': 'A.控制反转', 'isCorrect': '-1', 'option': 'A', 'optionValue': '控制反转'}, {'optionContent': 'B.面向切面编程', 'isCorrect': '-1', 'option': 'B', 'optionValue': '面向切面编程'}, {'optionContent': 'C.面向对象编程', 'isCorrect': '-1', 'option': 'C', 'optionValue': '面向对象编程'}, {'optionContent': 'D.以上说法都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上说法都不对'}]",Spring AOP 是面向切面编程，是OOP（面向对象编程）的补充和完善,B
(单选题)下面不属于持久化的是（）,"[{'optionContent': 'A.把对象转换为字符串的形式通过网络传输，在另一端接收到这个字符串后能把对象还原出来', 'isCorrect': '-1', 'option': 'A', 'optionValue': '把对象转换为字符串的形式通过网络传输，在另一端接收到这个字符串后能把对象还原出来'}, {'optionContent': 'B.把程序数据从数据库中读出来', 'isCorrect': '-1', 'option': 'B', 'optionValue': '把程序数据从数据库中读出来'}, {'optionContent': 'C.从XML配置文件中读取程序的配置信息', 'isCorrect': '-1', 'option': 'C', 'optionValue': '从XML配置文件中读取程序的配置信息'}, {'optionContent': 'D.把程序数据保存为文件', 'isCorrect': '-1', 'option': 'D', 'optionValue': '把程序数据保存为文件'}]", 何谓“持久化”持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。持久化顾名思义就是把缓存中的东西放到数据库中使之持久,A
(单选题)关于HQL与SQL，以下哪些说法正确？()。,"[{'optionContent': 'A.HQL与SQL没什么差别', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HQL与SQL没什么差别'}, {'optionContent': 'B.HQL面向对象，而SQL操纵关系数据库', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'HQL面向对象，而SQL操纵关系数据库'}, {'optionContent': 'C.在HQL与SQL中，都包含select,insert,update,delete语句', 'isCorrect': '-1', 'option': 'C', 'optionValue': '在HQL与SQL中，都包含select,insert,update,delete语句'}, {'optionContent': 'D.HQL仅用于查询和删除数据，不支持insert,update语句', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'HQL仅用于查询和删除数据，不支持insert,update语句'}]",详解见两者概念,B
(多选题)下面关于Hibernate说法正确的是()。,"[{'optionContent': 'A.Hibernate是ORM的一种实现方式', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Hibernate是ORM的一种实现方式'}, {'optionContent': 'B.Hibernate不要JDBC的支持', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Hibernate不要JDBC的支持'}, {'optionContent': 'C.属于控制层', 'isCorrect': '-1', 'option': 'C', 'optionValue': '属于控制层'}, {'optionContent': 'D.属于数据持久层', 'isCorrect': '-1', 'option': 'D', 'optionValue': '属于数据持久层'}]","hibernate底层还是jdbc
hibernate属于持久层，","A,D"
(单选题)Hibernate对JDBC访问数据库的代码进行了封装，从而大大的简化了数据访问层的代码，它是针对三层架构中(  )的解决方案。,"[{'optionContent': 'A.表现层', 'isCorrect': '-1', 'option': 'A', 'optionValue': '表现层'}, {'optionContent': 'B.业务逻辑层', 'isCorrect': '-1', 'option': 'B', 'optionValue': '业务逻辑层'}, {'optionContent': 'C.持久化层', 'isCorrect': '-1', 'option': 'C', 'optionValue': '持久化层'}, {'optionContent': 'D.数据库系统', 'isCorrect': '-1', 'option': 'D', 'optionValue': '数据库系统'}]",在三层架构中Hibernate这个框架主要作用于持久层，strus2在表现层，业务层是spring,C
(单选题)下面关于hibernate核心接口说明错误的是？(),"[{'optionContent': 'A.Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象'}, {'optionContent': 'B.SessionFactory 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'SessionFactory 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的'}, {'optionContent': 'C.Query 和Criteria 接口：执行数据库的查询', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Query 和Criteria 接口：执行数据库的查询'}, {'optionContent': 'D.Transaction 接口：管理事务', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Transaction 接口：管理事务'}]",SessionFactory接口:SessionFactroy接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。,B
(单选题)使用Hibernate技术实现数据库持久化时，（）内容不在Hibernate配置文件中,"[{'optionContent': 'A.数据库连接信息', 'isCorrect': '-1', 'option': 'A', 'optionValue': '数据库连接信息'}, {'optionContent': 'B.数据库类型', 'isCorrect': '-1', 'option': 'B', 'optionValue': '数据库类型'}, {'optionContent': 'C.show_sql参数', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'show_sql参数'}, {'optionContent': 'D.数据库表和实体的映射信息', 'isCorrect': '-1', 'option': 'D', 'optionValue': '数据库表和实体的映射信息'}]",映射信息配置在映射文件中,D
"(单选题)下面的程序执行后没有报错，但数据总保存不到数据库，最可能的原因是（ ）。
public static void main(String[] args) {
SessionFactory sf =
new Configuration().configure().buildSessionFactory();
Session session = sf.openSession();
Medal medal = new Medal();
medal.setOwner(""Shen Baozhi"");
medal.setSport(""Table Tennis-Women's Singles"");
medal.setType(""Gold Medal"");
session.save(user);
session.close();
}","[{'optionContent': 'A.配置文件配置有误', 'isCorrect': '-1', 'option': 'A', 'optionValue': '配置文件配置有误'}, {'optionContent': 'B.没有在配置文件中包含对映射文件的声明', 'isCorrect': '-1', 'option': 'B', 'optionValue': '没有在配置文件中包含对映射文件的声明'}, {'optionContent': 'C.映射文件配置有误', 'isCorrect': '-1', 'option': 'C', 'optionValue': '映射文件配置有误'}, {'optionContent': 'D.没有开启事务', 'isCorrect': '-1', 'option': 'D', 'optionValue': '没有开启事务'}]",因为程序没有错误，只是数据库数据无法保存进去，这种情况最大的可能就是事务没有提交,D
(单选题)Hibernate增加数据时可以调用Session的(   )方法。,"[{'optionContent': 'A.save()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'save()'}, {'optionContent': 'B.update()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'update()'}, {'optionContent': 'C.delete()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'delete()'}, {'optionContent': 'D.get()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'get()'}]","增加数据用save（）方法,update()是更新，delete()是删除，get()是取数据",A
"(多选题)对下面代码中存在的错误，说法正确的是（）。
String hql = ""from TblUser u where u.status = @status "";//<1>
Query query = session.createQuery();//<2>
query.setNamedParameter("":status"","""");//<3>
return query.executeQuery(hql);//<4>","[{'optionContent': 'A.第一行中的命名参数“@status”应该是“:status”', 'isCorrect': '-1', 'option': 'A', 'optionValue': '第一行中的命名参数“@status”应该是“:status”'}, {'optionContent': 'B.第二行createQuery 函数应该传入hql 作为参数', 'isCorrect': '-1', 'option': 'B', 'optionValue': '第二行createQuery 函数应该传入hql 作为参数'}, {'optionContent': 'C.第三行命名参数名称“:status”应该是“status”', 'isCorrect': '-1', 'option': 'C', 'optionValue': '第三行命名参数名称“:status”应该是“status”'}, {'optionContent': 'D.第四行应该是“return query.list(hql);”', 'isCorrect': '-1', 'option': 'D', 'optionValue': '第四行应该是“return query.list(hql);”'}]",第四行是没有错误的，返回值是对的,"A,B,C"
(单选题)请问，以下哪些修饰符不能用于顶层类？,"[{'optionContent': 'A.public', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public'}, {'optionContent': 'B.private', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'private'}, {'optionContent': 'C.abstract', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'abstract'}, {'optionContent': 'D.final', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'final'}]",对于顶层类(外部类)来说，只有两种修饰符：public和默认(default)。 因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。 因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。 但是private可以修饰class的，只不过该类不能使顶层类，可以是内部类 内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，父子类(protected)，任何位置(public)。 当一个内部类使用了private修饰后，只能在该类的外部类内部使用,B
(多选题)请问，以下哪些描述是正确的？,"[{'optionContent': 'A.如果package语句存在，则必须出现在源文件的非空白首行。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '如果package语句存在，则必须出现在源文件的非空白首行。'}, {'optionContent': 'B.如果import语句存在，则必须出现在源文件的非空白首行。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '如果import语句存在，则必须出现在源文件的非空白首行。'}, {'optionContent': 'C.如果main()方法存在，则必须出现在源文件的非空白首行。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '如果main()方法存在，则必须出现在源文件的非空白首行。'}, {'optionContent': 'D.如果在源文件中声明了一个public接口，则其名称必须和源文件名一致。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '如果在源文件中声明了一个public接口，则其名称必须和源文件名一致。'}]",B选项import是写在package下 C选项main方法可以放在类里任意一个地方。,"A,D"
(单选题)在创建对象时，必须（ ）,"[{'optionContent': 'A.先声明对象，然后才能使用对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': '先声明对象，然后才能使用对象'}, {'optionContent': 'B.先声明对象，为对象分配内存空间，然后才能使用对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': '先声明对象，为对象分配内存空间，然后才能使用对象'}, {'optionContent': 'C.先声明对象，为对象分配内存空间，对对象初始化，然后才能使用对象', 'isCorrect': '-1', 'option': 'C', 'optionValue': '先声明对象，为对象分配内存空间，对对象初始化，然后才能使用对象'}, {'optionContent': 'D.上述说法都对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '上述说法都对'}]",对象是先声明，声明后会在给对象在内存里开辟空间，之后初始化，再进行使用,C
(多选题) 下列变量命名哪个是合法的（）,"[{'optionContent': 'A.class', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'class'}, {'optionContent': 'B.$abc', 'isCorrect': '-1', 'option': 'B', 'optionValue': '$abc'}, {'optionContent': 'C.1234', 'isCorrect': '-1', 'option': 'C', 'optionValue': '1234'}, {'optionContent': 'D._name', 'isCorrect': '-1', 'option': 'D', 'optionValue': '_name'}]",class是java中的关键字，java中对象的命名不能是全数字,"B,D"
"(多选题)下面选项中哪两个可以在 A 的子类中使用（ ）
class A {
  protected int method1 (int a, int b) {
    return 0;
  }
}","[{'optionContent': 'A.public int method1(int a, int b) { return 0; }', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public int method1(int a, int b) { return 0; }'}, {'optionContent': 'B.private int method1(int a, int b) { return 0; }', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'private int method1(int a, int b) { return 0; }'}, {'optionContent': 'C.private int method1(int a, long b) { return 0; }', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'private int method1(int a, long b) { return 0; }'}, {'optionContent': 'D.public short method1(int a, int b) { return 0; }', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public short method1(int a, int b) { return 0; }'}]",B子类重写父类的方法，访问权限不能降低;C属于重载;D子类重写父类的方法如果返回值类型是基本类型的话，要求相同。,"A,C"
(多选题)下面哪个函数是public void method(){...}的重载函数（ ）,"[{'optionContent': 'A.public void method(int m){...}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public void method(int m){...}'}, {'optionContent': 'B.public int method(){...}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public int method(){...}'}, {'optionContent': 'C.public void method2(){...}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public void method2(){...}'}, {'optionContent': 'D.public int method(int m, float f){...}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public int method(int m, float f){...}'}]",重载：方法名相同且参数列表不同，与返回值类型无关。,"A,D"
"(单选题)以下程序正确的输出是（ ）
package test.father;
public class FatherClass { 
  public FatherClass() { 
    System.out.println(""FatherClass Create"");
  }
}

package test.child;
import test.father.FatherClass;
public class ChildClass extends FatherClass { 
  public ChildClass() { 
    System.out.println(""ChildClass Create"");
  }
  public static void main(String[] args) {
    FatherClass fc = new FatherClass(); 
    ChildClass cc = new ChildClass();
  }
}","[{'optionContent': 'A.FatherClass Create\nFatherClass Create\nChildClass Create', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'FatherClass Create\nFatherClass Create\nChildClass Create'}, {'optionContent': 'B.FatherClass Create\nChildClass Create\nFatherClass Create', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'FatherClass Create\nChildClass Create\nFatherClass Create'}, {'optionContent': 'C.ChildClass Create\nChildClass Create\nFatherClass Create', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ChildClass Create\nChildClass Create\nFatherClass Create'}, {'optionContent': 'D.ChildClass Create\nFatherClass Create', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ChildClass Create\nFatherClass Create'}]",在子类构造方法的开始默认情况下有一句 super();来调用父类的构造方法,A
"(单选题)给定如下代码，下面哪个可以作为该类的构造函数（ ）
public class Test {
// TODO ...
}","[{'optionContent': 'A.public void Test() {// ...}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public void Test() {// ...}'}, {'optionContent': 'B.public Test() {// ...}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public Test() {// ...}'}, {'optionContent': 'C.public static Test() {// ...}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public static Test() {// ...}'}, {'optionContent': 'D.public static void Test() {// ...}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public static void Test() {// ...}'}]",构造方法应与类同名，且没有返回值类型,B
(单选题)设m，n为类A中定义的int型变量名，下列A类的构造方法中不正确的是（）,"[{'optionContent': 'A.void A(int k){m=k;}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'void A(int k){m=k;}'}, {'optionContent': 'B.A(int k){m=k;}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'A(int k){m=k;}'}, {'optionContent': 'C.A(int k,int n){m=i;n=j;}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'A(int k,int n){m=i;n=j;}'}, {'optionContent': 'D.A(){m=0;n=0;}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'A(){m=0;n=0;}'}]",构造方法没有返回类型,A
(单选题)下列说法正确的有（ ）,"[{'optionContent': 'A.class 中的 constructor 不可省略', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'class 中的 constructor 不可省略'}, {'optionContent': 'B.constructor 必须与 class 同名，但方法不能与 class 同名', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'constructor 必须与 class 同名，但方法不能与 class 同名'}, {'optionContent': 'C.constructor 在一个对象被 new 时执行', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'constructor 在一个对象被 new 时执行'}, {'optionContent': 'D.一个 class 只能定义一个 constructor', 'isCorrect': '-1', 'option': 'D', 'optionValue': '一个 class 只能定义一个 constructor'}]",构造方法的作用是在实例化对象的时候给属性成员进行初始化。 A．类中如 果没有显示的给出构造方法，系统会提供一个无参构造方法。 B．构造方法 与类同名，类中可以有和类名相同的方法。 D．构造方法可以重载。,C
"(多选题)给出下面的代码片段：
public class Base {
  int w, x, y, z;
  public Base(int a, int b) {
    x=a; y=b;
  }
  public Base(int a, int b, int c, int d) {
    //assignment x=a, y=b
    w=d; z=c;	
  }
}
在代码说明//assignment x=a, y=b处写下如下哪几个代码是正确的（ ）","[{'optionContent': 'A.Base(a, b);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Base(a, b);'}, {'optionContent': 'B.x=a, y=b;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'x=a, y=b;'}, {'optionContent': 'C.x=a; y=b;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'x=a; y=b;'}, {'optionContent': 'D.this(a, b);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'this(a, b);'}]",C 是直接给 x，y 赋值；D 是使用 this 调用本类中其它的构造方法。,"C,D"
"(多选题)执行下列代码后,哪个结论是正确的（ ）
String[] s=new String[10];","[{'optionContent': 'A.s[9]为null;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 's[9]为null;'}, {'optionContent': 'B.s[10]为"""";', 'isCorrect': '-1', 'option': 'B', 'optionValue': 's[10]为"""";'}, {'optionContent': 'C.s[0]为未定义', 'isCorrect': '-1', 'option': 'C', 'optionValue': 's[0]为未定义'}, {'optionContent': 'D.s.length为10', 'isCorrect': '-1', 'option': 'D', 'optionValue': 's.length为10'}]",s 是引用类型，s 中的每一个成员都是引用类型，即 String 类型，String 类型默认的值为 null，s 数组的长度为 10。,"A,D"
"(单选题)关于以下程序代码的说明正确的是（	）
1．class	HasStatic{
2．  private	static	int	x=100;
3．  public	static	void	main(String	args[	]){
4．    HasStatic	hs1=new	HasStatic();
5．    hs1.x++;
6．    HasStatic	hs2=new	HasStatic();
7．    hs2.x++;
8．    hs1=new	HasStatic();
9．    hs1.x++;
10．   HasStatic.x--;
11．   System.out.println(""x=""+x);
12． }
13．}","[{'optionContent': 'A.5 行不能通过编译，因为引用了私有静态变量', 'isCorrect': '-1', 'option': 'A', 'optionValue': '5 行不能通过编译，因为引用了私有静态变量'}, {'optionContent': 'B.10 行不能通过编译，因为 x 是私有静态变量', 'isCorrect': '-1', 'option': 'B', 'optionValue': '10 行不能通过编译，因为 x 是私有静态变量'}, {'optionContent': 'C.程序通过编译，输出结果为：x=103', 'isCorrect': '-1', 'option': 'C', 'optionValue': '程序通过编译，输出结果为：x=103'}, {'optionContent': 'D.程序通过编译，输出结果为：x=102', 'isCorrect': '-1', 'option': 'D', 'optionValue': '程序通过编译，输出结果为：x=102'}]",静态变量是所有对象所共享的，所以上述代码中的几个对象操作是同一静 态变量x， 静态变量可以通过类名调用。,D
"(单选题)下面关于 import, class 和 package 的声明顺序哪个正确（ ）","[{'optionContent': 'A.package, import, class', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'package, import, class'}, {'optionContent': 'B.class, import, package', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'class, import, package'}, {'optionContent': 'C.import, package, class', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'import, package, class'}, {'optionContent': 'D.package, class, import', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'package, class, import'}]",.java文件中先使用package关键字，其次使用import关键字，最后使用class关键字。,A
"(单选题)已知类 Teacher 和 Student 都是类 Person 的子类，则对于下列代码说法正确的是（ ）
Person t = new Teacher();
if (t instanceof Teacher){	
  Student s = (Student)t; 
}","[{'optionContent': 'A.将构造一个 Student 对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': '将构造一个 Student 对象'}, {'optionContent': 'B.将构造一个 Teacher 对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': '将构造一个 Teacher 对象'}, {'optionContent': 'C.编译出错，且运行时出错', 'isCorrect': '-1', 'option': 'C', 'optionValue': '编译出错，且运行时出错'}, {'optionContent': 'D.编译正确，且运行时出错', 'isCorrect': '-1', 'option': 'D', 'optionValue': '编译正确，且运行时出错'}]",instanceof 是 Java 的一个二元操作符，它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 类型的数据。Teahcer 和 Student 之间没有继承关系不能做强制类型转换。,D
"(单选题)关于以下说法正确的是（ ）
1．class StaticStuff
2．{		
3．  static	int x=10;
4．  static	{x+=5;}
5．  public	static void	main(String args[])
6．  {
7．    System.out.println(""x="" + x);
8．  }
9．  static	{x/=3;}
10.}","[{'optionContent': 'A.4 行与 9 行不能通过编译，因为缺少方法名和返回类型', 'isCorrect': '-1', 'option': 'A', 'optionValue': '4 行与 9 行不能通过编译，因为缺少方法名和返回类型'}, {'optionContent': 'B.9 行不能通过编译，因为只能有一个静态初始化器', 'isCorrect': '-1', 'option': 'B', 'optionValue': '9 行不能通过编译，因为只能有一个静态初始化器'}, {'optionContent': 'C.编译通过，执行结果为：x=5', 'isCorrect': '-1', 'option': 'C', 'optionValue': '编译通过，执行结果为：x=5'}, {'optionContent': 'D.编译通过，执行结果为：x=3', 'isCorrect': '-1', 'option': 'D', 'optionValue': '编译通过，执行结果为：x=3'}]",静态块是类加载的时候就会被执行到的，静态执行顺序是按照在类中出现 的先后顺序执行。,C
(单选题)MAX_LENGTH是int型public成员变量，变量值保持为常量100，用简短语句定义这个变量（ ）,"[{'optionContent': 'A.public int MAX_LENGTH=100;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public int MAX_LENGTH=100;'}, {'optionContent': 'B.final int MAX_LENGTH=100;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'final int MAX_LENGTH=100;'}, {'optionContent': 'C.final private int MAX_LENGTH=100;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'final private int MAX_LENGTH=100;'}, {'optionContent': 'D.public final int MAX_LENGTH=100;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public final int MAX_LENGTH=100;'}]",常量是public final修饰的,D
(单选题)下列关于修饰符混用的说法，错误的是（ ）,"[{'optionContent': 'A.abstract 不能与 final 并列修饰同一个类', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'abstract 不能与 final 并列修饰同一个类'}, {'optionContent': 'B.abstract 类中可以有 private 的成员', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'abstract 类中可以有 private 的成员'}, {'optionContent': 'C.abstract 方法可以放在 abstract 类或接口中', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'abstract 方法可以放在 abstract 类或接口中'}, {'optionContent': 'D.static 方法中能直接使用非 static 的属性', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'static 方法中能直接使用非 static 的属性'}]",静态方法中不能引用其外部的非静态成员,D
(多选题)如下哪些不是 java 的关键字（ ）,"[{'optionContent': 'A.const', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'const'}, {'optionContent': 'B.sum', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'sum'}, {'optionContent': 'C.num', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'num'}, {'optionContent': 'D.this', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'this'}]","java中，num,sum都不属于java 的关键字.","B,C"
(多选题)已知下列选项中的方法是在某个类中定义的，现在子类中不可以定义与下列选项中方法签名相同的方法的选项是（ ）,"[{'optionContent': 'A.final void methoda() {}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'final void methoda() {}'}, {'optionContent': 'B.void methoda() {}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'void methoda() {}'}, {'optionContent': 'C.static void methoda() {}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'static void methoda() {}'}, {'optionContent': 'D.static final void methoda() {}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'static final void methoda() {}'}]",final 修饰方法，在子类中不能被重写。,"A,D"
(多选题)下面关于变量及其范围的陈述哪些是不正确的（ ）,"[{'optionContent': 'A.类中的普通属性是类的实例变量', 'isCorrect': '-1', 'option': 'A', 'optionValue': '类中的普通属性是类的实例变量'}, {'optionContent': 'B.实例变量用关键字static声明', 'isCorrect': '-1', 'option': 'B', 'optionValue': '实例变量用关键字static声明'}, {'optionContent': 'C.局部变量在局部范围外也可以被使用', 'isCorrect': '-1', 'option': 'C', 'optionValue': '局部变量在局部范围外也可以被使用'}, {'optionContent': 'D.局部变量在使用前必须被初始化', 'isCorrect': '-1', 'option': 'D', 'optionValue': '局部变量在使用前必须被初始化'}]",由static修饰的变量称为类变量或是静态变量，局部变量作用域只在局部范围内部。,"B,C"
(单选题)下列哪种说法是正确的（ ）,"[{'optionContent': 'A.本类中实例方法可以调用其他类中所有实例方法', 'isCorrect': '-1', 'option': 'A', 'optionValue': '本类中实例方法可以调用其他类中所有实例方法'}, {'optionContent': 'B.本类中实例方法可以调用其他类中类方法', 'isCorrect': '-1', 'option': 'B', 'optionValue': '本类中实例方法可以调用其他类中类方法'}, {'optionContent': 'C.本类中实例方法可以直接通过方法名调用其他类的实例方法', 'isCorrect': '-1', 'option': 'C', 'optionValue': '本类中实例方法可以直接通过方法名调用其他类的实例方法'}, {'optionContent': 'D.本类中实例方法可以直接通过方法名调用本类中其他实例方法', 'isCorrect': '-1', 'option': 'D', 'optionValue': '本类中实例方法可以直接通过方法名调用本类中其他实例方法'}]",A. 本类实例方法不可以调用其他类的私有实例方法。B. 本类实例方法不可以调用其他类的私有类方法。C．本类实例方法不可以直接通过方法名调用其他类的实例方法。,D
(单选题)关于实例方法和类方法，以下描述正确的是（ ）,"[{'optionContent': 'A.实例方法只能访问实例变量', 'isCorrect': '-1', 'option': 'A', 'optionValue': '实例方法只能访问实例变量'}, {'optionContent': 'B.类方法既可以访问类变量，也可以访问实例变量', 'isCorrect': '-1', 'option': 'B', 'optionValue': '类方法既可以访问类变量，也可以访问实例变量'}, {'optionContent': 'C.类方法只能通过类名来调用', 'isCorrect': '-1', 'option': 'C', 'optionValue': '类方法只能通过类名来调用'}, {'optionContent': 'D.实例方法只能通过对象来调用', 'isCorrect': '-1', 'option': 'D', 'optionValue': '实例方法只能通过对象来调用'}]",A 实例方法可以访问类变量；B 类方法只能访问类变量；C 类方法可以通 过对象调用。,D
(单选题)以下关于面向对象概念的描述中，不正确的一项是（ ）,"[{'optionContent': 'A.在现实生活中，对象是指客观世界的实体', 'isCorrect': '-1', 'option': 'A', 'optionValue': '在现实生活中，对象是指客观世界的实体'}, {'optionContent': 'B.程序中的对象就是现实生活中的实体对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': '程序中的对象就是现实生活中的实体对象'}, {'optionContent': 'C.在程序中，对象是通过一种抽象数据类型来描述的，这种抽象数据类型称\n为类（class）', 'isCorrect': '-1', 'option': 'C', 'optionValue': '在程序中，对象是通过一种抽象数据类型来描述的，这种抽象数据类型称\n为类（class）'}, {'optionContent': 'D.在程序中，对象是一组变量和相关方法的集合', 'isCorrect': '-1', 'option': 'D', 'optionValue': '在程序中，对象是一组变量和相关方法的集合'}]",程序中的对象是一种数据信息，并非现实中的实际物体,B
(多选题)面向对象的主要特征有哪些（）,"[{'optionContent': 'A.封装', 'isCorrect': '-1', 'option': 'A', 'optionValue': '封装'}, {'optionContent': 'B.多态', 'isCorrect': '-1', 'option': 'B', 'optionValue': '多态'}, {'optionContent': 'C.继承', 'isCorrect': '-1', 'option': 'C', 'optionValue': '继承'}, {'optionContent': 'D.抽象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '抽象'}]",面向对象的三大主要特征是：封装，多态，继承,"A,B,C"
(单选题)为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为(),"[{'optionContent': 'A.static void method( )', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'static void method( )'}, {'optionContent': 'B.public void method( )', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public void method( )'}, {'optionContent': 'C.final void method( )', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'final void method( )'}, {'optionContent': 'D.abstract void method( )', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'abstract void method( )'}]",1、public修饰的方法可被其它类访问或引用。 2、abstract修饰的方法是抽象方法，抽象方法没有方法体，要使用抽象方法，必须先实现此抽象方法。 3、final修饰的方法不能被继承。 4、static修饰的方法为静态方法，静态方法不需要类的实例化就可以被类直接调用。 故要使得类名AB可以直接调用method()方法，则必须在method()前用static来修饰。,A
(多选题)下列说法错误的有（ ）,"[{'optionContent': 'A.在类方法中可用 this 来调用本类的类方法', 'isCorrect': '-1', 'option': 'A', 'optionValue': '在类方法中可用 this 来调用本类的类方法'}, {'optionContent': 'B.在类方法中调用本类的类方法时可直接调用', 'isCorrect': '-1', 'option': 'B', 'optionValue': '在类方法中调用本类的类方法时可直接调用'}, {'optionContent': 'C.在类方法中只能调用本类中的类方法', 'isCorrect': '-1', 'option': 'C', 'optionValue': '在类方法中只能调用本类中的类方法'}, {'optionContent': 'D.在类方法中绝对不能调用实例方法', 'isCorrect': '-1', 'option': 'D', 'optionValue': '在类方法中绝对不能调用实例方法'}]",A在类方法中不能使用 this 关键字。C在类方法中可以调用其它类中的类方法。D在类方法中可以通过实例化对象调用实例方法。,"A,C,D"
(单选题)在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数个数、类型或顺序各不相同，传回的值也可以不相同。这种特性称为 （  ）,"[{'optionContent': 'A.隐藏', 'isCorrect': '-1', 'option': 'A', 'optionValue': '隐藏'}, {'optionContent': 'B.覆盖', 'isCorrect': '-1', 'option': 'B', 'optionValue': '覆盖'}, {'optionContent': 'C.重载', 'isCorrect': '-1', 'option': 'C', 'optionValue': '重载'}, {'optionContent': 'D.Java不支持此特性', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Java不支持此特性'}]",重载，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。,C
"(单选题)下述代码的执行结果是（ ）
class Super {
  public int getLength() {
    return 4;
  }
}
public class Sub extends Super {
  public long getLength() {
    return 5;
  }
  public static void main (String[] args) {
    Super sooper = new Super ();
    Super sub = new Sub();
    System.out.println(sooper.getLength() + "","" + sub.getLength());
  }			
}","[{'optionContent': 'A.4,4', 'isCorrect': '-1', 'option': 'A', 'optionValue': '4,4'}, {'optionContent': 'B.4,5', 'isCorrect': '-1', 'option': 'B', 'optionValue': '4,5'}, {'optionContent': 'C.5,4', 'isCorrect': '-1', 'option': 'C', 'optionValue': '5,4'}, {'optionContent': 'D.代码不能被编译', 'isCorrect': '-1', 'option': 'D', 'optionValue': '代码不能被编译'}]",方法重写返回值类型如果是基本类型应与父类的一致,D
"(单选题)下列代码执行的结果是（）。
class Base {
  void test() { 
    System.out.print(""Base.test()"");
  }
}
class Child extends Base { 
  void test() {
    System.out.print(""Child.test()"");
  }
  static public void main(String[] a) {
    Child anObj = new Child();
    Base baseObj = (Base)anObj;
    baseObj.test();
  }
}","[{'optionContent': 'A.Child.test()Base.test()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Child.test()Base.test()'}, {'optionContent': 'B.Base.test()Child.test()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Base.test()Child.test()'}, {'optionContent': 'C.Base.test()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Base.test()'}, {'optionContent': 'D.Child.test()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Child.test()'}]",测试代码相当于：Base baseObj = new Child();父类的引用指向子类的实例，子类又重写了父类 的 test() 方法，因此调用的是子类的 test() 方法。,D
(单选题)Java语言中，使用关键字那个对当前对象的父类对象进行引用（）,"[{'optionContent': 'A.super', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'super'}, {'optionContent': 'B.this', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'this'}, {'optionContent': 'C.new', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'new'}, {'optionContent': 'D.extends', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'extends'}]",当子类隐藏了父类的变量，并重写了父类方法后，又要使用父类变量或父类被重写的方法时，可通过super来实现对父类变量的访问和对父类方法的调用。super是用来引用当前对象的父类。,A
(单选题)JAVA 中（）,"[{'optionContent': 'A.一个子类可以有多个父类，一个父类也可以有多个子类', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一个子类可以有多个父类，一个父类也可以有多个子类'}, {'optionContent': 'B.一个子类可以有多个父类，但一个父类只可以有一个子类', 'isCorrect': '-1', 'option': 'B', 'optionValue': '一个子类可以有多个父类，但一个父类只可以有一个子类'}, {'optionContent': 'C.一个子类可以有一个父类，但一个父类可以有多个子类 ', 'isCorrect': '-1', 'option': 'C', 'optionValue': '一个子类可以有一个父类，但一个父类可以有多个子类 '}, {'optionContent': 'D.上述说法都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '上述说法都不对'}]",Java规定，子类只能有一个父类而父类可以有多个子类,C
"(单选题)在下面程序的第 7 行补充上下列哪个方法,会导致在编译过程中发生
错误（ ）
1)  class Super{
2)    public float getNum(){
3)      return 3.0f;
4)    }
5)  }
6)  public class Sub extends Super{
7)    // TODO ...
8)  }","[{'optionContent': 'A.public float getNum(){retun 4.0f;}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public float getNum(){retun 4.0f;}'}, {'optionContent': 'B.public void getNum(){}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public void getNum(){}'}, {'optionContent': 'C.public void getNum(double d){}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public void getNum(double d){}'}, {'optionContent': 'D.public double getNum(float d){retun 4.0f;}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public double getNum(float d){retun 4.0f;}'}]",方法重写、重载的问题。 重写要求方法签名完全相同，返回值类型如果是基本类型或无返回值时必须一致。重载要求方法名相同且参数列表必须不同，与返回值类型无关。,B
(单选题)从下面四段（A，B，C，D）代码中选择出正确的代码段（ ）,"[{'optionContent': 'A.abstract class Name {\n  private String name;\n  public abstract boolean isStupidName(String name) {}\n}', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'abstract class Name {\n  private String name;\n  public abstract boolean isStupidName(String name) {}\n}'}, {'optionContent': 'B.public class Something {\n  void doSomething () {\n    private String s = """";\n    int l = s.length();\n  }\n}', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public class Something {\n  void doSomething () {\n    private String s = """";\n    int l = s.length();\n  }\n}'}, {'optionContent': 'C.public class Something {\n  public static void main(String[] args) {\n    Other o = new Other();\n    new Something().addOne(o);\n  }\n  public void addOne(final Other o) {\n    o.i++;\n  }\n}\nclass Other {\n  public int i;\n}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public class Something {\n  public static void main(String[] args) {\n    Other o = new Other();\n    new Something().addOne(o);\n  }\n  public void addOne(final Other o) {\n    o.i++;\n  }\n}\nclass Other {\n  public int i;\n}'}, {'optionContent': 'D.public class Something {\n  public int addOne(final int x) { \n    return ++x;\n  }\n}', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public class Something {\n  public int addOne(final int x) { \n    return ++x;\n  }\n}'}]",A. 抽象方法不能有方法体。B．方法中定义的是局部变量，不能用类成员变量修饰符 private。D．final 修饰为常量，常量的值不能被改变。,C
"(单选题)已知A类在package A中, B类在package B中，且B类被声明为public，且
有一个成员变量x被声明为 protected控制方式。C类也位于package A包
中，且继承了B类。则以下说法正确的是（ ）","[{'optionContent': 'A.A 类的实例不能访问到 B 类的实例', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'A 类的实例不能访问到 B 类的实例'}, {'optionContent': 'B.A 类的实例能够访问到 B 类一个实例的 x 成员', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'A 类的实例能够访问到 B 类一个实例的 x 成员'}, {'optionContent': 'C.C 类的实例可以访问到 B 类一个实例的 x 成员', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'C 类的实例可以访问到 B 类一个实例的 x 成员'}, {'optionContent': 'D.C 类的实例不能访问到 B 类的实例', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'C 类的实例不能访问到 B 类的实例'}]",不同包子类的关系， 可以访问到父类 B 的 protected 成员,C
"(单选题)给出如下代码：
class Test{
  private int m;
  public static void fun() {
    //some code?
  }
}
如何使成员变量m可以被函数fun()直接访问（ ）","[{'optionContent': 'A.将private int m改为protected int m', 'isCorrect': '-1', 'option': 'A', 'optionValue': '将private int m改为protected int m'}, {'optionContent': 'B.将private int m改为public int m', 'isCorrect': '-1', 'option': 'B', 'optionValue': '将private int m改为public int m'}, {'optionContent': 'C.将private int m改为static int m', 'isCorrect': '-1', 'option': 'C', 'optionValue': '将private int m改为static int m'}, {'optionContent': 'D.将private int m改为int m', 'isCorrect': '-1', 'option': 'D', 'optionValue': '将private int m改为int m'}]",静态方法中可以直接调用使用其外部的静态成员,C
"(单选题)根据以下代码下面选项正确的是（）：
1.   package foo;
2.   import java.util.Vector;
3.   private class MyVector extends Vector {
4.     int i = 1;
5.     public MyVector() {
6.       i = 2;
7.     }
8.   }
9.   public class MyNewVector extends MyVector {
10.    public MyNewVector () {
11.      i = 4;
12.    }
13.    public static void main (String args []) {
14.      MyVector v = new MyNewVector();
15.    }
16.  }","[{'optionContent': 'A.代码无编译错误', 'isCorrect': '-1', 'option': 'A', 'optionValue': '代码无编译错误'}, {'optionContent': 'B.第3行出现编译错误', 'isCorrect': '-1', 'option': 'B', 'optionValue': '第3行出现编译错误'}, {'optionContent': 'C.第6行出现编译错误', 'isCorrect': '-1', 'option': 'C', 'optionValue': '第6行出现编译错误'}, {'optionContent': 'D.第9行出现编译错误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '第9行出现编译错误'}]",类 MyVector 不能是私有的,B
(单选题)关于被私有访问控制符private修饰的成员变量，以下说法正确的是(),"[{'optionContent': 'A.可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类'}, {'optionContent': 'B.可以被两种类访问和引用：该类本身、该类的所有子类', 'isCorrect': '-1', 'option': 'B', 'optionValue': '可以被两种类访问和引用：该类本身、该类的所有子类'}, {'optionContent': 'C.只能被该类自身所访问和修改', 'isCorrect': '-1', 'option': 'C', 'optionValue': '只能被该类自身所访问和修改'}, {'optionContent': 'D.只能被同一个包中的类访问', 'isCorrect': '-1', 'option': 'D', 'optionValue': '只能被同一个包中的类访问'}]",private修饰的变量说明变量为私有访问。只能被该类自己访问或调用，是对成员变量的高级保护。,C
"(多选题)以下哪个选项可以替换第2行位置的代码，且替换后效果相同（）
1. public interface Foo{
2.   int k = 4;
3. }","[{'optionContent': 'A.final int k = 4;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'final int k = 4;'}, {'optionContent': 'B.public int k = 4;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public int k = 4;'}, {'optionContent': 'C.static int k = 4;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'static int k = 4;'}, {'optionContent': 'D.abstract int k = 4;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'abstract int k = 4;'}]",接口中的属性都是常量，默认由public static final同时修饰，可以省略，abstract不能修饰变量,"A,B,C"
(多选题)属性的可见性有（ ）,"[{'optionContent': 'A.public', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public'}, {'optionContent': 'B.default', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'default'}, {'optionContent': 'C.private', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'private'}, {'optionContent': 'D.protected', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'protected'}]",属性的可见性有四种：公有的(public)、保护的(protected)、默认的(default)、私有的(private),"A,B,C,D"
"(单选题)已知如下代码，下列选项中哪个表达式会编译出错（ ）
interface IFace{}
class CFace implements IFace{}
class Base{}
public class ObRef extends Base{
  public static void main(String argv[]){ 
    ObRef ob = new ObRef();
    Base b = new Base(); 
    Object o1 = new Object(); 
    IFace o2 = new CFace();
  }
}","[{'optionContent': 'A.o1=o2;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'o1=o2;'}, {'optionContent': 'B.b=ob;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'b=ob;'}, {'optionContent': 'C.ob=b;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ob=b;'}, {'optionContent': 'D.o1=b;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'o1=b;'}]",b 是 ob 的父类，将父类引用赋值给子类型变量上需要强制类型转换,C
"(单选题)A派生出子类B ，B派生出子类C，并且在Java源代码中有如下声明：
A a0=new A();
A a1 =new B();
A a2=new C();
问以下哪个说法是正确的？ （ ）","[{'optionContent': 'A.只有第1行能通过编译', 'isCorrect': '-1', 'option': 'A', 'optionValue': '只有第1行能通过编译'}, {'optionContent': 'B.第1、2行能通过编译，但第3行编译出错', 'isCorrect': '-1', 'option': 'B', 'optionValue': '第1、2行能通过编译，但第3行编译出错'}, {'optionContent': 'C.第1、2、3行能通过编译，但第2、3行运行时出错', 'isCorrect': '-1', 'option': 'C', 'optionValue': '第1、2、3行能通过编译，但第2、3行运行时出错'}, {'optionContent': 'D.第1行、第2行和第3行的声明都是正确的', 'isCorrect': '-1', 'option': 'D', 'optionValue': '第1行、第2行和第3行的声明都是正确的'}]",都属于父类引用指向子类对象,D
(单选题)Runnable接口的实现类中必须定义以下哪个方法（ ）,"[{'optionContent': 'A.void run()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'void run()'}, {'optionContent': 'B.public void run()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public void run()'}, {'optionContent': 'C.public void start()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public void start()'}, {'optionContent': 'D.public void run(int priority)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public void run(int priority)'}]",实现 Runnable 接口，接口中有一个抽象方法 run，实现类中重写该方法，且该方法是public修饰的。,B
(单选题)下列哪一种叙述是正确的（ ）,"[{'optionContent': 'A.abstract 修饰符可修饰字段、方法和类', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'abstract 修饰符可修饰字段、方法和类'}, {'optionContent': 'B.抽象方法的 body 部分必须用一对大括号{ }包住', 'isCorrect': '-1', 'option': 'B', 'optionValue': '抽象方法的 body 部分必须用一对大括号{ }包住'}, {'optionContent': 'C.声明抽象方法，大括号可有可无', 'isCorrect': '-1', 'option': 'C', 'optionValue': '声明抽象方法，大括号可有可无'}, {'optionContent': 'D.声明抽象方法不可写出大括号', 'isCorrect': '-1', 'option': 'D', 'optionValue': '声明抽象方法不可写出大括号'}]",abstract可以修饰方法和类，不能修饰属性。抽象方法没有方法体，即没有 大括号{},D
(单选题)关于抽象方法说法正确的是（ ）,"[{'optionContent': 'A.不可以是静态的', 'isCorrect': '-1', 'option': 'A', 'optionValue': '不可以是静态的'}, {'optionContent': 'B.可以有方法体', 'isCorrect': '-1', 'option': 'B', 'optionValue': '可以有方法体'}, {'optionContent': 'C.可以在普通类中定义', 'isCorrect': '-1', 'option': 'C', 'optionValue': '可以在普通类中定义'}, {'optionContent': 'D.只能存在于抽象类中', 'isCorrect': '-1', 'option': 'D', 'optionValue': '只能存在于抽象类中'}]",抽象方法不可以是静态的，不可以有方法体，不可以在普通类中定义，可以在接口中和抽象类中定义。,A
"(单选题)在JAVA中，已定义两个接口B和C,要定义一个实现这两个接口的类，以下语句正确的是（ ）。","[{'optionContent': 'A.interface A extend B,C', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'interface A extend B,C'}, {'optionContent': 'B.interface A implements B,C', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'interface A implements B,C'}, {'optionContent': 'C.class A implements B,C', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'class A implements B,C'}, {'optionContent': 'D.class A implements B, implements C ', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'class A implements B, implements C '}]",因为是类实现所以开头是class，implements只用写一次。,C
(单选题)下列概念中不包括任何实现，与存储空间没有任何关系的是（）,"[{'optionContent': 'A.类', 'isCorrect': '-1', 'option': 'A', 'optionValue': '类'}, {'optionContent': 'B.接口', 'isCorrect': '-1', 'option': 'B', 'optionValue': '接口'}, {'optionContent': 'C.抽象类', 'isCorrect': '-1', 'option': 'C', 'optionValue': '抽象类'}, {'optionContent': 'D.对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '对象'}]",接口是一种只含有抽象方法或常量的一种特殊的抽象类，因为接口不包括任何实现，所以与存储空间没有任何关系。,B
(单选题)java7版本以前，下列有关接口的叙述错误的是哪项？(),"[{'optionContent': 'A.接口中只能包含抽象方法和常量', 'isCorrect': '-1', 'option': 'A', 'optionValue': '接口中只能包含抽象方法和常量'}, {'optionContent': 'B.一个类可以实现多个接口', 'isCorrect': '-1', 'option': 'B', 'optionValue': '一个类可以实现多个接口'}, {'optionContent': 'C.非抽象的类实现接口时必须实现其中的所有抽象方法', 'isCorrect': '-1', 'option': 'C', 'optionValue': '非抽象的类实现接口时必须实现其中的所有抽象方法'}, {'optionContent': 'D.类可以继承接口', 'isCorrect': '-1', 'option': 'D', 'optionValue': '类可以继承接口'}]",java8以前，接口只能被类实现，类不能继承接口，遵循单继承多实现原则。java8以后，接口中可以包含静态方法和默认方法。,D
(单选题)下列关于 interface 的说法正确的是（ ）,"[{'optionContent': 'A.interface 中可以有 private 方法', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'interface 中可以有 private 方法'}, {'optionContent': 'B.interface 中可以有 final 方法', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'interface 中可以有 final 方法'}, {'optionContent': 'C.interface 中可以有 function 实现', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'interface 中可以有 function 实现'}, {'optionContent': 'D.interface 可以继承其他 interface', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'interface 可以继承其他 interface'}]",A. 接口中不可以有 private 的方法。B．接口中不可以有 final 的方法 接口中的方法默认是 public abstract 的。C．接口中的方法不可以有实现,D
(单选题)接口是 Java 面向对象的实现机制之一，以下说法正确的是（ ）,"[{'optionContent': 'A.Java 支持多重继承，一个类可以实现多个接口', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Java 支持多重继承，一个类可以实现多个接口'}, {'optionContent': 'B.Java 只支持单重继承，但一个类可以实现多个接口', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Java 只支持单重继承，但一个类可以实现多个接口'}, {'optionContent': 'C.Java 只支持单重继承，一个类只可以实现一个接口', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Java 只支持单重继承，一个类只可以实现一个接口'}, {'optionContent': 'D.Java 支持多重继承，但一个类只可以实现一个接口', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Java 支持多重继承，但一个类只可以实现一个接口'}]",Java支持单重继承，一个类只能继承自另外的一个类，但是一个类可以实 现多个接口。,B
(多选题)在JAVA 8.0版本之前，接口中可以定义(   )。,"[{'optionContent': 'A.静态方法', 'isCorrect': '-1', 'option': 'A', 'optionValue': '静态方法'}, {'optionContent': 'B.常量', 'isCorrect': '-1', 'option': 'B', 'optionValue': '常量'}, {'optionContent': 'C.构造方法 ', 'isCorrect': '-1', 'option': 'C', 'optionValue': '构造方法 '}, {'optionContent': 'D.抽象方法', 'isCorrect': '-1', 'option': 'D', 'optionValue': '抽象方法'}]",java8之前，接口中只能定义常量和抽象方法。,"B,D"
(多选题)不能用来修饰 interface 的有（ ）,"[{'optionContent': 'A.private', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'private'}, {'optionContent': 'B.public', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public'}, {'optionContent': 'C.protected', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'protected'}, {'optionContent': 'D.static', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'static'}]",修饰接口可以是public和默认,"A,C,D"
"(单选题)以下程序的运行结果是（）
1. public static void main(String[] args) { 
2.   Object obj = new Object() {
3.     public int hashCode() {
4.       return 42;
5.     }
6.   }; 
7.   System.out.println(obj.hashCode());
8. }","[{'optionContent': 'A.42', 'isCorrect': '-1', 'option': 'A', 'optionValue': '42'}, {'optionContent': 'B.运行时出错', 'isCorrect': '-1', 'option': 'B', 'optionValue': '运行时出错'}, {'optionContent': 'C.第2行位置编译出错', 'isCorrect': '-1', 'option': 'C', 'optionValue': '第2行位置编译出错'}, {'optionContent': 'D.第7行位置编译出错', 'isCorrect': '-1', 'option': 'D', 'optionValue': '第7行位置编译出错'}]",匿名内部类中已覆盖 了hashCode 方法。,A
"(单选题)下面是文档注释的是
","[{'optionContent': 'A./**  */\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '/**  */\n'}, {'optionContent': 'B.//\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '//\n'}, {'optionContent': 'C./*  */\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '/*  */\n'}, {'optionContent': 'D.//*/\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '//*/\n'}]","此题目考查的是注释的了解,A选项是文档注释,BC是普通的注释,D选项格式错误 因此A是正确的选项。",A
"(多选题)下列文档注释规范说明正确的是
","[{'optionContent': 'A.@author Lee Boynton代表作者\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '@author Lee Boynton代表作者\n'}, {'optionContent': 'B.@version 1.2.1代表版本号\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '@version 1.2.1代表版本号\n'}, {'optionContent': 'C.@see import java.util.Arrays;代表参见\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '@see import java.util.Arrays;代表参见\n'}, {'optionContent': 'D.@since JDK1.8 代表JDK版本\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '@since JDK1.8 代表JDK版本\n'}]","此题目考查的是文档注释的规范,以上选项均正确 因此ABCD是正确的选项。","A,B,C,D"
"(多选题)有关javadoc命令生成文档叙述正确的是
","[{'optionContent': 'A.如果是一个包命令为javadoc –d docDir nameOfPackage\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': '如果是一个包命令为javadoc –d docDir nameOfPackage\n'}, {'optionContent': 'B.如果是一个包命令为javadoc –d docDir nameOfPackages\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': '如果是一个包命令为javadoc –d docDir nameOfPackages\n'}, {'optionContent': 'C.如果文件在默认包中命令为javadoc –d docDir *.java\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '如果文件在默认包中命令为javadoc –d docDir *.java\n'}, {'optionContent': 'D.如果文件在默认包中命令为javadoc –d docDir *.javac\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': '如果文件在默认包中命令为javadoc –d docDir *.javac\n'}]","此题目考查的是javadoc命令生成文档的了解,BD语法错误,AC均正确 因此AC是正确的选项。","A,C"
"(单选题)Java 语言中，String类的charAt ()方法返回的类型是（ ）
","[{'optionContent': 'A.int\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int\n'}, {'optionContent': 'B.char\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'char\n'}, {'optionContent': 'C.double\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'double\n'}, {'optionContent': 'D.float\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'float\n'}]","此题目考查的是String类的charAt ()方法返回的类型,返回值类型是char类型
因此B是正确的选项。
",B
"(单选题)已知如下代码：
String s = ""Example"";
下列选项中可以编译通过的是（ ）","[{'optionContent': 'A.s>>>=3;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 's>>>=3;'}, {'optionContent': 'B.s[3]= ""X"";', 'isCorrect': '-1', 'option': 'B', 'optionValue': 's[3]= ""X"";'}, {'optionContent': 'C.int i = s.length;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int i = s.length;'}, {'optionContent': 'D.s = s +10;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 's = s +10;'}]",A 移位运算需要整数类型才可以； B s不是数组，数组才有length属性，字符串只有length()方法； C String类有length()方法而不是属性； D 属于字符串拼接操作。,D
"(单选题)下面代码的运行结果为：（）
public class foo{
    public static void main (String[] args){
        String s;
        System.out.println(""s="" + s);
    }
}","[{'optionContent': 'A.代码得到编译，并输出“s=”', 'isCorrect': '-1', 'option': 'A', 'optionValue': '代码得到编译，并输出“s=”'}, {'optionContent': 'B.代码得到编译，并输出“s=null”', 'isCorrect': '-1', 'option': 'B', 'optionValue': '代码得到编译，并输出“s=null”'}, {'optionContent': 'C.由于String s没有初始化，代码不能编译通过', 'isCorrect': '-1', 'option': 'C', 'optionValue': '由于String s没有初始化，代码不能编译通过'}, {'optionContent': 'D.代码得到编译，但捕获到 NullPointException异常', 'isCorrect': '-1', 'option': 'D', 'optionValue': '代码得到编译，但捕获到 NullPointException异常'}]",Java中所有定义的基本类型或对象都必须初始化才能输出值。,C
"(单选题)指出下列程序运行的结果（ ）
public class Example{
  String str=new String(""good"");
  char[]ch={'a','b','c'};
  public static void main(String args[]){
    Example ex=new Example();
    ex.change(ex.str,ex.ch);
    System.out.print(ex.str+"" and "");
    System.out.print(ex.ch);
  }
  public void change(String str,char ch[]){
    str=""test ok"";
    ch[0]='g';
  }
}","[{'optionContent': 'A.good and abc', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'good and abc'}, {'optionContent': 'B.good and gbc', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'good and gbc'}, {'optionContent': 'C.test ok and abc', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'test ok and abc'}, {'optionContent': 'D.test ok and gbc', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'test ok and gbc'}]",引用类型变量保存的是对象的地址，一个对象可以同时被多个变量所引用，并且操作，一个变量只能引用一个对象，对一个对象进行操作。,B
(单选题)关于 java.lang.String 类，以下描述正确的一项是（	）,"[{'optionContent': 'A.String 类是 final 类故不可以继承', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String 类是 final 类故不可以继承'}, {'optionContent': 'B.String 类是 final 类故可以继承', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String 类是 final 类故可以继承'}, {'optionContent': 'C.String 类不是 final 类故不可以继承', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'String 类不是 final 类故不可以继承'}, {'optionContent': 'D.String 类不是 final 类故可以继承', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'String 类不是 final 类故可以继承'}]",String 类是 final 的，在 java 中 final 修饰类的不能被继承,A
"(单选题)下面代码的打印结果是
String s1=""abc"";
String s2=""abc"";
System.out.println(s1==s2);
System.out.println(s1.equals(s2));
","[{'optionContent': 'A.true,true\n', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'true,true\n'}, {'optionContent': 'B.true,false\n', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'true,false\n'}, {'optionContent': 'C.false, false\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'false, false\n'}, {'optionContent': 'D.false,ture\n', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'false,ture\n'}]","此题目考查的是对于java常量池的理解, java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，常量池存在于方法区中。根据代码顺序，先在常量池中创建”abc“，并指向s1,而后在创建s2时，由于常量池中已经存在”abc“，只需指向s2就可以，而不需要再创建。”==”在这里比较的是对象引用，故结果为”true”,String 中的equals方法经过重写后操作为“比较此字符串与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的字符序列的 String 对象时，结果才为 true”。很明显，s1和s2的字符序列相同，故而结果为true
因此A是正确的选项。
",A
"(单选题)以下代码的执行结果是（ ）
public class Base {
  private void test() {
    System.out.println(6 + 6 + ""(Result)"");
  }
  static public void main(String[] a) {
    new Base().test();
  }
}","[{'optionContent': 'A.66(Result)', 'isCorrect': '-1', 'option': 'A', 'optionValue': '66(Result)'}, {'optionContent': 'B.12(Result)', 'isCorrect': '-1', 'option': 'B', 'optionValue': '12(Result)'}, {'optionContent': 'C.运行时出错。不能将一个int转成一个String。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '运行时出错。不能将一个int转成一个String。'}, {'optionContent': ""D.Compilation Error.Incompatible type for +. Can't add a string to an int.\n运行时出错。不能将一个String与一个int相加。"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""Compilation Error.Incompatible type for +. Can't add a string to an int.\n运行时出错。不能将一个String与一个int相加。""}]","字符串与基本数据类型链接的问题,如果第一个是字符串那么后续就都按字符串处理，比如上边例子要是 System.out.println(""(Result)""+6 + 6 );那么结果就是(Result)66，如果第一个和第二个…..第 n 个都是基本数据第 n+1 是字符串类型，那么前 n 个都按加法计算出结果在与字符串连接",B
(单选题)Java 语言中，String类的indexOf()方法返回的类型是（ ）,"[{'optionContent': 'A.int16', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int16'}, {'optionContent': 'B.int32', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int32'}, {'optionContent': 'C.int', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int'}, {'optionContent': 'D.long', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'long'}]",indexOf 方法的声明为：public int indexOf(int ch)在此对象表示的字符序列中第一次出现该字符的索引；如果未出现该字符，则返回 -1。,C
"(单选题)以下代码编译运行的结果是（）。
public class Base{
  private void test() {
    String aStr = ""? One? "";
    String bStr = aStr;
    aStr.toUpperCase();
    aStr.trim();
    System.out.println(""["" + aStr + "","" + bStr + ""]"");
  }
  static public void main(String[] a) {
    new Base().test();
  }
}","[{'optionContent': 'A.[ONE,?One?]', 'isCorrect': '-1', 'option': 'A', 'optionValue': '[ONE,?One?]'}, {'optionContent': 'B.[? One? ,One ]', 'isCorrect': '-1', 'option': 'B', 'optionValue': '[? One? ,One ]'}, {'optionContent': 'C.[ONE,ONE]', 'isCorrect': '-1', 'option': 'C', 'optionValue': '[ONE,ONE]'}, {'optionContent': 'D.[? One? ,? One? ]', 'isCorrect': '-1', 'option': 'D', 'optionValue': '[? One? ,? One? ]'}]","通过 String bStr = aStr;这句代码使 bStr 和 aStr 指向同一个地址空间，所以最后 aStr 和 bStr 的结 果应该是一样，String 类是定长字符串，调用一个字符串的方法以后会形成一个新的字符串。
在调用toUpperCase()和trim()方法时都会返回新的字符串对象，
而题目中在调用完这两个方法后并没有使用变量接收方法所返回的新字符串对象，而aStr和bStr所引用的仍然是原来的字符串对象。
所以选项D正确。",D
"(单选题)以下代码的输出结果是（）
public class Test {
  public static void main(String[] args) { 
    String str = NULL;
   System.out.println(str);
  }
}","[{'optionContent': 'A.NULL', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'NULL'}, {'optionContent': 'B.代码不能通过编译', 'isCorrect': '-1', 'option': 'B', 'optionValue': '代码不能通过编译'}, {'optionContent': 'C.没有输出结果', 'isCorrect': '-1', 'option': 'C', 'optionValue': '没有输出结果'}, {'optionContent': 'D.运行时出错', 'isCorrect': '-1', 'option': 'D', 'optionValue': '运行时出错'}]","String类型变量取值应为小写null或其他用""""双引号括起来的内容",B
"(多选题)String s = new String(""hello"");	
String t = new String(""hello"");
char c [ ] = {'h', 'e', 'l', 'l', 'o'}; 
下列哪些表达式返回 true （ ）","[{'optionContent': 'A.s.equals(t);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 's.equals(t);'}, {'optionContent': 'B.t.equals(c);', 'isCorrect': '-1', 'option': 'B', 'optionValue': 't.equals(c);'}, {'optionContent': 'C.s==t;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 's==t;'}, {'optionContent': 'D.t.equals (new String(""hello""));', 'isCorrect': '-1', 'option': 'D', 'optionValue': 't.equals (new String(""hello""));'}]",String类的equals方法已经覆盖了Object类的equals方法，比较的是两个字符串的内容是否相等，双等号比较的是两个对象的内存地址是否相等,"A,D"
"(单选题)正则表达式""\d+\.?\d{1,2}""在匹配下列字符串时结果失败的是（ ）","[{'optionContent': 'A.""12.5""', 'isCorrect': '-1', 'option': 'A', 'optionValue': '""12.5""'}, {'optionContent': 'B.""1.025""', 'isCorrect': '-1', 'option': 'B', 'optionValue': '""1.025""'}, {'optionContent': 'C.""0125""', 'isCorrect': '-1', 'option': 'C', 'optionValue': '""0125""'}, {'optionContent': 'D.""125.00""', 'isCorrect': '-1', 'option': 'D', 'optionValue': '""125.00""'}]","\d+ 表示可以出现 1 次或是 n 次数字 \. ? 表示"".""可以出现 1 次，也可以不出现 \d{1,2} 表示最少出现 1 次 最多出现 2 次数字",B
(单选题)判断两个字符串的内容是否相同，下面哪个选项正确（ ）,"[{'optionContent': 'A.==', 'isCorrect': '-1', 'option': 'A', 'optionValue': '=='}, {'optionContent': 'B.=', 'isCorrect': '-1', 'option': 'B', 'optionValue': '='}, {'optionContent': 'C.equals（）', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'equals（）'}, {'optionContent': 'D.以上的都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上的都不对'}]",equals（）方法用来判断字符串的内容是否相同 ==用来比较字符串对象的地址是否相同 =用来赋值,C
"(单选题)下面代码的执行结果是（ ）
import java.util.*;
public class ShortSet{
  public static void main(String args[]){
    Set<Short> s=new HashSet<Short>();
    for(Short i=0;i<100;i++) {
      s.add(i);
      s.remove(i-1);
    } 
    System.out.println(s.size());
  }
}","[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.100', 'isCorrect': '-1', 'option': 'B', 'optionValue': '100'}, {'optionContent': 'C.Throws Exception.', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Throws Exception.'}, {'optionContent': 'D.None of the Above.', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'None of the Above.'}]","i是Short类型i-1是int类型,其包装类为 Integer，所以s.remove(i-1);不能移除Set集合中Shor类型对象。",B
"(单选题)请选出下列正确的答案（ ）
1.   import java.util.*;
2.   public class WrappedString {
3.     private String s;
4.     public WrappedString(String s) { this.s = s; }
5.     public static void main(String[] args) {
6.       HashSet<Object> hs = new HashSet<Object>();
7.       WrappedString ws1 = new WrappedString(""aardvark"");
8.       WrappedString ws2 = new WrappedString(""aardvark"");
9.       String s1 = new String(""aardvark"");
10.      String s2 = new String(""aardvark"");
11.      hs.add(ws1); hs.add(ws2); hs.add(s1); hs.add(s2);
12.      System.out.println(hs.size()); } }","[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.4', 'isCorrect': '-1', 'option': 'B', 'optionValue': '4'}, {'optionContent': 'C.2', 'isCorrect': '-1', 'option': 'C', 'optionValue': '2'}, {'optionContent': 'D.3', 'isCorrect': '-1', 'option': 'D', 'optionValue': '3'}]",HashSet集合里面存储的元素是无序的且不重复的，本题中的是s1和s2两个对象在底层判断时返回的相关信息被视为相同元素，所以最终结果集合中值有3个元素。,D
(单选题)Java的集合框架中重要的接口java.util.Collection定义了许多方法。选项中哪个方法不是Collection接口所定义的（ ）,"[{'optionContent': 'A.int size()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int size()'}, {'optionContent': 'B.boolean containsAll(Collection c)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'boolean containsAll(Collection c)'}, {'optionContent': 'C.int compareTo(Object obj)', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int compareTo(Object obj)'}, {'optionContent': 'D.boolean equals(Object o);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'boolean equals(Object o);'}]",请参考api文档手册,C
(单选题)以下哪个不是Collection的子接口?(    )。,"[{'optionContent': 'A.List', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'List'}, {'optionContent': 'B.Set', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Set'}, {'optionContent': 'C.Map', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Map'}, {'optionContent': 'D.SortedSet', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'SortedSet'}]",Map与Collection是两个不同的接口，没有继承关系。,C
(单选题)如果要保证元素唯一，且按照存放顺序读取，可以选用（ ）,"[{'optionContent': 'A.Map', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Map'}, {'optionContent': 'B.Set', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Set'}, {'optionContent': 'C.LinkedList', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'LinkedList'}, {'optionContent': 'D.LinkedHashSet', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'LinkedHashSet'}]",请参考集合结构特点及元素存取,D
(单选题)欲构造 ArrayList 类的一个实例，此类继承了 List 接口，下列哪个方法是正确的（ ）,"[{'optionContent': 'A.ArrayList myList = new Object();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'ArrayList myList = new Object();'}, {'optionContent': 'B.List myList = new ArrayList();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'List myList = new ArrayList();'}, {'optionContent': 'C.ArraylList myList = new List();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ArraylList myList = new List();'}, {'optionContent': 'D.List myList = new List();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'List myList = new List();'}]",接口不能new，Object对象不能直接转型成ArrayList类型。,B
"(单选题)关于以下代码描述正确的有（ ）
public class Cats {
  public static void main(String args[]) {
    List<Cat> cats = new ArrayList<Cat>();
    cats.add(new Cat());
    Animal b = new Animal();
    Cat a = null;
    if(b instanceof Animal) 
      a = (Cat)b;
    if(a != null) 
      cats.add(a);
    System.out.println(cats.size() +""cats"");
  }
}
class Animal {}
class Cat extends Animal{}","[{'optionContent': 'A.编译失败', 'isCorrect': '-1', 'option': 'A', 'optionValue': '编译失败'}, {'optionContent': 'B.输出1 cats', 'isCorrect': '-1', 'option': 'B', 'optionValue': '输出1 cats'}, {'optionContent': 'C.输出2 cats', 'isCorrect': '-1', 'option': 'C', 'optionValue': '输出2 cats'}, {'optionContent': 'D.运行时抛出异常', 'isCorrect': '-1', 'option': 'D', 'optionValue': '运行时抛出异常'}]",a = (Cat)b;处抛出java.lang.ClassCastException异常，b为Animal类型，并且具体引用对象是Animal对象，不能强转成Cat类型。,D
(单选题)下面哪个是链式存储并快速顺序(不需要随机访问)访问的集合类型（ ）,"[{'optionContent': 'A.java.util.LinkedList', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'java.util.LinkedList'}, {'optionContent': 'B.java.util.Queue', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'java.util.Queue'}, {'optionContent': 'C.java.util.ArrayList', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'java.util.ArrayList'}, {'optionContent': 'D.java.util.LinearList', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'java.util.LinearList'}]",请参考集合队列的结构特点及元素的存取,B
(多选题)以下集合对象中哪几个是线程安全的（）,"[{'optionContent': 'A.LinkedList', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'LinkedList'}, {'optionContent': 'B.ArrayList', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'ArrayList'}, {'optionContent': 'C.Vector', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Vector'}, {'optionContent': 'D.Hashtable', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Hashtable'}]","Collection 是对象集合， Collection 有两个子接口 List 和 Set,
List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的
ArrayList ， Vector ， LinkedList 是 List 的实现类
ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的
LinkedList 是线程不安全的，底层是由链表实现的
Map 是键值对集合
HashTable 和 HashMap 是 Map 的实现类
HashTable 是线程安全的，不能存储 null 值
HashMap 不是线程安全的，可以存储 null 值","C,D"
(多选题)关于 Java 语言，下列描述正确的是（ ）,"[{'optionContent': 'A.switch不能够作用在String类型上', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'switch不能够作用在String类型上'}, {'optionContent': 'B.List, Set, Map都继承自Collection接口', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'List, Set, Map都继承自Collection接口'}, {'optionContent': 'C.Java语言支持goto语句', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Java语言支持goto语句'}, {'optionContent': 'D.GC是垃圾收集器，程序员不用担心内存管理', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'GC是垃圾收集器，程序员不用担心内存管理'}]","B. Map没有继承Collection接口；
C. java不支持goto语句。","A,D"
(单选题)关于集合类以下说法错误的是（ ）,"[{'optionContent': 'A.Vector是线程安全的', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Vector是线程安全的'}, {'optionContent': 'B.ArrayList是线程安全的', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'ArrayList是线程安全的'}, {'optionContent': 'C.HashMap中可以存放null值作为key', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'HashMap中可以存放null值作为key'}, {'optionContent': 'D.Set中存放的对象是唯一的', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Set中存放的对象是唯一的'}]",ArrayList不是线程安全的,B
(多选题)链表具有的特点是（ ）,"[{'optionContent': 'A.不必事先估计存储空间', 'isCorrect': '-1', 'option': 'A', 'optionValue': '不必事先估计存储空间'}, {'optionContent': 'B.可随机访问任一元素', 'isCorrect': '-1', 'option': 'B', 'optionValue': '可随机访问任一元素'}, {'optionContent': 'C.插入删除不需要移动元素', 'isCorrect': '-1', 'option': 'C', 'optionValue': '插入删除不需要移动元素'}, {'optionContent': 'D.所需空间与线性表长度成正比', 'isCorrect': '-1', 'option': 'D', 'optionValue': '所需空间与线性表长度成正比'}]","A. 采用动态存储分配，不会造成内存浪费和溢出。
B. 不能随机访问，查找时要从头指针开始遍历
C. 插入、删除时，只要找到对应前驱结点，修改指针即可，无需移动元素
D. 需要用额外空间存储线性表的关系，存储密度小","A,C,D"
(单选题)HashSet子类依靠( )方法区分重复元素。,"[{'optionContent': 'A.toString(),equals()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'toString(),equals()'}, {'optionContent': 'B.clone(),equals()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'clone(),equals()'}, {'optionContent': 'C.hashCode(),equals()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'hashCode(),equals()'}, {'optionContent': 'D.getClass(),clone()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'getClass(),clone()'}]",HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。,C
"(单选题)在Java中，""目录""被看作是（）","[{'optionContent': 'A.文件', 'isCorrect': '-1', 'option': 'A', 'optionValue': '文件'}, {'optionContent': 'B.流', 'isCorrect': '-1', 'option': 'B', 'optionValue': '流'}, {'optionContent': 'C.数据', 'isCorrect': '-1', 'option': 'C', 'optionValue': '数据'}, {'optionContent': 'D.接口', 'isCorrect': '-1', 'option': 'D', 'optionValue': '接口'}]",目录在Java中作为一种特殊文件，即文件名的列表，通过类File所提供的方法，可得到文件或目录的描述信息（包括名字、路径、长度、可读、可写等），也可以生成新文件、目录、修改文件和目录，查询文件属性，重命名文件或者删除文件。,A
(单选题)RandomAccessFile是java.io包中的一个兼有输入输出功能的类。以下说法正确的是(),"[{'optionContent': 'A.可以选择文件中的任意位置开始操作', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以选择文件中的任意位置开始操作'}, {'optionContent': 'B.必须从文件中的终止位置开始操作', 'isCorrect': '-1', 'option': 'B', 'optionValue': '必须从文件中的终止位置开始操作'}, {'optionContent': 'C.必须从文件中的起始位置开始操作', 'isCorrect': '-1', 'option': 'C', 'optionValue': '必须从文件中的起始位置开始操作'}, {'optionContent': 'D.必须从文件中的某个固定位置开始操作', 'isCorrect': '-1', 'option': 'D', 'optionValue': '必须从文件中的某个固定位置开始操作'}]",文件操作中经常需要的是随机访问，Java中的RandomAccessFile类提供了随意访问文件的功能，它继承了Object类，用DataInput和DataOutput接口来实现。接口中定义了从流中读/写基本类型的数据方法，因此也可以随意读/写数据文件的记录。,A
(单选题)计算机中的流是(),"[{'optionContent': 'A.流动的字节', 'isCorrect': '-1', 'option': 'A', 'optionValue': '流动的字节'}, {'optionContent': 'B.流动的对象', 'isCorrect': '-1', 'option': 'B', 'optionValue': '流动的对象'}, {'optionContent': 'C.流动的文件', 'isCorrect': '-1', 'option': 'C', 'optionValue': '流动的文件'}, {'optionContent': 'D.流动的数据缓冲区', 'isCorrect': '-1', 'option': 'D', 'optionValue': '流动的数据缓冲区'}]",流，最早从C语言中引入的。其可以看成是一个流动的数据缓冲区。数据从数据源方向经过缓冲区流向数据的目的地。在传送的过程中，其传送方式是串行的。在Java中的java.io包中定义了Java中常见流的接口与类。其中包括两个最基本的流的抽象类，它们分别是OutputStream与InputStream。其余的流都分别从这两个基本类中继承而来。,D
(单选题)FilterOutputStream是BufferedOutputStream、DataOutputStream及PrintStream的父类，以下哪个类可能是FilterOutputStream构造函数的参数类型（ ）,"[{'optionContent': 'A.OutputStream', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'OutputStream'}, {'optionContent': 'B.File', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'File'}, {'optionContent': 'C.InputStream', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'InputStream'}, {'optionContent': 'D.BufferedOutputStream', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'BufferedOutputStream'}]",请参考api文档手册,A
(单选题)下面哪个流类属于面向字符的输入流（ ）,"[{'optionContent': 'A.ByteArrayInputStream', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'ByteArrayInputStream'}, {'optionContent': 'B.FileInputStream', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'FileInputStream'}, {'optionContent': 'C.ObjectInputStream', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ObjectInputStream'}, {'optionContent': 'D.InputStreamReader', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'InputStreamReader'}]",A、B、C 3个都是字节流,D
(单选题)Java I/O 程序设计中，下列描述正确的是（ ）,"[{'optionContent': 'A.OutputStream用于写操作', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'OutputStream用于写操作'}, {'optionContent': 'B.InputStream用于写操作', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'InputStream用于写操作'}, {'optionContent': 'C.I/O库不支持对文件可读可写API', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'I/O库不支持对文件可读可写API'}, {'optionContent': 'D.InputStream是一个接口', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'InputStream是一个接口'}]",B. InputStream用于读操作； C. I/O支持对文件的读写； D. InputStream是一个抽象类。,A
"(单选题)getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（）
    public void getCustomerInfo() {
        try {
            // do something that may cause an Exception
        } catch (java.io.FileNotFoundException ex) {
            System.out.print(""FileNotFoundException!"");
        } catch (java.io.IOException ex) {
            System.out.print(""IOException!"");
        } catch (java.lang.Exception ex) {
            System.out.print(""Exception!"");
        }
    }","[{'optionContent': 'A.IOException!', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'IOException!'}, {'optionContent': 'B.IOException!Exception!', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'IOException!Exception!'}, {'optionContent': 'C.FileNotFoundException!IOException!', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'FileNotFoundException!IOException!'}, {'optionContent': 'D.FileNotFoundException!IOException!Exception!', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'FileNotFoundException!IOException!Exception!'}]",考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。,A
"(单选题)下列选项中可以填写在'Point X'处的是（）
public class ExceptionTest {
  class TestException extends Exception {}
  public void runTest () throws TestException {}
  public void test () /* Point X*/{
    runTest ();
  }
}","[{'optionContent': 'A.throws TestException', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'throws TestException'}, {'optionContent': 'B.catch (Exception e)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'catch (Exception e)'}, {'optionContent': 'C.throws RuntimeException.', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'throws RuntimeException.'}, {'optionContent': 'D.catch (TestException e).', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'catch (TestException e).'}]",方法上应使用 throws 抛出异常，test()方法中执行调用了runTest()方法，而runTest()方法抛出的是TestException异常，所以A符合要求。,A
(单选题)下面关于java.lang.Exception类的说法正确的是（）,"[{'optionContent': 'A.继承自Throwable ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '继承自Throwable '}, {'optionContent': 'B.继承自Serialable', 'isCorrect': '-1', 'option': 'B', 'optionValue': '继承自Serialable'}, {'optionContent': 'C.继承自Error', 'isCorrect': '-1', 'option': 'C', 'optionValue': '继承自Error'}, {'optionContent': 'D.以上说法均不正确', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上说法均不正确'}]",Java异常的基类为java.lang.Throwable，java.lang.Error和java.lang.Exception继承 Throwable，RuntimeException和其它的Exception等继承Exception。,A
(多选题)final、finally、finalize三个关键字的区别是（）,"[{'optionContent': 'A.final是修饰符（关键字）可以修饰类、方法、变量 ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'final是修饰符（关键字）可以修饰类、方法、变量 '}, {'optionContent': 'B.finally在异常处理的时候使用，提供finally块来执行任何清除操作', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'finally在异常处理的时候使用，提供finally块来执行任何清除操作'}, {'optionContent': 'C.finalize是方法名，在垃圾收入集器将对象从内存中清除出去之前做必要的清理工作 ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'finalize是方法名，在垃圾收入集器将对象从内存中清除出去之前做必要的清理工作 '}, {'optionContent': 'D.finally和finalize一样都是用异常处理的方法 ', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'finally和finalize一样都是用异常处理的方法 '}]",finally是关键字不是方法,"A,B,C"
(单选题)下列不是异常体系中Exception类包括的异常类的有(  ),"[{'optionContent': 'A.Error', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Error'}, {'optionContent': 'B.NullPointerException', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'NullPointerException'}, {'optionContent': 'C.SQLException', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'SQLException'}, {'optionContent': 'D.InputMismathException', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'InputMismathException'}]",一个程序在编译和运行时出现的错误我们统一称之为异常； 一个合理的应用程序不能截获的严重的问题属于错误。,A
(单选题)下列哪种异常是检查型异常，需要在编写程序时声明（ ）,"[{'optionContent': 'A.NullPointerException', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'NullPointerException'}, {'optionContent': 'B.ClassCastException', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'ClassCastException'}, {'optionContent': 'C.FileNotFoundException', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'FileNotFoundException'}, {'optionContent': 'D.IndexOutOfBoundsException', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'IndexOutOfBoundsException'}]",A、B、D 3个异常都属于运行时异常,C
(多选题)关于异常(Exception)，下列描述正确的是（ ）,"[{'optionContent': 'A.异常的基类为 Exception，所有异常都必须直接或者间接继承它', 'isCorrect': '-1', 'option': 'A', 'optionValue': '异常的基类为 Exception，所有异常都必须直接或者间接继承它'}, {'optionContent': 'B.异常可以用 try{ . . .}catch(Exception e){ . . .}来捕获并进行处理', 'isCorrect': '-1', 'option': 'B', 'optionValue': '异常可以用 try{ . . .}catch(Exception e){ . . .}来捕获并进行处理'}, {'optionContent': 'C.如果某异常继承 RuntimeException，则该异常可以不被声明', 'isCorrect': '-1', 'option': 'C', 'optionValue': '如果某异常继承 RuntimeException，则该异常可以不被声明'}, {'optionContent': 'D.异常可以随便处理，而不是抛给外层的程序进行处理', 'isCorrect': '-1', 'option': 'D', 'optionValue': '异常可以随便处理，而不是抛给外层的程序进行处理'}]",异常可以在自己方法内部处理，当自己无法解决时，需要抛出给调用者来处理。,"A,B,C"
"(单选题)下面程序的运行结果：（）
public static void main(String args[]) {
        Thread t = new Thread() {
            public void run() {
                pong();
            }
        };
        t.run();
        System.out.print(""ping"");
    }
    static void pong() {
        System.out.print(""pong"");
    }","[{'optionContent': 'A.pingpong', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'pingpong'}, {'optionContent': 'B.pongping', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'pongping'}, {'optionContent': 'C.pingpong和pongping都有可能 ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'pingpong和pongping都有可能 '}, {'optionContent': 'D.都不输出', 'isCorrect': '-1', 'option': 'D', 'optionValue': '都不输出'}]",这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程，进而调用run()方法来执行任务，而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使用start()而不是run(),B
(单选题)关于线程设计，下列描述正确的是（ ）,"[{'optionContent': 'A.线程对象必须实现 Runnable 接口', 'isCorrect': '-1', 'option': 'A', 'optionValue': '线程对象必须实现 Runnable 接口'}, {'optionContent': 'B.启动一个线程直接调用线程对象的 run()方法', 'isCorrect': '-1', 'option': 'B', 'optionValue': '启动一个线程直接调用线程对象的 run()方法'}, {'optionContent': 'C.Java 提供对多线程同步提供语言级的支持', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Java 提供对多线程同步提供语言级的支持'}, {'optionContent': 'D.一个线程可以包含多个进程', 'isCorrect': '-1', 'option': 'D', 'optionValue': '一个线程可以包含多个进程'}]",A. 线程对象也可以继承Thread B. 启动线程需要调用start()方法 D. 一个进程可以包含多个线程,C
(单选题)线程生命周期中正确的状态是(),"[{'optionContent': 'A.新建状态、运行状态和终止状态 ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '新建状态、运行状态和终止状态 '}, {'optionContent': 'B.新建状态、运行状态、阻塞状态和终止状态', 'isCorrect': '-1', 'option': 'B', 'optionValue': '新建状态、运行状态、阻塞状态和终止状态'}, {'optionContent': 'C.新建状态、可运行状态、运行状态、阻塞状态和终止状态', 'isCorrect': '-1', 'option': 'C', 'optionValue': '新建状态、可运行状态、运行状态、阻塞状态和终止状态'}, {'optionContent': 'D.新建状态、可运行状态、运行状态、恢复状态和终止状态', 'isCorrect': '-1', 'option': 'D', 'optionValue': '新建状态、可运行状态、运行状态、恢复状态和终止状态'}]",线程生命周期：新建状态、可运行状态、运行状态、阻塞状态和终止状态,C
(多选题)有关线程的哪些叙述是对的（ ）,"[{'optionContent': 'A.一旦一个线程被创建，它就立即开始运行。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一旦一个线程被创建，它就立即开始运行。'}, {'optionContent': 'B.使用 start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '使用 start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。'}, {'optionContent': 'C.当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面。'}, {'optionContent': 'D.一个线程可能因为不同的原因停止并进入就绪状态。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '一个线程可能因为不同的原因停止并进入就绪状态。'}]",线程被创建后不可能立即开始运行。 不同优先级的线程间是抢先式的，同级线程间是轮转式的。 即使线程因为抢先而停止也不一定就进入可运行队列的前面。 而同级线程是轮换式的，它的运行可能就是因为轮换，而它因抢占而停止后只能在轮换队列中排队而不能排在前面。,"B,D"
(单选题)在主线程中启动新线程后，新线程处于就绪状态，那么新线程对象中的哪个方法被系统执行时，视为已经进入执行新线程的内容（ ）,"[{'optionContent': 'A.public void start()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public void start()'}, {'optionContent': 'B.public void run()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'public void run()'}, {'optionContent': 'C.public static void main(Stirng[] args)', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'public static void main(Stirng[] args)'}, {'optionContent': 'D.public void runnable()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'public void runnable()'}]",线程的执行计划是在run方法中的。,B
"(单选题)请选出正确的一项（ ）
1. public class ThreadTest {
2.   public static void main (String[] args) {
3.     new Thread(new Runnable() {
4.       public void run() {
5.         System.out.print(""bar"");
6.       }}).start();
7.   }
8. }","[{'optionContent': 'A.Compilation fails.', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Compilation fails.'}, {'optionContent': 'B.An exception is thrown at runtime.', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'An exception is thrown at runtime.'}, {'optionContent': 'C.The code executes normally, but nothing prints.', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'The code executes normally, but nothing prints.'}, {'optionContent': 'D.The code executes normally and prints ""bar"".', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'The code executes normally and prints ""bar"".'}]",此段代码使用的是匿名类的写法，线程执行时，所执行的内容是其执行计划中的内容，也就是run方法中所定义的逻辑。,D
"(单选题)请选择正确的一项（ ）
1.   public class Threads3 implements Runnable {  
2.     public void run() {  
3.       System.out.print(""running"");  
4.     }  
5.     public static void main(String[] args) {  
6.       Thread t = new Thread(new Threads3());  
7.       t.run();  
8.       t.run();  
9.       t.start(); 
10.    }  
11.  }","[{'optionContent': 'A.The code executes and prints ""runningrunning"".', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'The code executes and prints ""runningrunning"".'}, {'optionContent': 'B.The code executes and prints ""runningrunningrunning"".', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'The code executes and prints ""runningrunningrunning"".'}, {'optionContent': 'C.The code executes and prints ""running"".', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'The code executes and prints ""running"".'}, {'optionContent': 'D.An exception is thrown at runtime.', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'An exception is thrown at runtime.'}]",在执行t.start();之前所执行的两个t.run();只是单纯的通过虚拟机进行调用该方法，t.start();执行后会将该线程置于就绪状态，等待系统分配时间片段给该线程去执行线程任务。,B
(单选题)下列有关线程的说法正确的是（ ）,"[{'optionContent': 'A.启动一个线程是调用start（）方法，是线程所代表的虚拟处理机处于可运行状态，这意味着线程此时就会立即运行。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '启动一个线程是调用start（）方法，是线程所代表的虚拟处理机处于可运行状态，这意味着线程此时就会立即运行。'}, {'optionContent': 'B.notify（）方法可以确切的唤醒某个处于等待状态的线程。', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'notify（）方法可以确切的唤醒某个处于等待状态的线程。'}, {'optionContent': 'C.wait（）方法可以使一个线程处于等待状态，但不会释放所持有对象的锁。', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'wait（）方法可以使一个线程处于等待状态，但不会释放所持有对象的锁。'}, {'optionContent': 'D.sleep（）方法使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法时，需要捕捉InterruptedException异常。', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'sleep（）方法使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法时，需要捕捉InterruptedException异常。'}]",线程调用start方法后不会立即运行此线程，而是将该线程处于就绪状态；notify方法不能确切唤醒某个整处于等待状态的线程，而是需要通过其他线程来调用该等待线程中的notify方法来唤醒该线程；wait方法会释放掉锁。,D
(单选题)关于 sleep()和 wait()，以下描述错误的一项是（ ）,"[{'optionContent': 'A.sleep 是线程类（Thread）的方法，wait 是 Object 类的方法', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'sleep 是线程类（Thread）的方法，wait 是 Object 类的方法'}, {'optionContent': 'B.sleep 不释放对象锁，wait 放弃对象锁', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'sleep 不释放对象锁，wait 放弃对象锁'}, {'optionContent': 'C.sleep 暂停线程、但监控状态仍然保持，结束后会自动恢复', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'sleep 暂停线程、但监控状态仍然保持，结束后会自动恢复'}, {'optionContent': 'D.wait 后进入等待锁定池，只有针对此对象发出 notify 方法后获得对象锁进入运行状态', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'wait 后进入等待锁定池，只有针对此对象发出 notify 方法后获得对象锁进入运行状态'}]",sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控 状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。 wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对 象锁进入运行状态。,D
(单选题)以下哪个方法用于定义线程的执行体（ ）,"[{'optionContent': 'A.start()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'start()'}, {'optionContent': 'B.init()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'init()'}, {'optionContent': 'C.run()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'run()'}, {'optionContent': 'D.main()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'main()'}]",run 方法是线程的执行体,C
(单选题)方法 resume()负责恢复哪些线程的执行（ ）,"[{'optionContent': 'A.通过调用 stop()方法而停止的线程。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '通过调用 stop()方法而停止的线程。'}, {'optionContent': 'B.通过调用 sleep()方法而停止的线程。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '通过调用 sleep()方法而停止的线程。'}, {'optionContent': 'C.通过调用 wait()方法而停止的线程。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '通过调用 wait()方法而停止的线程。'}, {'optionContent': 'D.通过调用 suspend()方法而停止的线程。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '通过调用 suspend()方法而停止的线程。'}]",suspend 可以挂起一个线程，就是把这个线程暂停了，它占着资源，但不运行，用 resume 是恢复挂起 的线程，让这个线程继续执行下去。,D
"(单选题)下列程序的功能是在控制台上，每隔1秒钟显示字符串""Hello"",能够填写在程序中下划线位置，使程序完整，并能够正确运行的语句是（ ）
public class Test implements Runnable{
  public static void main(String[] args){
    Test t=new Test();
    Thread tt=new Thread(t);
    tt.start();
  }
  public void run(){
    for(;;){
      try{
        __________
      }catch(_________  e ){}
      System.out.println(“Hello”);
    } 
  }
}","[{'optionContent': 'A.Thread. sleep (1000)  InterruptedException', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Thread. sleep (1000)  InterruptedException'}, {'optionContent': 'B.sleep (1000)  InterruptedException', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'sleep (1000)  InterruptedException'}, {'optionContent': 'C.t. sleep (1000)  InterruptedException', 'isCorrect': '-1', 'option': 'C', 'optionValue': 't. sleep (1000)  InterruptedException'}, {'optionContent': 'D.Thread. sleep (1000)  RuntimeException', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Thread. sleep (1000)  RuntimeException'}]",睡眠需要笤俑Thread的sleep方法，传入参数为一个long类型毫秒值，本题中要求间隔时间为1秒，所以需要传入1000毫秒作为参数。打断睡眠程序会抛出InterruptedException异常。,A
(多选题)下面能让线程停止执行的有（ ）,"[{'optionContent': 'A.sleep();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'sleep();'}, {'optionContent': 'B.stop();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'stop();'}, {'optionContent': 'C.notify();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'notify();'}, {'optionContent': 'D.wait();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'wait();'}]",sleep：导致此线程暂停执行指定时间； stop：这个方法将终止所有未结束的方法，包括 run 方法； wait：当前正在被服务的线程需要睡一会，醒来后继续被服务。,"A,B,D"
(单选题)Java语言中，负责并发管理的机制是() ,"[{'optionContent': 'A.垃圾回收', 'isCorrect': '-1', 'option': 'A', 'optionValue': '垃圾回收'}, {'optionContent': 'B.虚拟机 ', 'isCorrect': '-1', 'option': 'B', 'optionValue': '虚拟机 '}, {'optionContent': 'C.代码安全', 'isCorrect': '-1', 'option': 'C', 'optionValue': '代码安全'}, {'optionContent': 'D.多线程', 'isCorrect': '-1', 'option': 'D', 'optionValue': '多线程'}]",Java语言中，负责并发管理的机制是多线程,D
"(单选题)代码执行后输出的结果是（ ）
public class Z{
  public static void main(String[] args){
    new Z();
  }
  Z(){
    Z alias1 = this;
    Z alias2 = this;
    synchronized (alias1){
      try{
        alias2.wait();
        System.out.println(""DONE WAITING"");
      } catch (InterruptedException e) {
        System.out.println(""IN TEEEUPTED"");
      } catch (Exception e) {
        System.out.println(""OTHER EXCEPTION"");
      } finally {
        System.out.println(""FINALLY"");
      }
    }
    System.out.println(""ALL DONE"");
  }
}","[{'optionContent': ""A.The application compiles but doesn't print anything."", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""The application compiles but doesn't print anything.""}, {'optionContent': 'B.The application compiles and print ""DONE WAITING"".', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'The application compiles and print ""DONE WAITING"".'}, {'optionContent': 'C.The application compiles and print ""FINALLY"".', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'The application compiles and print ""FINALLY"".'}, {'optionContent': 'D.The application compiles and print ""ALL DONE"".', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'The application compiles and print ""ALL DONE"".'}]",wait方法和sleep方法很类似，都是处于等待状态，但是不同的是，wait方法执行后会释放锁对象，所以此段代码中wait方法后面的语句不会被执行，而是一直处于等待状态中。,A
(单选题)以下哪一个是错误的（ ）,"[{'optionContent': 'A.public synchronized void go() { /* code here */ }', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'public synchronized void go() { /* code here */ }'}, {'optionContent': 'B.private synchronized(this) void go() { /* code here */ }', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'private synchronized(this) void go() { /* code here */ }'}, {'optionContent': 'C.void go() {\n  Object o = new Object();\n  synchronized(o) { /* code here */ }\n}', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'void go() {\n  Object o = new Object();\n  synchronized(o) { /* code here */ }\n}'}, {'optionContent': 'D.synchronized(Object.class) { /* code here */ }', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'synchronized(Object.class) { /* code here */ }'}]",如果在方法声明时给该方法加锁，只需要使用synchronized关键字来修饰该方法即可，不需要传入任何对象，只有在方法内部的某些代码块中才需要传入对象参数。,B
(单选题)下列可以解析XML的有（ ）,"[{'optionContent': 'A.CSS', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'CSS'}, {'optionContent': 'B.DTD', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DTD'}, {'optionContent': 'C.SAX', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'SAX'}, {'optionContent': 'D.XSL', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'XSL'}]",java 解析 xml 文件四种方式：SAX、DOM、JDOM、DOM4J,C
(单选题)在 XML 中用于注释的符号是（ ）,"[{'optionContent': 'A.<!--\t-->', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<!--\t-->'}, {'optionContent': 'B.<?--\t--?>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<?--\t--?>'}, {'optionContent': 'C.<%\t%>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<%\t%>'}, {'optionContent': 'D.<!--\t--!>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<!--\t--!>'}]",XML文档注释符号是,A
(单选题)属性（）用来表示XML文档所使用的字符集。,"[{'optionContent': 'A.version', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'version'}, {'optionContent': 'B.encoding', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'encoding'}, {'optionContent': 'C.standalone', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'standalone'}, {'optionContent': 'D.type', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'type'}]",定义xml文档时，通过encoding属性来指定字符集,B
"(单选题)<?xml version=""1.0"" encoding=""GB2312""?>
<!ELEMENT Customer EMPTY>
<!ATTLIST Customer 
称呼 CDATA #IMPLIED 
姓名 CDATA #REQUIRED 
职位 CDATA #REQUIRED>
关于上述DTD 定义的描述正确的是（ ）","[{'optionContent': 'A.Customer 元素能包含子元素，并且能为空', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Customer 元素能包含子元素，并且能为空'}, {'optionContent': 'B.Customer 元素能包含文本，并且能为空', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Customer 元素能包含文本，并且能为空'}, {'optionContent': 'C.Customer 元素不能包含文本，也不能包含子元素', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Customer 元素不能包含文本，也不能包含子元素'}, {'optionContent': 'D.Customer 元素的所有实例的“称呼”属性必须有值，不能为空', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Customer 元素的所有实例的“称呼”属性必须有值，不能为空'}]",EMPTY 表示元素不能包含文本，也不能包含子元素； #IMPLIED 属性可以没有值； #REQUIRED 属性必须有值。,C
(单选题)实体引用是一种合法的XML名字，前面带有一个符号（   ）,"[{'optionContent': 'A.&', 'isCorrect': '-1', 'option': 'A', 'optionValue': '&'}, {'optionContent': 'B.;', 'isCorrect': '-1', 'option': 'B', 'optionValue': ';'}, {'optionContent': 'C.+', 'isCorrect': '-1', 'option': 'C', 'optionValue': '+'}, {'optionContent': 'D.?', 'isCorrect': '-1', 'option': 'D', 'optionValue': '?'}]",xml文档中实体符号是用&作为开头的,A
(单选题)Schema与DTD的相同之处有（ ）,"[{'optionContent': 'A.基于XML语法', 'isCorrect': '-1', 'option': 'A', 'optionValue': '基于XML语法'}, {'optionContent': 'B.支持命名空间', 'isCorrect': '-1', 'option': 'B', 'optionValue': '支持命名空间'}, {'optionContent': 'C.可扩展', 'isCorrect': '-1', 'option': 'C', 'optionValue': '可扩展'}, {'optionContent': 'D.对XML文档结构进行验证', 'isCorrect': '-1', 'option': 'D', 'optionValue': '对XML文档结构进行验证'}]",DTD不遵循XML语法 DTD不支持命名空间 DTD不可扩展,D
(单选题)XML的命名规则中说法正确的是（ ）,"[{'optionContent': 'A.可以包含字母、数字、以及其他字符', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以包含字母、数字、以及其他字符'}, {'optionContent': 'B.名字可以任何字母、数字或符号开始', 'isCorrect': '-1', 'option': 'B', 'optionValue': '名字可以任何字母、数字或符号开始'}, {'optionContent': 'C.名字没有任何限制', 'isCorrect': '-1', 'option': 'C', 'optionValue': '名字没有任何限制'}, {'optionContent': 'D.以上均不正确', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上均不正确'}]","XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符; 名称不能以数字或者标点符号开始; 名称不能以字符 ""xml""（或者 XML、Xml）开始; 名称不能包含空格; 可使用任何名称，没有保留的字词。",A
(单选题)XML( )提供了一种避免元素命名冲突的方法。,"[{'optionContent': 'A.命名空间', 'isCorrect': '-1', 'option': 'A', 'optionValue': '命名空间'}, {'optionContent': 'B.DTD', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DTD'}, {'optionContent': 'C.XSD', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'XSD'}, {'optionContent': 'D.XSL', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'XSL'}]",定义xml文档时通过命名空间来避免重复的命名。,A
(多选题)在XML中，下列关于DOM的叙述是正确的（ ）,"[{'optionContent': 'A.DOM是独立于开发语言和平台的，因此使用Visnal Basic、Java、Visual C++等开发工具使用的DOM编程API是一致的', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DOM是独立于开发语言和平台的，因此使用Visnal Basic、Java、Visual C++等开发工具使用的DOM编程API是一致的'}, {'optionContent': 'B.XML文档通过load方法被装载进内存后，在内存中形成一个DOM文档对象模型树', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'XML文档通过load方法被装载进内存后，在内存中形成一个DOM文档对象模型树'}, {'optionContent': 'C.通过DOM  API，软件开发人员可以控制XML文档的结构和内容', 'isCorrect': '-1', 'option': 'C', 'optionValue': '通过DOM  API，软件开发人员可以控制XML文档的结构和内容'}, {'optionContent': 'D.通过DOM在XML文档中只能按照顺序方式导航', 'isCorrect': '-1', 'option': 'D', 'optionValue': '通过DOM在XML文档中只能按照顺序方式导航'}]",选项D错误 SAX解析文档需要按照顺序 DOM可以随意,"A,B,C"
(多选题)下列选项中，哪一个是预定义实体？（ ）,"[{'optionContent': 'A.<', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<'}, {'optionContent': 'B.&left;', 'isCorrect': '-1', 'option': 'B', 'optionValue': '&left;'}, {'optionContent': 'C.>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '>'}, {'optionContent': 'D.&right;', 'isCorrect': '-1', 'option': 'D', 'optionValue': '&right;'}]",表示>号,"A,C"
(多选题)以下声明正确的是（ ）,"[{'optionContent': 'A.<xml-stylesheet type=""txt/css"" href=""abc.css"">', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<xml-stylesheet type=""txt/css"" href=""abc.css"">'}, {'optionContent': ""B.<?xml-stylesheet type='txt/css' href='abc.css'?>"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""<?xml-stylesheet type='txt/css' href='abc.css'?>""}, {'optionContent': 'C.<?xml-stylesheet type=""txt/css"" href=""abc.css""?>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<?xml-stylesheet type=""txt/css"" href=""abc.css""?>'}, {'optionContent': 'D.<%xml-stylesheet type=""txt/css"" href=""abc.css""%>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<%xml-stylesheet type=""txt/css"" href=""abc.css""%>'}]",单引号，双引号都可以使用在属性上。,"B,C"
(多选题)以下说法符合xml语法规则的是（ ）,"[{'optionContent': 'A.标记头和标记末的大小写一致', 'isCorrect': '-1', 'option': 'A', 'optionValue': '标记头和标记末的大小写一致'}, {'optionContent': 'B.元素之间要正确的嵌套', 'isCorrect': '-1', 'option': 'B', 'optionValue': '元素之间要正确的嵌套'}, {'optionContent': 'C.结束标记可有可无', 'isCorrect': '-1', 'option': 'C', 'optionValue': '结束标记可有可无'}, {'optionContent': 'D.每个XML文档只能有一个根元素', 'isCorrect': '-1', 'option': 'D', 'optionValue': '每个XML文档只能有一个根元素'}]",XML语法规则： 必须有XML声明语句; 是否有DTD文件; 注意大小写; 给属性值加引号; 所有的标识必须有相应的结束标识; 所有的空标识也必须被关闭。,"A,B,D"
(单选题)－80转换成二进制的结果是：（）,"[{'optionContent': 'A.1011 0000', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1011 0000'}, {'optionContent': 'B.0101 0000', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0101 0000'}, {'optionContent': 'C.1101 0001', 'isCorrect': '-1', 'option': 'C', 'optionValue': '1101 0001'}, {'optionContent': 'D.1010 1111', 'isCorrect': '-1', 'option': 'D', 'optionValue': '1010 1111'}]",负数的二进制转换的时候先认定是负数，因此转换为的二进制数的最高位是1。然后按正数的大小转换为二进制，再然后按位取反，接着二进制末位加1，最后因为是负数，因此最高位应该是1，检查是否正确。所得的结果即为负数的二进制结果。按这个规则计算，则选项A正确。,A
(单选题)二进制数（0011 1101）转换成十六进制数是（）,"[{'optionContent': 'A.3C', 'isCorrect': '-1', 'option': 'A', 'optionValue': '3C'}, {'optionContent': 'B.3D', 'isCorrect': '-1', 'option': 'B', 'optionValue': '3D'}, {'optionContent': 'C.E1', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'E1'}, {'optionContent': 'D.F1', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'F1'}]",十六进制是由4位二进制组成的，进制的转换是不影响数制的，因此转换的时候应该是把二进制数从右往左来计算，每4位来组合成一个十六进制数，每4位数字都按照8421的格式编码，然后累加求和就是对应的十六进制数，因此，二进制数划分为：11   1101，前两位按照8421排码加和为2+1=3，后四位按照8421排码加和为8+4+1=13=D，组合在一起就是3D，因此B正确。,B
(单选题)十进制数23转换成二进制数是（）,"[{'optionContent': 'A.0001 0011', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0001 0011'}, {'optionContent': 'B.0001 0101', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0001 0101'}, {'optionContent': 'C.0001 0111', 'isCorrect': '-1', 'option': 'C', 'optionValue': '0001 0111'}, {'optionContent': 'D.0001 1011', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0001 1011'}]","十进制整数转换为二进制整数采用""除2取余，逆序排列""法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为0时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。按此方式所得结果为C正确。",C
(单选题)每四位二进制数可用（）位十六进制数表示,"[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '4'}]",每位十六进制数是需要四位二进制数来表示，因此四位二进制则是对应一位十六进制数，因此A正确。,A
(单选题)十六进制数4F转换成二进制数是（）,"[{'optionContent': 'A.0100 1111', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0100 1111'}, {'optionContent': 'B.0101 1011', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0101 1011'}, {'optionContent': 'C.0101 0111', 'isCorrect': '-1', 'option': 'C', 'optionValue': '0101 0111'}, {'optionContent': 'D.0101 1110', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0101 1110'}]",每位十六进制数是需要四位二进制数来表示，因此四位二进制则是对应一位十六进制数，因此A正确。,A
(单选题)八进制数0176对应的十进制数是（）,"[{'optionContent': 'A.176', 'isCorrect': '-1', 'option': 'A', 'optionValue': '176'}, {'optionContent': 'B.78', 'isCorrect': '-1', 'option': 'B', 'optionValue': '78'}, {'optionContent': 'C.112', 'isCorrect': '-1', 'option': 'C', 'optionValue': '112'}, {'optionContent': 'D.126', 'isCorrect': '-1', 'option': 'D', 'optionValue': '126'}]","本题中给出的是八进制数
由高到低各位对应的权值为8的i次幂  i值由高到低各位的值为3 2 1 0
所以八进制权值由高到低各位为512 64 8 1
所以0176(八)转为十进制数计算为
0*512+1*64+7*8+6*1=126
故答案为D",D
(单选题)二进制数1001 0010对应的八进制数是（）,"[{'optionContent': 'A.146', 'isCorrect': '-1', 'option': 'A', 'optionValue': '146'}, {'optionContent': 'B.222', 'isCorrect': '-1', 'option': 'B', 'optionValue': '222'}, {'optionContent': 'C.116', 'isCorrect': '-1', 'option': 'C', 'optionValue': '116'}, {'optionContent': 'D.以上都不对', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上都不对'}]","八进制转二进制只需要从低位到高位顺序每3位分为一组 然后将每组的十进制数算出
再将所有十进制数按顺序拼接起来即可
因为八进制数每一位的最大值为7 永远不会出现大于7的数字
而4位二进制数的最大值也为7 最高位是0 所以可以使用3位二进制数算出1位八进制数
所以本题中二进制数1001 0010被分为3位一组的话结果是 010 010 010 最高位的0是为了达到3位一组的效果而加上去的 也可以不加
这样分组后每组对应的十进制数分别为2 2 2 所以八进制数就是222
故答案B正确",B
(单选题)三位二进制数能表示的最大十进制数是（）,"[{'optionContent': 'A.1', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1'}, {'optionContent': 'B.7', 'isCorrect': '-1', 'option': 'B', 'optionValue': '7'}, {'optionContent': 'C.8', 'isCorrect': '-1', 'option': 'C', 'optionValue': '8'}, {'optionContent': 'D.9', 'isCorrect': '-1', 'option': 'D', 'optionValue': '9'}]",三位二进制最高位就只能表示到4，排码格式就变成了421，然后把各位所能表示的最大的二进制数累加就是表示的最大的十进制数。4+2+1=7，因此B正确。,B
(单选题)十六进制数7F对应的十进制数是多少（）,"[{'optionContent': 'A.128', 'isCorrect': '-1', 'option': 'A', 'optionValue': '128'}, {'optionContent': 'B.-128', 'isCorrect': '-1', 'option': 'B', 'optionValue': '-128'}, {'optionContent': 'C.127', 'isCorrect': '-1', 'option': 'C', 'optionValue': '127'}, {'optionContent': 'D.-127', 'isCorrect': '-1', 'option': 'D', 'optionValue': '-127'}]","十六进制数7F可以先转为对应的二进制数
即7(十六)对应0111(二)  F(十六)对应1111(二)  所以4F(十六)对应0111 1111（二）
再转为十进制计算为
0*128+1*64+1*32+1*16+1*8+1*4+1*2+1*1=127
所以答案选C",C
"(多选题)已知如下代码片段：
1. public class test {
2.  public static void main (String args[]) {
3.    int i = 0xFFFFFFF1;
4.    int j = ~i;
5.
6.  }
7.}
当程序运行到第5行时, i 和 j 的值分别为多少（ ）","[{'optionContent': 'A.–15', 'isCorrect': '-1', 'option': 'A', 'optionValue': '–15'}, {'optionContent': 'B.0', 'isCorrect': '-1', 'option': 'B', 'optionValue': '0'}, {'optionContent': 'C.1', 'isCorrect': '-1', 'option': 'C', 'optionValue': '1'}, {'optionContent': 'D.14', 'isCorrect': '-1', 'option': 'D', 'optionValue': '14'}]","0xFFFFFFF1为十六进制数，其转为二进制数为
11111111 11111111 11111111 11110001 ，
所对应的十进制数为-15 ，
""~""符号为取反操作，即将0、1对换，结果为
00000000 00000000 00000000 00001110 ，
该二进制数转为十进制数结果为14 。","A,D"
(单选题)计算二进制1100^1010的结果是（）,"[{'optionContent': 'A.1000', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1000'}, {'optionContent': 'B.1110', 'isCorrect': '-1', 'option': 'B', 'optionValue': '1110'}, {'optionContent': 'C.0110', 'isCorrect': '-1', 'option': 'C', 'optionValue': '0110'}, {'optionContent': 'D.0000', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0000'}]","^属于二进制位运算符 代表异或的意思
运算时两个二进制数对应位的数不同时结果为1  否则为0
所以1100^1010的结果应该是0110
所以答案C正确",C
(单选题)计算~36的十进制结果是（）,"[{'optionContent': 'A.36', 'isCorrect': '-1', 'option': 'A', 'optionValue': '36'}, {'optionContent': 'B.-36', 'isCorrect': '-1', 'option': 'B', 'optionValue': '-36'}, {'optionContent': 'C.37', 'isCorrect': '-1', 'option': 'C', 'optionValue': '37'}, {'optionContent': 'D.-37', 'isCorrect': '-1', 'option': 'D', 'optionValue': '-37'}]","~属于二进制位运算符 代表非的意思
计算方法为将每一位上0变为1  1变为0
本题中要计算的是十进制数36的非运算值
首先先将36(十)转为0010 0100(二) 然后进行运算得到结果1101 1011(二)
然后再将此二进制数转为十进制
由于我们这里计算的是8位二进制数 最高位为第8位
此时最高位数字为1 是一个负数
要想算出十进制负数的值可以进行取反+1运算先算出对应的十进制正数的值
即1101 1011取反+1后变为 0010 0101 则对应的十进制数为37
所以最终~36的结果应该是-37
答案为D",D
"(单选题)若x=2,y=3则x&y的结果是（）","[{'optionContent': 'A.0', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0'}, {'optionContent': 'B.2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2'}, {'optionContent': 'C.3', 'isCorrect': '-1', 'option': 'C', 'optionValue': '3'}, {'optionContent': 'D.5', 'isCorrect': '-1', 'option': 'D', 'optionValue': '5'}]",2对应的二进制为10，3对应的二进制为11，&运算的规则是数位都为1则是1，只要有一个数的当前数位是0则结果为0，所以 2&3 == 10 & 11 ，则对应的结果为10，转换成十进制就是数字2，因此B正确。,B
(单选题)关于运算符>>和>>>描述正确的是（ ）,"[{'optionContent': 'A.>>执行移动', 'isCorrect': '-1', 'option': 'A', 'optionValue': '>>执行移动'}, {'optionContent': 'B.>>执行翻转', 'isCorrect': '-1', 'option': 'B', 'optionValue': '>>执行翻转'}, {'optionContent': 'C.>>执行有符号右移，>>>执行无符号右移', 'isCorrect': '-1', 'option': 'C', 'optionValue': '>>执行有符号右移，>>>执行无符号右移'}, {'optionContent': 'D.>>执行无符号右移，>>>执行有符号右移', 'isCorrect': '-1', 'option': 'D', 'optionValue': '>>执行无符号右移，>>>执行有符号右移'}]",java中，>>为有符号右移，>>>为无符号右移，<<为有符号左移，不存在无符号左移运算符。,C
"(单选题)阅读下列代码 :
public class Test{  
public static void main(String args[]){  
System.out.println(89 >>1)； 
} 
}   
其运行结果是 ()","[{'optionContent': 'A.44', 'isCorrect': '-1', 'option': 'A', 'optionValue': '44'}, {'optionContent': 'B.45', 'isCorrect': '-1', 'option': 'B', 'optionValue': '45'}, {'optionContent': 'C.88', 'isCorrect': '-1', 'option': 'C', 'optionValue': '88'}, {'optionContent': 'D.90', 'isCorrect': '-1', 'option': 'D', 'optionValue': '90'}]",89>>1相当于89X（1/2）取整。,A
(单选题)在位运算中，操作数每左移一位，其结果相当于（）,"[{'optionContent': 'A.操作数乘以2', 'isCorrect': '-1', 'option': 'A', 'optionValue': '操作数乘以2'}, {'optionContent': 'B.操作数除以2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '操作数除以2'}, {'optionContent': 'C.操作数除以4', 'isCorrect': '-1', 'option': 'C', 'optionValue': '操作数除以4'}, {'optionContent': 'D.操作数乘以4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '操作数乘以4'}]",二进制数左移一位相当于数位上的数值乘以2，右移一位相当于数位上的数值除以2，因此A正确。,A
(单选题)在位运算中，操作数每右移一位，其结果相当于（）,"[{'optionContent': 'A.操作数乘以2', 'isCorrect': '-1', 'option': 'A', 'optionValue': '操作数乘以2'}, {'optionContent': 'B.操作数除以2', 'isCorrect': '-1', 'option': 'B', 'optionValue': '操作数除以2'}, {'optionContent': 'C.操作数除以4', 'isCorrect': '-1', 'option': 'C', 'optionValue': '操作数除以4'}, {'optionContent': 'D.操作数乘以4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '操作数乘以4'}]",二进制数左移一位相当于数位上的数值乘以2，右移一位相当于数位上的数值除以2，因此B正确。,B
(多选题)下列代码中，哪一项可以编译通过且正常运行出结果（ ）,"[{'optionContent': 'A.int foo = (int) Math.max(bar);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'int foo = (int) Math.max(bar);'}, {'optionContent': 'B.int foo = (int) Math.min(bar);', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int foo = (int) Math.min(bar);'}, {'optionContent': 'C.int foo = (int) Math.abs(bar);', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'int foo = (int) Math.abs(bar);'}, {'optionContent': 'D.int foo = (int) Math.ceil(bar);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'int foo = (int) Math.ceil(bar);'}]","A B 两个选项方法使用错误，都是两个参数。
abs 方法是取 bar 的绝对值，
ceil 方法返回大于或者等于指定表达式的最小整数，即向上取整，本题中该值大于等于参数 bar。
例如：
Math.ceil(5.6) //6
Math.ceil(-5.6) //-5","C,D"
(单选题)SQL语言又称为(),"[{'optionContent': 'A.结构化定义语言', 'isCorrect': '-1', 'option': 'A', 'optionValue': '结构化定义语言'}, {'optionContent': 'B.结构化控制语言 ', 'isCorrect': '-1', 'option': 'B', 'optionValue': '结构化控制语言 '}, {'optionContent': 'C.结构化查询语言', 'isCorrect': '-1', 'option': 'C', 'optionValue': '结构化查询语言'}, {'optionContent': 'D.结构化操纵语言', 'isCorrect': '-1', 'option': 'D', 'optionValue': '结构化操纵语言'}]",SQL语言又称为结构化查询语言,C
(单选题)SQL 语言中修改表结构的命令是（ ）,"[{'optionContent': 'A.MODIFY TABLE', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'MODIFY TABLE'}, {'optionContent': 'B.MODIFY STRUCTURE', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'MODIFY STRUCTURE'}, {'optionContent': 'C.ALTER TABLE', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ALTER TABLE'}, {'optionContent': 'D.ALTER STRUCTURE', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ALTER STRUCTURE'}]",修改表结构使用alter命令,C
(单选题)在Oracle中，删除表Student中的所有数据，可以使用的Sql是（）。,"[{'optionContent': 'A.DROP TABLE Student', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DROP TABLE Student'}, {'optionContent': 'B.DELETE FROM Student', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DELETE FROM Student'}, {'optionContent': 'C.DELETE * FROM Student', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'DELETE * FROM Student'}, {'optionContent': 'D.DROP * FROM Student', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'DROP * FROM Student'}]",drop会将表结构一并删除，且删除表数据不可以使用*号,B
(多选题)以下哪种操作属于DML操作（ ）,"[{'optionContent': 'A.truncate', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'truncate'}, {'optionContent': 'B.insert', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'insert'}, {'optionContent': 'C.update', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'update'}, {'optionContent': 'D.delete', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'delete'}]","DML：data manipulation language 数据操作语言：
      insert、delete、update、merge
DDL：data definition language 数据定义语言：
      create、alter、drop
DCL：data control	language	数据控制语言：
      grant、revoke
truncate属于DDL语句","B,C,D"
(多选题)delete 和 truncate 都可以用来删除表内容，以下描述正确的是（ ）,"[{'optionContent': 'A.truncate 不需要 rollback segment', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'truncate 不需要 rollback segment'}, {'optionContent': 'B.delete 需要 rollback segment', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'delete 需要 rollback segment'}, {'optionContent': 'C.truncate 在提交 commit 之前仍可回滚', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'truncate 在提交 commit 之前仍可回滚'}, {'optionContent': 'D.truncate 还可以删除表结构', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'truncate 还可以删除表结构'}]","TRUNCATE TABLE 语句:删除表中所有的数据并且释放表的存储空间，可以使用 DELETE 语句删除数据， DELETE 产生 rollback segment，
如果删除大数据量的表速度会很慢，同时会占用很多的 rollback segment 。
TRUNCATE 是 DDL 操作，不产生 rollback segment，速度快一些。","A,B"
"(单选题)有如下 SQL 片段：
delete from asdfh a where a.kaihrq > '20091214' and a.jiluzt <> '1';
其含义为（ ）","[{'optionContent': 'A.从表 asdfh 中删除 kaihrq 大于 2009 年 12 月 14 日，且 jiluzt 不为 1 的记录', 'isCorrect': '-1', 'option': 'A', 'optionValue': '从表 asdfh 中删除 kaihrq 大于 2009 年 12 月 14 日，且 jiluzt 不为 1 的记录'}, {'optionContent': 'B.从表 asdfh 中删除 kaihrq 和 jiluzt 列', 'isCorrect': '-1', 'option': 'B', 'optionValue': '从表 asdfh 中删除 kaihrq 和 jiluzt 列'}, {'optionContent': 'C.对表 asdfh 中删除 kaihrq 大于 2009 年 12 月 14 日，且 jiluzt 不为 1 的记录做一个删除标记', 'isCorrect': '-1', 'option': 'C', 'optionValue': '对表 asdfh 中删除 kaihrq 大于 2009 年 12 月 14 日，且 jiluzt 不为 1 的记录做一个删除标记'}, {'optionContent': 'D.以上都不正确', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上都不正确'}]","提交或回滚前的数据状态改变前的数据状态是可以恢复的
执行 DML 操作的用户可以通过 SELECT 语句查询之前的修正 其他会话不能看到当前用户所做的改变，直到当前会话结束事务。 DML 语句所涉及到的行被锁定， 其他会话不能操作。",C
"(单选题)表 TEACHER 包含如下字段：
列名                   可为空否？ 数据类型
TEACHER_ID        NOT NULL NUMBER(9)
NAME                               VARCHAR2(25)
SALARY                            NUMBER(7,2)
SUBJECT_ID        NOT NULL NUMBER(4)
SUBJECT_DESCRIPTION       VARCHAR2(20)
你需要将SUBJECT_ID是11的理科(SCIENCE)教师的工资上浮8%，
需用哪一句实现（ ）","[{'optionContent': ""A.UPDATE teacher SET salary = salary * 1.08 WHERE subject_description LIKE 'SCIENCE';"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""UPDATE teacher SET salary = salary * 1.08 WHERE subject_description LIKE 'SCIENCE';""}, {'optionContent': ""B.UPDATE teacher SET salary = salary * 0.8 WHERE subject_description LIKE 'SCIENCE' AND subject_id = 11;"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""UPDATE teacher SET salary = salary * 0.8 WHERE subject_description LIKE 'SCIENCE' AND subject_id = 11;""}, {'optionContent': ""C.UPDATE teacher SET salary = salary * 1.08 WHERE \nsubject_description LIKE 'SCIENCE' AND subject_id = 11;"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""UPDATE teacher SET salary = salary * 1.08 WHERE \nsubject_description LIKE 'SCIENCE' AND subject_id = 11;""}, {'optionContent': ""D.UPDATE teacher SET salary = salary + (salary * 0.08) \nWHERE subject_description LIKE 'SCIENCE' OR subject_id = 11;"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""UPDATE teacher SET salary = salary + (salary * 0.08) \nWHERE subject_description LIKE 'SCIENCE' OR subject_id = 11;""}]","A. 是将所有理科教师的工资都上浮8%
B. 是将SUBJECT_ID是11的理科(SCIENCE)教师的原有工资改成了
   原来的0.8倍
D. 与A的效果相同",C
(单选题)Oracle数据库中，在SQL语句中连接字符串的方法是：（）。,"[{'optionContent': 'A.CAT', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'CAT'}, {'optionContent': 'B.CONCAT', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'CONCAT'}, {'optionContent': 'C.JOIN', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'JOIN'}, {'optionContent': 'D.UNION', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'UNION'}]","Oracle可以使用CONCAT关键字或""||""符号连接字符串",B
(单选题)select 语句中用来连接字符串的符号是（ ）,"[{'optionContent': 'A.""+""', 'isCorrect': '-1', 'option': 'A', 'optionValue': '""+""'}, {'optionContent': 'B.""&""', 'isCorrect': '-1', 'option': 'B', 'optionValue': '""&""'}, {'optionContent': 'C.""||""', 'isCorrect': '-1', 'option': 'C', 'optionValue': '""||""'}, {'optionContent': 'D.""|""', 'isCorrect': '-1', 'option': 'D', 'optionValue': '""|""'}]","Oracle中连接字符串使用""||""符号",C
(单选题)Oracle 数据库中，在 SQL 语句中连接字符串的方法是哪个（ ）,"[{'optionContent': 'A.cat', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'cat'}, {'optionContent': 'B.concat', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'concat'}, {'optionContent': 'C.join', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'join'}, {'optionContent': 'D.+', 'isCorrect': '-1', 'option': 'D', 'optionValue': '+'}]",Oracle中使用concat连接字符串,B
"(单选题)试图用下面句子查询数据：SELECT 100/NVL(quantity, 0) FROM inventory; 为何 QUANTITY 为 null 空值时，将导致出错（ ）","[{'optionContent': 'A.表达式企图被空值除', 'isCorrect': '-1', 'option': 'A', 'optionValue': '表达式企图被空值除'}, {'optionContent': 'B.换函数参数数据类型不一致', 'isCorrect': '-1', 'option': 'B', 'optionValue': '换函数参数数据类型不一致'}, {'optionContent': 'C.空值不能被转成实际值', 'isCorrect': '-1', 'option': 'C', 'optionValue': '空值不能被转成实际值'}, {'optionContent': 'D.表达式企图被零除', 'isCorrect': '-1', 'option': 'D', 'optionValue': '表达式企图被零除'}]",nvl(表达式1，表达式2)这个函数的作用是如果表达式1的值为null，那么取表达式2的值。,D
(单选题)在oracle中，判断一条记录的某个列是否为NULL，应该使用( )。,"[{'optionContent': 'A.!=', 'isCorrect': '-1', 'option': 'A', 'optionValue': '!='}, {'optionContent': 'B.<>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<>'}, {'optionContent': 'C.IS', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'IS'}, {'optionContent': 'D.=', 'isCorrect': '-1', 'option': 'D', 'optionValue': '='}]",Oracle中通过is关键字判断字段值是否为NULL,C
"(单选题)inventory中，哪句可以实现显示id和description ，条件满足订单时间在
January 1, 1997 以前的，且单价小于 1.00 或者大于 5.00 的， 
结果用订单时间降序排列（ ）","[{'optionContent': ""A.SELECT id_number, description FROM inventory \nWHERE price IN (1.00, 5.00) OR order_date < '01-JAN-97' \nORDER BY order_date DESC;"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""SELECT id_number, description FROM inventory \nWHERE price IN (1.00, 5.00) OR order_date < '01-JAN-97' \nORDER BY order_date DESC;""}, {'optionContent': ""B.SELECT id_number, description FROM inventory \nWHERE price BETWEEN 1.00 AND 5.00 OR order_date < '01-JAN-1997'  ORDER BY order_date;"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""SELECT id_number, description FROM inventory \nWHERE price BETWEEN 1.00 AND 5.00 OR order_date < '01-JAN-1997'  ORDER BY order_date;""}, {'optionContent': ""C.SELECT id_number, description FROM inventory \nWHERE price < 1.00 OR price > 5.00 AND order_date < '01 -Jan-97' \nORDER BY order_date ASC;"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""SELECT id_number, description FROM inventory \nWHERE price < 1.00 OR price > 5.00 AND order_date < '01 -Jan-97' \nORDER BY order_date ASC;""}, {'optionContent': ""D.SELECT id_number, description FROM inventory \nWHERE (price <1.00 OR price > 5.00) AND order_date < '01-JAN-1997' ORDER BY order_date DESC;"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""SELECT id_number, description FROM inventory \nWHERE (price <1.00 OR price > 5.00) AND order_date < '01-JAN-1997' ORDER BY order_date DESC;""}]","A选项的意思是只要price是1.00或5.00两个其中任意一个，或者order_date在January 1, 1997以前，都属于符合条件的结果。
B选项的意思是price在1.00和5.00之间，或者order_date在January 1, 1997以前，都属于符合条件的结果，最后结果集升序排序。
C选项最后是对结果升序排序。",D
(单选题)查询cost表的所有行，所有列，下列sql语句正确的是：,"[{'optionContent': 'A.select * from cost; ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select * from cost; '}, {'optionContent': 'B.select  all.*  from cost; ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select  all.*  from cost; '}, {'optionContent': 'C.select all from cost; ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select all from cost; '}, {'optionContent': 'D.select \\* from cost;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select \\* from cost;'}]",select * from 表名     是查询此表的所有行和所有列,A
(单选题)在Oracle中，控制年龄必须在18到50之间(包含18和50)，可使用的代码是（）。,"[{'optionContent': 'A.age>18 and age<50', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'age>18 and age<50'}, {'optionContent': 'B.age>=18 and age<=50', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'age>=18 and age<=50'}, {'optionContent': 'C.age>=18 && age<=50', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'age>=18 && age<=50'}, {'optionContent': 'D.age>18 && age<50', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'age>18 && age<50'}]",oracle中要求多条件必须同时满足时需要使用and关键字，题中要求包含18和50，需要>=和<=。,B
"(单选题)哪一子句可实现 SELECT 语句查询员工平均工资小于 5000 的部门
信息（ ）","[{'optionContent': 'A.GROUP BY dept_id WHERE AVG(sal) < 5000;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'GROUP BY dept_id WHERE AVG(sal) < 5000;'}, {'optionContent': 'B.GROUP BY AVG(sal) HAVING AVG(sal) < 5000', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'GROUP BY AVG(sal) HAVING AVG(sal) < 5000'}, {'optionContent': 'C.GROUP BY dept_id HAVING AVG(sal) < 5000', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'GROUP BY dept_id HAVING AVG(sal) < 5000'}, {'optionContent': 'D.GROUP BY AVG(sal) < 5000', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'GROUP BY AVG(sal) < 5000'}]",使用 HAVING 过滤分组。,C
"(单选题)判断下面句子，将返回什么值（ ）
SELECT id_number, description, price FROM inventory 
WHERE manufacturer_id IN (
  SELECT manufacturer_id FROM inventory 
  WHERE price > 8.00 OR quantity > 1000
);","[{'optionContent': 'A.返回单价大于 8.00 且数量大于1000的存货的货号、种类、单价信息', 'isCorrect': '-1', 'option': 'A', 'optionValue': '返回单价大于 8.00 且数量大于1000的存货的货号、种类、单价信息'}, {'optionContent': 'B.返回单价大于 8.00 或者数量大于1000的存货的货号、种类、单价信息', 'isCorrect': '-1', 'option': 'B', 'optionValue': '返回单价大于 8.00 或者数量大于1000的存货的货号、种类、单价信息'}, {'optionContent': 'C.返回单价大于8.00或者数量大于1000且有制造商号的存货的货号、种类、单价信息', 'isCorrect': '-1', 'option': 'C', 'optionValue': '返回单价大于8.00或者数量大于1000且有制造商号的存货的货号、种类、单价信息'}, {'optionContent': 'D.返回单价大于8.00或者数量大于1000的制造商的所有存货的货号、种类、单价信息', 'isCorrect': '-1', 'option': 'D', 'optionValue': '返回单价大于8.00或者数量大于1000的制造商的所有存货的货号、种类、单价信息'}]",该语句返回的是单价大于8.00或者数量大于1000，且制造商号在子查询结果集中的存货的货号、种类、单价的信息,C
"(单选题)表（TEACHER）包含以下列：
ID NUMBER(7) PK 
SALARY NUMBER(7,2) 
SUBJECT_ID NUMBER(7) 
判断以下两个 SQL 语句：
（1）SELECT ROUND(SUM(salary),-2) FROM teacher ;
（2）SELECT subject_id, ROUND(SUM(salary),-2) FROM teacher 
     GROUP BY subject_id ;
有什么不同结果（ ）","[{'optionContent': 'A.语句 1 将返回每个老师一个结果', 'isCorrect': '-1', 'option': 'A', 'optionValue': '语句 1 将返回每个老师一个结果'}, {'optionContent': 'B.语句 2 将返回多个结果', 'isCorrect': '-1', 'option': 'B', 'optionValue': '语句 2 将返回多个结果'}, {'optionContent': 'C.结果相同，显示不同', 'isCorrect': '-1', 'option': 'C', 'optionValue': '结果相同，显示不同'}, {'optionContent': 'D.将有一个句子产生错误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '将有一个句子产生错误'}]",语句 1 会返回一个结果，就是所有老师的工资和，使用了四舍五入函数，语句 2 是按照 subject_id 进行分组，那么分几组就会有几个结果,B
"(单选题)从""员工""表的""姓名""字段中找出名字包含""玛丽""的人，下面哪条 select 语句正确（ ）","[{'optionContent': ""A.select * from 员工 where 姓名='_玛丽_';"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""select * from 员工 where 姓名='_玛丽_';""}, {'optionContent': ""B.select * from 员工 where 姓名='%玛丽_';"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""select * from 员工 where 姓名='%玛丽_';""}, {'optionContent': ""C.select * from 员工 where 姓名 like '_玛丽%';"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""select * from 员工 where 姓名 like '_玛丽%';""}, {'optionContent': ""D.select * from 员工 where 姓名 like '%玛丽%';"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""select * from 员工 where 姓名 like '%玛丽%';""}]","LIKE 运算选择类似的值，选择条件可以包含字符或数字，""%""代表0个或多个字符，""_""代表一 个字符。",D
"(单选题)cost表中id,unit_cost列数据如下：
 ID   UNIT_COST
 1  
 2      0.40
 3      0.30
 4      0.20
 5      0.10
 6      0.50  
sql语句select count(unit_cost) from cost;查询的结果为：","[{'optionContent': 'A.2', 'isCorrect': '-1', 'option': 'A', 'optionValue': '2'}, {'optionContent': 'B.6', 'isCorrect': '-1', 'option': 'B', 'optionValue': '6'}, {'optionContent': 'C.5', 'isCorrect': '-1', 'option': 'C', 'optionValue': '5'}, {'optionContent': 'D.0', 'isCorrect': '-1', 'option': 'D', 'optionValue': '0'}]",以上查询将返回表cost中unit_cost列的记录个数，当某条记录为空时将不计入结果。,C
"(多选题)已知student表，结构如下：
sid_id      number						
start_date      date	
end_date      date
以下哪个函数可以用在start_date列上（ ）","[{'optionContent': 'A.sum(start_date)', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'sum(start_date)'}, {'optionContent': 'B.avg(start_date)', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'avg(start_date)'}, {'optionContent': 'C.count(start_date)', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'count(start_date)'}, {'optionContent': 'D.min(start_date)', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'min(start_date)'}]",sum 和 avg 要求数字数据类型。,"C,D"
(单选题)只有满足联接条件的记录才包含在查询结果中，这种联接为（ ）,"[{'optionContent': 'A.左联接', 'isCorrect': '-1', 'option': 'A', 'optionValue': '左联接'}, {'optionContent': 'B.右联接', 'isCorrect': '-1', 'option': 'B', 'optionValue': '右联接'}, {'optionContent': 'C.内部联接', 'isCorrect': '-1', 'option': 'C', 'optionValue': '内部联接'}, {'optionContent': 'D.完全联接', 'isCorrect': '-1', 'option': 'D', 'optionValue': '完全联接'}]",内连接 ：内连接查询操作列出与连接条件匹配的数据行 外连接：返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左连接)、右表(右 连接)或两个边接表(全外连接)中的所有数据行。,C
(单选题)下列哪个集合操作符返回两个查询所选择的所有的行（ ）,"[{'optionContent': 'A.union', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'union'}, {'optionContent': 'B.unionall', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'unionall'}, {'optionContent': 'C.union only', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'union only'}, {'optionContent': 'D.connect by', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'connect by'}]",union集合操作符返回两个查询所选择的去除重复行。,B
"(单选题)表 CLASSES 和 表 SCHEDULE 结构如下: 
CLASSES：
ID NUMBER(9)
CLASS_NAME VARCHAR2(20) 
TEACHER_ID NUMBER(9) 

SCHEDULE：
CLASS_TIME DATE 
CLASS_ID NUMBER(9)
建一个视图显示每一门课程的课名、课时，并按教师 ID 排序，判断下面语句将返回何种结果（ ）
CREATE VIEW class_schedule AS
SELECT c.class_name, s.class_time FROM classes c, schedule s 
WHERE c.id = s.class_id;","[{'optionContent': 'A.语句创建视图 CLASS_SCHEDULE 且可产生预期结果', 'isCorrect': '-1', 'option': 'A', 'optionValue': '语句创建视图 CLASS_SCHEDULE 且可产生预期结果'}, {'optionContent': 'B.语句创建视图 CLASS_SCHEDULE 但不能产生预期结果', 'isCorrect': '-1', 'option': 'B', 'optionValue': '语句创建视图 CLASS_SCHEDULE 但不能产生预期结果'}, {'optionContent': 'C.语法错误，因为视图不可基于连接查询', 'isCorrect': '-1', 'option': 'C', 'optionValue': '语法错误，因为视图不可基于连接查询'}, {'optionContent': 'D.语法错，因为语句未包含 ORDER BY 子句', 'isCorrect': '-1', 'option': 'D', 'optionValue': '语法错，因为语句未包含 ORDER BY 子句'}]",上述视图显示每一课的课名、课时，但是没有按教师 ID 排序,B
(单选题)在数据库中，有一个名为seq的序列对象，以下语句能返回下一个序列值的是：,"[{'optionContent': 'A.select seq.ROWNUM from dual;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select seq.ROWNUM from dual;'}, {'optionContent': 'B.select seq.ROWID from dual; ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select seq.ROWID from dual; '}, {'optionContent': 'C.select seq.CURRVAL from dual;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select seq.CURRVAL from dual;'}, {'optionContent': 'D.select seq.NEXTVAL from dual;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select seq.NEXTVAL from dual;'}]",.NEXTVAL是获取下一个序列值,D
(单选题)Oracle 数据库表空间与数据文件的关系描述正确的是（ ）,"[{'optionContent': 'A.一个表空间只能对应一个数据文件', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一个表空间只能对应一个数据文件'}, {'optionContent': 'B.一个表空间可以对应多个数据文件', 'isCorrect': '-1', 'option': 'B', 'optionValue': '一个表空间可以对应多个数据文件'}, {'optionContent': 'C.一个数据文件可以对应多个表空间', 'isCorrect': '-1', 'option': 'C', 'optionValue': '一个数据文件可以对应多个表空间'}, {'optionContent': 'D.表空间与数据文件没任何对应关系', 'isCorrect': '-1', 'option': 'D', 'optionValue': '表空间与数据文件没任何对应关系'}]",表空间和数据文件发生关系，数据文件是物理的，一个表空间可以包含多个数据文件， 而一个数据文件只能隶属一个表空间,B
(单选题)Oracle 数据库表空间与用户的关系是（ ）,"[{'optionContent': 'A.一对一', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一对一'}, {'optionContent': 'B.一对多', 'isCorrect': '-1', 'option': 'B', 'optionValue': '一对多'}, {'optionContent': 'C.多对一', 'isCorrect': '-1', 'option': 'C', 'optionValue': '多对一'}, {'optionContent': 'D.多对多', 'isCorrect': '-1', 'option': 'D', 'optionValue': '多对多'}]",一个用户可以使用一个或多个表空间，一个表空间也可以供多个用户使用。,D
"(单选题)典型的JDBC程序按哪个顺序编写（ ）
1. 释放资源 
2. 获得与数据库的物理连接
3. 执行SQL命令
4. 注册JDBC Driver
5. 创建不同类型的Statement
6. 如果有结果集, 处理结果集","[{'optionContent': 'A.245316', 'isCorrect': '-1', 'option': 'A', 'optionValue': '245316'}, {'optionContent': 'B.243561', 'isCorrect': '-1', 'option': 'B', 'optionValue': '243561'}, {'optionContent': 'C.425361', 'isCorrect': '-1', 'option': 'C', 'optionValue': '425361'}, {'optionContent': 'D.423561', 'isCorrect': '-1', 'option': 'D', 'optionValue': '423561'}]",C选项为JDBC程序编写的正确顺序,C
(多选题)下列属于JAVA的接口的是:,"[{'optionContent': 'A.Statement', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Statement'}, {'optionContent': 'B.Collection ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Collection '}, {'optionContent': 'C.ResultSet ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ResultSet '}, {'optionContent': 'D.DriverManager', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'DriverManager'}]",DriverManager是一个关于JDBC的数据库驱动类,"A,B,C"
(多选题)下列关于JDBC说法正确的是（ ）,"[{'optionContent': 'A.JDBC提供了访问数据库的通用API，不同的数据库厂商根据各自数据库的特点提供了对JDBC的实现', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'JDBC提供了访问数据库的通用API，不同的数据库厂商根据各自数据库的特点提供了对JDBC的实现'}, {'optionContent': 'B.JDBC只提供了访问Oracle数据库的API', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'JDBC只提供了访问Oracle数据库的API'}, {'optionContent': 'C.Oracle公司提供了对JDBC的API的实现', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Oracle公司提供了对JDBC的API的实现'}, {'optionContent': 'D.JDBC只提供了对Java程序员的API', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'JDBC只提供了对Java程序员的API'}]",JDBC提供了对不同数据库连接访问的实现，不只提供了访问Oracle数据库的API，还有很多其他数据库的实现。 AC选项正确。,"A,C"
(多选题)选择JDBC可以执行的语句（ ）,"[{'optionContent': 'A.DDL', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DDL'}, {'optionContent': 'B.DML', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DML'}, {'optionContent': 'C.DQL', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'DQL'}, {'optionContent': 'D.以上都不可以', 'isCorrect': '-1', 'option': 'D', 'optionValue': '以上都不可以'}]",ABC选项jdbc都可以执行,"A,B,C"
(单选题)下面关于Oracle数据库连接URI正确的拼写格式是（ ）,"[{'optionContent': 'A.jdbc:oracle:thin:@hostname:1521:orcl', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'jdbc:oracle:thin:@hostname:1521:orcl'}, {'optionContent': 'B.jdbc/oracle/thin/@hostname:1521/orcl', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'jdbc/oracle/thin/@hostname:1521/orcl'}, {'optionContent': 'C.jdbc:oracle/thin/@hostname:1521/orcl', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'jdbc:oracle/thin/@hostname:1521/orcl'}, {'optionContent': 'D.jdbc:oracle:thin/@hostname:1521/orcl', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'jdbc:oracle:thin/@hostname:1521/orcl'}]",A选项为oracle jdbc连接的uri正确写法,A
(单选题)在JDBC连接数据库编程应用开发中，可以实现数据库连接的是（）。,"[{'optionContent': 'A.Connection接口', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Connection接口'}, {'optionContent': 'B.PreparedStatement类', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'PreparedStatement类'}, {'optionContent': 'C.CallableStatement类', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'CallableStatement类'}, {'optionContent': 'D.Statement类', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Statement类'}]",Connection接口是用来获取数据库连接的。,A
(单选题)下面关于mysql数据库连接URI正确的拼写格式是（ ）,"[{'optionContent': 'A.jdbc:mysql://localhost:3306/test', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'jdbc:mysql://localhost:3306/test'}, {'optionContent': 'B.jdbc:mysql:/localhost:3306/test', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'jdbc:mysql:/localhost:3306/test'}, {'optionContent': 'C.jdbc:mysql://localhost/3306/test', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'jdbc:mysql://localhost/3306/test'}, {'optionContent': 'D.jdbc:mysql://localhost:3306?test', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'jdbc:mysql://localhost:3306?test'}]","正确格式是jdbc:mysql://localhost:3306/test
A正确",A
"(单选题)已知数据表emp的数据为：
EMPNO ENAME
----- ----------
7369  SMITH
7499  ALLEN
7521  WARD

下面代码的运行结果是（  ） 
int empno = 7521;
String ename = ""hello' or '1'='1"";
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery(""select count(*) from emp where empno=""+empno+"" and ename='""+ename+""'"");
rs.next();
System.out.println(rs.getInt(1));","[{'optionContent': 'A.0', 'isCorrect': '-1', 'option': 'A', 'optionValue': '0'}, {'optionContent': 'B.1', 'isCorrect': '-1', 'option': 'B', 'optionValue': '1'}, {'optionContent': 'C.2', 'isCorrect': '-1', 'option': 'C', 'optionValue': '2'}, {'optionContent': 'D.3', 'isCorrect': '-1', 'option': 'D', 'optionValue': '3'}]",本题考点是SQL注入 SQL语句编译后的结果是 select count(*) from emp where empno=7521 and ename='hello' or '1'='1' 由于最终的恒等式 '1'='1' 所以导致where子句的条件恒成立 所以最终结果返回所有记录,D
(单选题)接口Statement中定义的execute方法的返回类型是:,"[{'optionContent': 'A.ResultSet', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'ResultSet'}, {'optionContent': 'B.int ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int '}, {'optionContent': 'C.boolean', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'boolean'}, {'optionContent': 'D.double ', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'double '}]",execute方法的返回的是bollean类型,C
(单选题)下面描述不属于连接池的功能的是（ ）,"[{'optionContent': 'A.可以缓解连接频繁的关闭和创建会造成系统性能的下降', 'isCorrect': '-1', 'option': 'A', 'optionValue': '可以缓解连接频繁的关闭和创建会造成系统性能的下降'}, {'optionContent': 'B.可以大幅度提高查询语句的执行效率', 'isCorrect': '-1', 'option': 'B', 'optionValue': '可以大幅度提高查询语句的执行效率'}, {'optionContent': 'C.可以限制客户端的连接数量', 'isCorrect': '-1', 'option': 'C', 'optionValue': '可以限制客户端的连接数量'}, {'optionContent': 'D.可以提高系统的伸缩性', 'isCorrect': '-1', 'option': 'D', 'optionValue': '可以提高系统的伸缩性'}]",连接池可以提高系统性能，于查询语句没有关系。,B
"(单选题)下面的代码用于删除emp表中的id为100的记录：
Class.forName(""com.mysql.jdbc.Driver"");
Connection con = DriverManager.getConnection(
""jdbc:mysql://localhost:3306/test""
,""root"",""root"");
（空白处）
stmt.close();
con.close();
空白处应填入的代码是：（）。","[{'optionContent': 'A.Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.executeUpdate();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.executeUpdate();'}, {'optionContent': 'B.Statement stmt = con.createStatement();\nint updateRows = stmt.executeUpdate(""delete from emp where id=100"");', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Statement stmt = con.createStatement();\nint updateRows = stmt.executeUpdate(""delete from emp where id=100"");'}, {'optionContent': 'C.Statement stmt = con.createStatement();\nint updateRows = stmt.execute(""delete from emp where id=100"");', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Statement stmt = con.createStatement();\nint updateRows = stmt.execute(""delete from emp where id=100"");'}, {'optionContent': 'D.Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.execute();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.execute();'}]","应该将sql语句传入executeUpdate方法执行。
B正确",B
"(单选题)接口Statement中定义的execute方法的返回值类型是（ ），
它的含义是（ ）
1. ResultSet
2. int
3. boolean
4. 受影响的记录数
5. 有无ResultSet返回","[{'optionContent': 'A.2\n5', 'isCorrect': '-1', 'option': 'A', 'optionValue': '2\n5'}, {'optionContent': 'B.3\n5', 'isCorrect': '-1', 'option': 'B', 'optionValue': '3\n5'}, {'optionContent': 'C.2\n4', 'isCorrect': '-1', 'option': 'C', 'optionValue': '2\n4'}, {'optionContent': 'D.1\n4', 'isCorrect': '-1', 'option': 'D', 'optionValue': '1\n4'}]",execute方法返回值类型是boolean，其含义是判断有误ResultSet返回。,B
"(单选题)下面的代码用于删除emp表中的id为100的记录：
Class.forName(""orcale.jdbc.OracleDriver"");
Connection con = DriverManager.getConnection(
""jdbc:oracle:thin:@192.168.0.26:1521:tarena""
,""openlab"",""open123"");
（空白处）
stmt.close();
con.close();
空白处应填入的代码是：（）。","[{'optionContent': 'A.Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.executeUpdate();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.executeUpdate();'}, {'optionContent': 'B.Statement stmt = con.createStatement();\nint updateRows = stmt.executeUpdate(""delete from emp where id=100"");', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Statement stmt = con.createStatement();\nint updateRows = stmt.executeUpdate(""delete from emp where id=100"");'}, {'optionContent': 'C.Statement stmt = con.createStatement();\nint updateRows = stmt.execute(""delete from emp where id=100"");', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Statement stmt = con.createStatement();\nint updateRows = stmt.execute(""delete from emp where id=100"");'}, {'optionContent': 'D.Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.execute();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Statement stmt = con.createStatement(""delete from emp where id=100"");\nint updateRows = stmt.execute();'}]",应该将sql语句传入executeUpdate方法执行。,B
(单选题)下面关于PreparedStatement的说法错误的是（ ）,"[{'optionContent': 'A.PreparedStatement继承了Statement', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'PreparedStatement继承了Statement'}, {'optionContent': 'B.PreparedStatement可以有效的防止SQL注入', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'PreparedStatement可以有效的防止SQL注入'}, {'optionContent': 'C.PreparedStatement不能用于批量更新的操作', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'PreparedStatement不能用于批量更新的操作'}, {'optionContent': 'D.PreparedStatement可以存储预编译的Statement，从而提升执行效率', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'PreparedStatement可以存储预编译的Statement，从而提升执行效率'}]",PreparedStatement和Statement都可以进行批处理操作,C
(单选题)关于ResultSetMetaData API描述错误的是（ ）,"[{'optionContent': 'A.getColumnCount()\n返回所查询表中的列数', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'getColumnCount()\n返回所查询表中的列数'}, {'optionContent': 'B.getColumnTypeName(int index)\n获取指定列的数据库特定的类型名称', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'getColumnTypeName(int index)\n获取指定列的数据库特定的类型名称'}, {'optionContent': 'C.getColumnType(int index)\n获取指定列的SQL类型', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'getColumnType(int index)\n获取指定列的SQL类型'}, {'optionContent': 'D.isNullable(int column)\n指示指定列中的值是否可以为 null', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'isNullable(int column)\n指示指定列中的值是否可以为 null'}]",A选项 返回此 ResultSet 对象中的列数,A
(单选题)下面关于ResultSet说法错误的是（ ）,"[{'optionContent': 'A.查询结束后，所有的结果数据将一次被存储在ResultSet对象中', 'isCorrect': '-1', 'option': 'A', 'optionValue': '查询结束后，所有的结果数据将一次被存储在ResultSet对象中'}, {'optionContent': 'B.Statement对象close后，由其创建的ResultSet对象将自动的close', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Statement对象close后，由其创建的ResultSet对象将自动的close'}, {'optionContent': 'C.查询结束后，ResultSet中的游标指向第一条记录之上，因此要先调用一次next方法才有可能取得记录', 'isCorrect': '-1', 'option': 'C', 'optionValue': '查询结束后，ResultSet中的游标指向第一条记录之上，因此要先调用一次next方法才有可能取得记录'}, {'optionContent': 'D.ResultSet的的方法getString(...)意为取得该列的数据以字符串的形式返回', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ResultSet的的方法getString(...)意为取得该列的数据以字符串的形式返回'}]",JDBC的查询结果并不是一次性全拿到resultset中的，Oracle默认每次拿指定数量的结果，将指定数量的结果遍历完后，再拿下一个指定数量的结果。 否则，当查询海量数据的时候，内存会直接爆掉。,A
"(多选题)在JDBC编程中执行完下列SQL语句: SELECT name, job, sal FROM emp，能得到结果集中的第一列数据的代码是（ ）","[{'optionContent': 'A.rs.getString(0);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'rs.getString(0);'}, {'optionContent': 'B.rs.getString(""name"");', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'rs.getString(""name"");'}, {'optionContent': 'C.rs.getString(1);', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'rs.getString(1);'}, {'optionContent': 'D.rs.getString(""ename”);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'rs.getString(""ename”);'}]",获取结果集中的列值可以直接通过通过select子句中字段名获取， 也可以通过序号获取，序号从1开始。 答案BC正确。,"B,C"
(多选题)下列操作数据库时遇到的异常情况说法正确的是（ ）,"[{'optionContent': 'A.java.sql.SQLException:结果集已耗尽（结果集用尽或未调用next）', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'java.sql.SQLException:结果集已耗尽（结果集用尽或未调用next）'}, {'optionContent': 'B.java.sql.SQLException: No suitable driver（URL拼写错误）', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'java.sql.SQLException: No suitable driver（URL拼写错误）'}, {'optionContent': ""C.java.sql.SQLException: Unknown column 'sid' in 'field list' （SQL语句表名错误）"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""java.sql.SQLException: Unknown column 'sid' in 'field list' （SQL语句表名错误）""}, {'optionContent': ""D.java.sql.SQLException: Data too long for column 'id' at row 1（列名定义过长）"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""java.sql.SQLException: Data too long for column 'id' at row 1（列名定义过长）""}]",C选项是列名错误 D选项是列值过长 AB选项正确,"A,B"
(多选题)JDBC编程的异常类型分为（ ）,"[{'optionContent': 'A.SQLException', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'SQLException'}, {'optionContent': 'B.SQLWarning', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'SQLWarning'}, {'optionContent': 'C.SQLTruncation', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'SQLTruncation'}, {'optionContent': 'D.SQLError', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'SQLError'}]",JDBC编程的异常类型分为SQL警告和SQL异常。 选项AB正确。,"A,B"
(单选题)下面关于数据库事务的描述错误的是（ ）,"[{'optionContent': 'A.原子性是事务具备的一个重要特性', 'isCorrect': '-1', 'option': 'A', 'optionValue': '原子性是事务具备的一个重要特性'}, {'optionContent': 'B.Connection对象setAutoCommit(boolean b) 方法默认设置为true', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Connection对象setAutoCommit(boolean b) 方法默认设置为true'}, {'optionContent': 'C.事务回滚会回滚这次事务中的所有修改操作，并释放当前连接所持有的数据库锁', 'isCorrect': '-1', 'option': 'C', 'optionValue': '事务回滚会回滚这次事务中的所有修改操作，并释放当前连接所持有的数据库锁'}, {'optionContent': 'D.事务的三大特性分别是：原子性、隔离性、一致性', 'isCorrect': '-1', 'option': 'D', 'optionValue': '事务的三大特性分别是：原子性、隔离性、一致性'}]","事务有四大特性
分别是：原子性、隔离性、一致性、持久性",D
"(单选题)下面代码空白处应该填入的是（ ）
public void tstAuto() throws Exception {
  Class.forName(""com.mysql.jdbc.Driver"");
  Connection con = 
    DriverManager.getConnection(""jdbc:mysql://localhost:3306/test"", ""root"", ""root"");
  con.setAutoCommit(false);
  PreparedStatement stmt = con.prepareStatement(""insert into emp(name, hire_date, dept_id) values(?,?,?)"");
  ... ... ...
  stmt.executeUpdate();
  // 获取刚刚产生的主键 < 填入代码 >
  ... ... ...
  stmt.close();
  con.close();
}","[{'optionContent': 'A.ResultSet key = stmt.getKeys();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'ResultSet key = stmt.getKeys();'}, {'optionContent': 'B.int key = stmt.getGeneratedKeys();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'int key = stmt.getGeneratedKeys();'}, {'optionContent': 'C.ResultSet key = stmt.getGeneratedKeys();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'ResultSet key = stmt.getGeneratedKeys();'}, {'optionContent': 'D.int key = stmt.getKeys();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'int key = stmt.getKeys();'}]","通过getGeneratedKeys()方法获取刚刚插入数据库的记录的自增主键值，
返回的结果是ResultSet类型的结果集。",C
(单选题)下面的代码用于实现对emp表的分页查询（Oracle），在每页10行的前提下查询第8页的语句是（ ）,"[{'optionContent': 'A.String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();'}, {'optionContent': 'B.String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();'}, {'optionContent': 'C.String sql = ""select ename, sal from emp (select ename, sal, rownum n from emp where rownum>=?) where n<?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1);\nstmt.setInt(2,10*7+1+10);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'String sql = ""select ename, sal from emp (select ename, sal, rownum n from emp where rownum>=?) where n<?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1);\nstmt.setInt(2,10*7+1+10);\nstmt.executeQuery();'}, {'optionContent': 'D.String sql = ""select ename, sal from (select ename, sal, rownum n from emp where rownum<?) where n>=?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'String sql = ""select ename, sal from (select ename, sal, rownum n from emp where rownum<?) where n>=?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,10*7+1+10);\nstmt.setInt(2,10*7+1);\nstmt.executeQuery();'}]","oracle中没有limit，mysql中分页才使用limit。
oracle中通过rownum分页需要先在子查询中查询小于满足条件的最后一条数据的所有记录，当子查询结果集确定后，再过滤出大于满足条件的起始第一条数据的所有记录。",D
(单选题)下面的代码用于实现对emp表的分页查询（mysql），在每页10行的前提下查询第8页的语句是（ ）,"[{'optionContent': 'A.String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,7*10);\nstmt.setInt(2,10);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,7*10);\nstmt.setInt(2,10);\nstmt.executeQuery();'}, {'optionContent': 'B.String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,7*10);\nstmt.setInt(2,10);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,7*10);\nstmt.setInt(2,10);\nstmt.executeQuery();'}, {'optionContent': 'C.String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,8*10);\nstmt.setInt(2,10);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'String sql = ""select ename,sal from emp where limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,8*10);\nstmt.setInt(2,10);\nstmt.executeQuery();'}, {'optionContent': 'D.String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,8*10);\nstmt.setInt(2,10);\nstmt.executeQuery();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'String sql = ""select ename,sal from emp limit ?,?"";\nPreparedStatement stmt = con.prepareStatement(sql);\nstmt.setInt(1,8*10);\nstmt.setInt(2,10);\nstmt.executeQuery();'}]","mysql分页需要使用limit
第一个参数是从第几条数据开始查寻
第二个参数是查询多少条数据
数据从0开始计数 即第一条数据为第0个
且语法中查询分页时不需要where关键字
所以B正确",B
(单选题)如果一个HTML文档内含有阿拉伯文，则应该？,"[{'optionContent': 'A.使用utf-8编码', 'isCorrect': '-1', 'option': 'A', 'optionValue': '使用utf-8编码'}, {'optionContent': 'B.将阿拉伯文转为图片并嵌入到文档内', 'isCorrect': '-1', 'option': 'B', 'optionValue': '将阿拉伯文转为图片并嵌入到文档内'}, {'optionContent': 'C.使用GBK编码', 'isCorrect': '-1', 'option': 'C', 'optionValue': '使用GBK编码'}, {'optionContent': 'D.使用iso-8859-2编码', 'isCorrect': '-1', 'option': 'D', 'optionValue': '使用iso-8859-2编码'}]",A。UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。UTF-8用1到6个字节编码UNICODE字符。用在网页上可以同一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。,A
(单选题)以下关于HTML文档的说法正确的是（）,"[{'optionContent': 'A.HTML是一种动态网页设计语言', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'HTML是一种动态网页设计语言'}, {'optionContent': 'B.HTML文档是编译执行的', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'HTML文档是编译执行的'}, {'optionContent': 'C.HTML是一种超文本标记语言', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'HTML是一种超文本标记语言'}, {'optionContent': 'D.HTML文档中用户可以使用自定义标记', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'HTML文档中用户可以使用自定义标记'}]",HTML 语言是一种脚本语言，不需要编译可直接在浏览器上解释并运行。它是一种超文本标记协议。标签已定，不可自定义,C
(单选题)选出你认为最合理的定义标题的方法。,"[{'optionContent': 'A.<span class=”heading”>文章标题</span>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<span class=”heading”>文章标题</span>'}, {'optionContent': 'B.<p><b>文章标题</b></p>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<p><b>文章标题</b></p>'}, {'optionContent': 'C.<h1>文章标题</h1>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<h1>文章标题</h1>'}, {'optionContent': 'D.<strong>文章标题</strong>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<strong>文章标题</strong>'}]",A是添加了一个类 B是用加粗 C使用标签h1 D是强调,C
(单选题)meta标签可以出现在 () 中,"[{'optionContent': 'A.<head>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<head>'}, {'optionContent': 'B.<body>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<body>'}, {'optionContent': 'C.<title>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<title>'}, {'optionContent': 'D.<link>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<link>'}]",head标签可以包含，title、meta、link、script 等,A
(单选题)通常我们在浏览器内容区看到的内容，都是放入在 () 之间,"[{'optionContent': 'A.<!doctype html>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<!doctype html>'}, {'optionContent': 'B.<html></html>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<html></html>'}, {'optionContent': 'C.<head></head>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<head></head>'}, {'optionContent': 'D.<body></body>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<body></body>'}]",A答案是声明文档类型。 B答案是整个html文件。 C答案是网页标题，在浏览器顶部显示、 D答案是网页的主体部分，即浏览器的内容区域。,D
(单选题)在html规范描述中，哪个是head标签部分里必不可少的元素（ ）,"[{'optionContent': 'A.<meta>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<meta>'}, {'optionContent': 'B.<link>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<link>'}, {'optionContent': 'C.<title>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<title>'}, {'optionContent': 'D.<script>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<script>'}]","下面这些标签可用在 head 部分：,, ,",C
(单选题)在HTML文档中，引用外部样式表的正确位置是？,"[{'optionContent': 'A.文档的末尾', 'isCorrect': '-1', 'option': 'A', 'optionValue': '文档的末尾'}, {'optionContent': 'B.文档的顶部', 'isCorrect': '-1', 'option': 'B', 'optionValue': '文档的顶部'}, {'optionContent': 'C.<body>部分', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<body>部分'}, {'optionContent': 'D.<head>部分', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<head>部分'}]",里存储外部样式,D
(多选题)一份HTML文档有哪几个必须的HTML标签？,"[{'optionContent': 'A.<html>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<html>'}, {'optionContent': 'B.<head>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<head>'}, {'optionContent': 'C.<input>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<input>'}, {'optionContent': 'D.<body>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<body>'}]",这里说的是html文档的结构标准、规范，html、head、body是一个html文档中必须的标签,"A,B,D"
(单选题)默认情况下，使用h1标签会形成什么效果?,"[{'optionContent': 'A.加粗、斜体', 'isCorrect': '-1', 'option': 'A', 'optionValue': '加粗、斜体'}, {'optionContent': 'B.加粗、大号文字', 'isCorrect': '-1', 'option': 'B', 'optionValue': '加粗、大号文字'}, {'optionContent': 'C.正常粗细、正常大小文字', 'isCorrect': '-1', 'option': 'C', 'optionValue': '正常粗细、正常大小文字'}, {'optionContent': 'D.正常粗细、大号文字', 'isCorrect': '-1', 'option': 'D', 'optionValue': '正常粗细、大号文字'}]",加粗、大号文字,B
(单选题)请选择产生粗体字的 HTML 标签：,"[{'optionContent': 'A.<bold>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<bold>'}, {'optionContent': 'B.<bb>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<bb>'}, {'optionContent': 'C.<b>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<b>'}, {'optionContent': 'D.<bld>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<bld>'}]","html语言中加粗的标签有<b>和<strong>,或者使用css设置｛font-weight:bold｝",C
(多选题)下面说法正确的有（）,"[{'optionContent': 'A.P元素不能包含div', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'P元素不能包含div'}, {'optionContent': 'B.Li元素的祖先元素可能是li，但父元素不可能是li', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Li元素的祖先元素可能是li，但父元素不可能是li'}, {'optionContent': 'C.Domtree的根节点是body元素', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Domtree的根节点是body元素'}, {'optionContent': 'D.Body内的元素的offsetparent一定存在', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Body内的元素的offsetparent一定存在'}]","1.p元素内部只能嵌套行内元素，不能嵌套块级元素。A说法正确；
2.li标签可以嵌套<ul><li></li></ul>,但是li标签必须嵌套在ul、ol标签里面。B说法正确；
3.所有元素的根节点都是html元素。C说法错误；
4.offsetparent是相对的意思，Body内的元素，不论怎么嵌套，offsetparent都是一定存在。D说法正确；","A,B,D"
(多选题)下列哪些元素是块级元素：,"[{'optionContent': 'A.div', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'div'}, {'optionContent': 'B.h1', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'h1'}, {'optionContent': 'C.button', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'button'}, {'optionContent': 'D.ul', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'ul'}]",块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote,"A,B,D"
(多选题)下列哪些元素是行内元素：,"[{'optionContent': 'A.span', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'span'}, {'optionContent': 'B.img', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'img'}, {'optionContent': 'C.div', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'div'}, {'optionContent': 'D.p', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'p'}]",行内元素有：a、b、span、img、input、strong、select、label、em、button、textarea,"A,B"
(单选题)下面哪一个标符可以产生一个表行？,"[{'optionContent': 'A.<HR>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<HR>'}, {'optionContent': 'B.<BR>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<BR>'}, {'optionContent': 'C.<TR>\n', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<TR>\n'}, {'optionContent': 'D.<T1>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<T1>'}]",<HR> ：表示一条横线    <BR> :可插入一个简单的换行符   <TR>产生一个表行,C
(单选题)请选出错误的标签,"[{'optionContent': 'A.<p>段落</p>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<p>段落</p>'}, {'optionContent': 'B.<h1>标题</h1>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<h1>标题</h1>'}, {'optionContent': 'C.<blockquote>引用内容</blockquote>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<blockquote>引用内容</blockquote>'}, {'optionContent': 'D.<img src=”http://www.nowcoder.com/”></img>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<img src=”http://www.nowcoder.com/”></img>'}]",img标签不用成对出现,D
(单选题)下面哪一个标符可以产生一个水平线？,"[{'optionContent': 'A.<HR>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<HR>'}, {'optionContent': 'B.<BR>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<BR>'}, {'optionContent': 'C.<TR>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<TR>'}, {'optionContent': 'D.<T1>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<T1>'}]",<HR> ：表示一条横线    <BR> :可插入一个简单的换行符   <TR>产生一个表行,A
(单选题)img标签中的alt属性的作用是,"[{'optionContent': 'A.表示图片的名称', 'isCorrect': '-1', 'option': 'A', 'optionValue': '表示图片的名称'}, {'optionContent': 'B.无实际意义，可有可无', 'isCorrect': '-1', 'option': 'B', 'optionValue': '无实际意义，可有可无'}, {'optionContent': 'C.提供替代图片的信息，使屏幕阅读器能获取到关于图片的信息', 'isCorrect': '-1', 'option': 'C', 'optionValue': '提供替代图片的信息，使屏幕阅读器能获取到关于图片的信息'}, {'optionContent': 'D.等比缩放图片大小', 'isCorrect': '-1', 'option': 'D', 'optionValue': '等比缩放图片大小'}]",alt=“ ”里面放图片的描述信息，有时候网络问题图片显示不出来，可以显示该文字信息替代图片,C
(单选题)img标签中src属性表示,"[{'optionContent': 'A.图片存储的地址', 'isCorrect': '-1', 'option': 'A', 'optionValue': '图片存储的地址'}, {'optionContent': 'B.图片的描述', 'isCorrect': '-1', 'option': 'B', 'optionValue': '图片的描述'}, {'optionContent': 'C.图片的名称', 'isCorrect': '-1', 'option': 'C', 'optionValue': '图片的名称'}, {'optionContent': 'D.图片大小', 'isCorrect': '-1', 'option': 'D', 'optionValue': '图片大小'}]",存放图片地址,A
(单选题)下面哪一个是JSON数据？,"[{'optionContent': 'A.｛name:""xiaoming"",age,""student""｝', 'isCorrect': '-1', 'option': 'A', 'optionValue': '｛name:""xiaoming"",age,""student""｝'}, {'optionContent': 'B.｛""name"":""xiaoming"",""age"":""student""｝', 'isCorrect': '-1', 'option': 'B', 'optionValue': '｛""name"":""xiaoming"",""age"":""student""｝'}, {'optionContent': 'C.｛""xiaoming"",""student""｝', 'isCorrect': '-1', 'option': 'C', 'optionValue': '｛""xiaoming"",""student""｝'}, {'optionContent': 'D.[""xiaoming"",""student""]', 'isCorrect': '-1', 'option': 'D', 'optionValue': '[""xiaoming"",""student""]'}]",json中key也是个字符串，要加引号。 key和value之间是用：号连接 即key:value,B
"(单选题)在jQuery中，有以下代码：  
$("".btn"").click(function() {     
	var json = 
		[                  
			{ ""S_Name"": ""周颜"", ""S_Sex"": ""男"" },                 
			{ ""S_Name"": ""周颖"", ""S_Sex"": ""女"" }                
		];      
	$.each(json, function(index, s) { 
		//语句1
		alert(s.S_Name + "","" + s.S_Sex);		    
	}); 
});  
以下说法正确的是（ ）。","[{'optionContent': 'A.此代码不会正常运行', 'isCorrect': '-1', 'option': 'A', 'optionValue': '此代码不会正常运行'}, {'optionContent': 'B.语句1会被执行1次', 'isCorrect': '-1', 'option': 'B', 'optionValue': '语句1会被执行1次'}, {'optionContent': 'C.语句1会被执行2次', 'isCorrect': '-1', 'option': 'C', 'optionValue': '语句1会被执行2次'}, {'optionContent': 'D.$.each()函数的用法有误', 'isCorrect': '-1', 'option': 'D', 'optionValue': '$.each()函数的用法有误'}]",此题目考查的是jQuery函数 代码可以正常运行，$.each函数会对json进行遍历，且语句1会被执行2次 C选项正确,C
(多选题)下面对于 JSON 描述正确是 （ ）,"[{'optionContent': 'A.JSON 使用 JavaScript 语法来描述数据对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'JSON 使用 JavaScript 语法来描述数据对象'}, {'optionContent': 'B.JSON 是轻量级的文本数据交换格式', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'JSON 是轻量级的文本数据交换格式'}, {'optionContent': 'C.JSON 独立于语言、平台', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'JSON 独立于语言、平台'}, {'optionContent': 'D.JSON 具有自我描述性，更易理解', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'JSON 具有自我描述性，更易理解'}]","JSON 是使用 JavaScript 语法来描述数据对象。 它是轻量级的文本数据交换格式，独立于语言和平台,JSON 解析器和 JSON 库支持许多不同的编程语言。 它具有自我描述性。 选项ABCD都正确","A,B,C,D"
"(单选题)HTML代码:
<form>
<label>Name:</label>
<input name=""name""/>
<fieldset>
<label>Newsletter:</label>
<input name=""newsletter""/>
</fieldset>
</form>
<input name=""none""/>
jQuery代码:
$(""form ~ input"")
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<input name=""name""/>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<input name=""name""/>'}, {'optionContent': 'B.<input name=""newsletter""/>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<input name=""newsletter""/>'}, {'optionContent': 'C.<input name=""none""/>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<input name=""none""/>'}, {'optionContent': 'D.<label>Newsletter:</label>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<label>Newsletter:</label>'}]","""form ~ input""选择器是匹配所有与表单 form 同辈的 input 元素。 选项C正确",C
"(单选题)HTML代码:
<input name=""man-news""/>
<input name=""milkman""/>
<input name=""letterman2""/>
<input name=""newmilk""/>
jQuery代码:
$(""input[name*='man']"")
jQuery代码执行后的结果是（ ）","[{'optionContent': 'A.<input name=""man-news""/>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<input name=""man-news""/>'}, {'optionContent': 'B.<input name=""milkman""/>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<input name=""milkman""/>'}, {'optionContent': 'C.<input name=""letterman2""/>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<input name=""letterman2""/>'}, {'optionContent': 'D.<input name=""man-news""/>,<input name=""milkman""/>,<input name=""letterman2""/>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<input name=""man-news""/>,<input name=""milkman""/>,<input name=""letterman2""/>'}]","""[attribute*=value]""选择器表示匹配给定的属性是以包含某些值的元素，其中参数attribute和value都是String类型，value参数可选。 本题中""input[name*='man']""表示匹配所有 name 属性值中包含 'man' 的 input 元素。 选项D正确",D
(单选题)如果需要通过jQuery匹配包含文本的元素，下面哪个选项正确（ ）,"[{'optionContent': 'A.text()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'text()'}, {'optionContent': 'B.contains()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'contains()'}, {'optionContent': 'C.input()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'input()'}, {'optionContent': 'D.attr()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'attr()'}]",contains()： 匹配包含给定文本的元素。 它所传入的参数是一个用以查找的字符串。,B
"(单选题)HTML代码:
<table>
<tr><td>Header 1</td></tr>
<tr><td>Value 1</td></tr>
<tr><td>Value 2</td></tr>
</table>
jQuery代码:$(""tr:first"")
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<tr><td>Header 1</td></tr>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<tr><td>Header 1</td></tr>'}, {'optionContent': 'B.<td>Value 1</td>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<td>Value 1</td>'}, {'optionContent': 'C.<td>Value 2</td>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<td>Value 2</td>'}, {'optionContent': 'D.<td>Header 1</td>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<td>Header 1</td>'}]","""tr:first""选择器是匹配第一个tr元素。 选项A正确",A
"(单选题)HTML代码:
<p>one</p><div><p>two</p></div><p>three</p>
jQuery代码:
$(""div > p"");
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<p>two</p>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<p>two</p>'}, {'optionContent': 'B.<p>one</p>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<p>one</p>'}, {'optionContent': 'C.<p>three</p>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<p>three</p>'}, {'optionContent': 'D.<div><p>two</p></div>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<div><p>two</p></div>'}]","""div > p""是层级选择器，div属于父级选择器，p属于子级选择器， 这道题是匹配div元素下所有的子级p元素。 所以A正确。",A
"(单选题)HTML代码:
<table>
<tr style=""display:none""><td>Value 1</td></tr>
<tr><td>Value 2</td></tr>
</table>
jQuery代码:
$(""tr:hidden"")
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<tr style=""display:none""><td>Value 1</td></tr>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<tr style=""display:none""><td>Value 1</td></tr>'}, {'optionContent': 'B.<tr><td>Value 2</td></tr>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<tr><td>Value 2</td></tr>'}, {'optionContent': 'C.<td>Value 1</td>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<td>Value 1</td>'}, {'optionContent': 'D.<td>Value 2</td>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<td>Value 2</td>'}]",""":hidden""选择器是匹配所有不可见元素，或者type为hidden的元素。 本题中""tr:hidden""表示匹配隐藏的 tr 元素。 选项A正确",A
"(单选题)HTML代码:
<table>
<tr><td>Value 1</td><td></td></tr>
<tr><td>Value 2</td><td></td></tr>
</table>
jQuery代码:
$(""td:empty"")
执行jQuery代码后的结果的（ ）","[{'optionContent': 'A.<td>Value 1</td>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<td>Value 1</td>'}, {'optionContent': 'B.<td></td>,<td></td>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<td></td>,<td></td>'}, {'optionContent': 'C.<td>Value 2</td>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<td>Value 2</td>'}, {'optionContent': 'D.<td></td>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<td></td>'}]",""":empty""选择器是匹配所有不包含子元素或者文本的空元素。 本题中""td:empty""表示匹配所有没有子节点或文本内容的空的 td 元素。 B选项正确。",B
(单选题)下面哪种选择器不属于jQuery的选择器（ ）,"[{'optionContent': 'A.基本选择器', 'isCorrect': '-1', 'option': 'A', 'optionValue': '基本选择器'}, {'optionContent': 'B.过滤选择器', 'isCorrect': '-1', 'option': 'B', 'optionValue': '过滤选择器'}, {'optionContent': 'C.CSS选择器', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'CSS选择器'}, {'optionContent': 'D.HTML选择器', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'HTML选择器'}]",jQuery选择器包括： 1.基本选择器 CSS选择器、层级选择器、表单域选择器 2.过滤选择器 简单过滤选择器、内容过滤选择器、属性过滤选择器、 子元素过滤选择器、表单域属性过滤选择器、可见性过滤选择器,D
"(单选题)HTML代码:
<table>
<tr><td>Header 1</td></tr>
<tr><td>Value 1</td></tr>
<tr><td>Value 2</td></tr>
</table>
jQuery代码:
$(""tr:odd"")
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<tr><td>Value 1</td></tr>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<tr><td>Value 1</td></tr>'}, {'optionContent': 'B.<tr><td>Header 1</td></tr>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<tr><td>Header 1</td></tr>'}, {'optionContent': 'C.<td>Value 1</td>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<td>Value 1</td>'}, {'optionContent': 'D.<tr><td>Value 2</td></tr>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<tr><td>Value 2</td></tr>'}]",""":odd""选择器是匹配所有索引值为奇数的元素， 其中索引值从 0 开始计数。 本题中""tr:odd""表示匹配tr中索引值为奇数的 tr 元素。 选项A正确。",A
"(单选题)HTML代码:
<div>DIV1</div>
<div>DIV2</div>
<span>SPAN</span>
jQuery代码:
$(""div"");
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<div>DIV1</div>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<div>DIV1</div>'}, {'optionContent': 'B.<div>DIV2</div>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<div>DIV2</div>'}, {'optionContent': 'C.<div>DIV1</div>,<div>DIV2</div>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<div>DIV1</div>,<div>DIV2</div>'}, {'optionContent': 'D.DIV1,DIV2', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'DIV1,DIV2'}]","""div""是匹配所有div元素。 D选项返回的是匹配元素的文本内容。 C选项正确。",C
(单选题)下面哪一个是用来将内容追加到指定元素的末尾的（ ）,"[{'optionContent': 'A.insertAfter()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'insertAfter()'}, {'optionContent': 'B.append()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'append()'}, {'optionContent': 'C.appendTo()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'appendTo()'}, {'optionContent': 'D.after()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'after()'}]",jQuery中使用appendTo()方法将指定内容追加到指定元素的末尾。,C
"(单选题)HTML代码:
<div></div>
jQuery代码:
$(""div"").html(""<p>Hello Again</p>"")
执行jQuery代码后的结果是（ ）","[{'optionContent': 'A.<div></div>', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<div></div>'}, {'optionContent': 'B.<div><p>Hello Again</p></div>', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<div><p>Hello Again</p></div>'}, {'optionContent': 'C.<p>Hello Again</p>', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<p>Hello Again</p>'}, {'optionContent': 'D.Hello Again', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Hello Again'}]","""html(val)""表示设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。 本题中""$(""div"").html(""Hello Again"")""表示给 div 元素中一段内容为""Hello Again""的html元素，则返回的应该是 ""Hello Again""。 答案B正确",B
(单选题)在jQuey中，如果想要从DOM中删除所有匹配的元素，下面哪一个是正确的（ ）,"[{'optionContent': 'A.delete()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'delete()'}, {'optionContent': 'B.empty()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'empty()'}, {'optionContent': 'C.remove()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'remove()'}, {'optionContent': 'D.removeAll()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'removeAll()'}]",删除指定元素使用remove()方法，empty()是删除指定元素的子节点， 其他两个都不对,C
(多选题)对于springmvc，说法正确的是（ ）。,"[{'optionContent': 'A.是spring框架一个非常重要的功能模块。', 'isCorrect': '-1', 'option': 'A', 'optionValue': '是spring框架一个非常重要的功能模块。'}, {'optionContent': 'B.实现了MVC结构，便于简单、快速开发MVC结构的Web程序。', 'isCorrect': '-1', 'option': 'B', 'optionValue': '实现了MVC结构，便于简单、快速开发MVC结构的Web程序。'}, {'optionContent': 'C.提供的API封装了Web开发中常用的功能, 简化了Web开发过程。', 'isCorrect': '-1', 'option': 'C', 'optionValue': '提供的API封装了Web开发中常用的功能, 简化了Web开发过程。'}, {'optionContent': 'D.提供了访问数据库的功能。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '提供了访问数据库的功能。'}]",Springmvc是一个mvc框架，主要是实现了核心控制器，并没有实现数据库访问功能。,"A,B,C"
(多选题)以下哪些层属于MVC模式 （）,"[{'optionContent': 'A.模型层', 'isCorrect': '-1', 'option': 'A', 'optionValue': '模型层'}, {'optionContent': 'B.管理层', 'isCorrect': '-1', 'option': 'B', 'optionValue': '管理层'}, {'optionContent': 'C.视图层', 'isCorrect': '-1', 'option': 'C', 'optionValue': '视图层'}, {'optionContent': 'D.数据层', 'isCorrect': '-1', 'option': 'D', 'optionValue': '数据层'}]",MVC包括，视图层，模型层，控制层,"A,C"
(单选题)下面（ ）不属于关系—对象映射的映射信息。,"[{'optionContent': 'A.程序包名到数据库库名的映射', 'isCorrect': '-1', 'option': 'A', 'optionValue': '程序包名到数据库库名的映射'}, {'optionContent': 'B.程序类名到数据库表名的映射', 'isCorrect': '-1', 'option': 'B', 'optionValue': '程序类名到数据库表名的映射'}, {'optionContent': 'C.实体属性名到数据库表字段的映射', 'isCorrect': '-1', 'option': 'C', 'optionValue': '实体属性名到数据库表字段的映射'}, {'optionContent': 'D.实体属性类型到数据库表字段类型的映射', 'isCorrect': '-1', 'option': 'D', 'optionValue': '实体属性类型到数据库表字段类型的映射'}]",映射中并没有“程序包名到数据库库名的映射”这种方式,A
(多选题)下面（ ）不是Hibernate 映射文件中包含的内容。,"[{'optionContent': 'A.数据库连接信息', 'isCorrect': '-1', 'option': 'A', 'optionValue': '数据库连接信息'}, {'optionContent': 'B.Hibernate 属性参数', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Hibernate 属性参数'}, {'optionContent': 'C.主键生成策略', 'isCorrect': '-1', 'option': 'C', 'optionValue': '主键生成策略'}, {'optionContent': 'D.属性数据类型', 'isCorrect': '-1', 'option': 'D', 'optionValue': '属性数据类型'}]",Hibernate映射文件并不包括数据库连接和Hibernate的属性参数,"A,B"
(单选题)如果数据库是mysql，则generator属性值不可以使用（B）。,"[{'optionContent': 'A.native', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'native'}, {'optionContent': 'B.identity', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'identity'}, {'optionContent': 'C.hilo', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'hilo'}, {'optionContent': 'D.sequence', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'sequence'}]","sequence ：生成long, short或者int类型的主键。适用于DB2, PostgreSQL, Oracle, SAP DB, McKoi，Interbase. ",D
(单选题)如果数据库是oracle，则generator属性值不可以使用（）。,"[{'optionContent': 'A.native', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'native'}, {'optionContent': 'B.identity', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'identity'}, {'optionContent': 'C.hilo', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'hilo'}, {'optionContent': 'D.sequence', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'sequence'}]","identity：生成long, short或者int类型的主键。适用于MySQL, MS SQL Server,  Sybase and HypersonicSQL ",B
(单选题)以下哪个 Hibernate 主键生成策略是实现主键按数值顺序递增的（ ）,"[{'optionContent': 'A.increment', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'increment'}, {'optionContent': 'B.identity', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'identity'}, {'optionContent': 'C.sequence', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'sequence'}, {'optionContent': 'D.native', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'native'}]","increment 生成策略：当 Hibernate 准备在数据库表中插入一条新记录时，首先从数据库表中获取当 前主键字段的最大值，然后在最大值基础上加 1，作为当前持久化对象的标识符属性值。这种策略即 increment 生成策略，用其生成的标识符属性的类型可以是 long、short、int 及其封装类的类型 identity 生成策略：在 MS SQL Server、MySQL 和 DB2 等数据库中可以设置表中某一个字段的数值自 动增长，identity 生成策略通过这种方式为当前记录获取主键值的同时为持久化对象赋予标识符属性值。
sequence 生成策略：在 Oracle、DB2 和 PostgreSQL 等数据库中创建一个序列（sequence），然后Hibernate 通过该序列为当前记录获取主键值，进而为持久化对象赋予标识符属性值。
native 生成策略：由 Hibernate 根据所使用的数据库支持能力从 identity、sequence 或者等生成策 略中选择一种。",A
(单选题)increment适用于那些数据库（）,"[{'optionContent': 'A.DB2', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DB2'}, {'optionContent': 'B.mysql', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'mysql'}, {'optionContent': 'C.orcale', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'orcale'}, {'optionContent': 'D.所有数据库', 'isCorrect': '-1', 'option': 'D', 'optionValue': '所有数据库'}]","increment：生成long, short或者int类型的主键，不能在cluster环境下使用。适用于所有数据库 ",D
(多选题)下面关于Hibernate中Session的说法正确的是()。,"[{'optionContent': 'A.Session是轻量级的，可以随意的创建和销毁', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Session是轻量级的，可以随意的创建和销毁'}, {'optionContent': 'B.Session是重量级的，不能随意的创建和销毁', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Session是重量级的，不能随意的创建和销毁'}, {'optionContent': 'C.Session是线程安全的', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Session是线程安全的'}, {'optionContent': 'D.Session不是线程安全的', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Session不是线程安全的'}]",详解见正确选项,"A,D"
(单选题)将某个对象从Session的一级缓存中清除的方法是(  )。,"[{'optionContent': 'A.close()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'close()'}, {'optionContent': 'B.clear()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'clear()'}, {'optionContent': 'C.evict()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'evict()'}, {'optionContent': 'D.flush()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'flush()'}]","close()表示将当前会话连接关闭,断开与数据库的连接
flush()方法是强制将session中的东西刷入到数据库中
clear()是清空一级缓存中所有的对象
evict()是把某一个对象从一级缓存中清除",C
(单选题)由持久化状态向游离状态转变的方法不包括( )。,"[{'optionContent': 'A.临时状态', 'isCorrect': '-1', 'option': 'A', 'optionValue': '临时状态'}, {'optionContent': 'B.无引用状态', 'isCorrect': '-1', 'option': 'B', 'optionValue': '无引用状态'}, {'optionContent': 'C.持久化状态', 'isCorrect': '-1', 'option': 'C', 'optionValue': '持久化状态'}, {'optionContent': 'D.游离状态', 'isCorrect': '-1', 'option': 'D', 'optionValue': '游离状态'}]",仔细看题干,C
(单选题)由持久化状态向游离状态转变的方法不包括( )。,"[{'optionContent': 'A.close()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'close()'}, {'optionContent': 'B.clear()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'clear()'}, {'optionContent': 'C.lock()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'lock()'}, {'optionContent': 'D.evict()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'evict()'}]",lock()是从游离状态变为持久状态,C
"(单选题)对于以下程序，Customer对象在第几行变为游离状态？( )
Session session1=sessionFactory.openSession();  
Transaction tx1 = session1.beginTransaction();  
Customer customer=new Customer();  		        //1
customer.setName(\""Tom\""); 
session1.save(customer);  					//2
tx1.commit();  							        //3
session1.close(); 							//4","[{'optionContent': 'A.第(1)行', 'isCorrect': '-1', 'option': 'A', 'optionValue': '第(1)行'}, {'optionContent': 'B.第(2)行', 'isCorrect': '-1', 'option': 'B', 'optionValue': '第(2)行'}, {'optionContent': 'C.第(3)行', 'isCorrect': '-1', 'option': 'C', 'optionValue': '第(3)行'}, {'optionContent': 'D.第(4)行', 'isCorrect': '-1', 'option': 'D', 'optionValue': '第(4)行'}]",close后又持久状态变为游离状态,D
"(单选题)假设对Customer 类的orders 集合采用延迟检索策略，编译或运行以下程序，会出现（ ）
Session session=sessionFactory.openSession();
Customer customer=(Customer)session.get(Customer.class,new Long(1));
session.close();
Iterator orderIterator=customer.getOrders().iterator();","[{'optionContent': 'A.编译出错', 'isCorrect': '-1', 'option': 'A', 'optionValue': '编译出错'}, {'optionContent': 'B.编译通过，并正常运行', 'isCorrect': '-1', 'option': 'B', 'optionValue': '编译通过，并正常运行'}, {'optionContent': 'C.编译通过，但运行时抛出异常', 'isCorrect': '-1', 'option': 'C', 'optionValue': '编译通过，但运行时抛出异常'}, {'optionContent': 'D.运行时输出“session.open”', 'isCorrect': '-1', 'option': 'D', 'optionValue': '运行时输出“session.open”'}]",编译上没有错误，但会出现运行时异常,C
(多选题)下面关于Hibernate关联映射说法错误的是（）。,"[{'optionContent': 'A. 配置单项多对一关联映射，在配置文件中需要使用<many-to-one>标签', 'isCorrect': '-1', 'option': 'A', 'optionValue': ' 配置单项多对一关联映射，在配置文件中需要使用<many-to-one>标签'}, {'optionContent': 'B.面向对象领域的关联关系可以分为单向一对多或者单向多对一', 'isCorrect': '-1', 'option': 'B', 'optionValue': '面向对象领域的关联关系可以分为单向一对多或者单向多对一'}, {'optionContent': 'C.人和手机号码之间的关系是一对多关系', 'isCorrect': '-1', 'option': 'C', 'optionValue': '人和手机号码之间的关系是一对多关系'}, {'optionContent': 'D.cascade属性描述了级联操作的规则', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'cascade属性描述了级联操作的规则'}]","B选项：面向对象领域的关联关系不是只有单向一对多或者单向多对一还有双向一对多双向多对一，自身双向关联等等，
C选项：人和手机号码之间也可以是多对一，或多对多","B,C"
(单选题)以下不属于Cascade的属性取值的有(   )。,"[{'optionContent': 'A.all', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'all'}, {'optionContent': 'B.save', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'save'}, {'optionContent': 'C.delete', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'delete'}, {'optionContent': 'D.save-update', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'save-update'}]",Cascade的属性取值的有all，none，save-update，delete，all-delete-orphan,B
(单选题)级联删除时，cascade属性是(   )。,"[{'optionContent': 'A.all', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'all'}, {'optionContent': 'B.save', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'save'}, {'optionContent': 'C.delete', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'delete'}, {'optionContent': 'D.save-update', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'save-update'}]","delete：在执行删除时进行关联操作。 
",C
(单选题)从性能考虑，inverse属性值通常设置为(  )。,"[{'optionContent': 'A.all', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'all'}, {'optionContent': 'B.false', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'false'}, {'optionContent': 'C.true', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'true'}, {'optionContent': 'D.None', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'None'}]","""inverse""属性只有两个值""true""和""false""。""true""表示将关系维护的权力交给对方，""false""表示不交出维护权力（默认值）。
属性为false的情况下性能较快",B
"(单选题)下面代码的执行效果是（ ）。
String hql = ""from TblStudent s order by s.score asc"";
Query query = session.createQuery(hql);
query.setFirstResult(0);	
query.setMaxResults(5);
return query.list();","[{'optionContent': 'A.返回分数最高的五个学生', 'isCorrect': '-1', 'option': 'A', 'optionValue': '返回分数最高的五个学生'}, {'optionContent': 'B.返回分数最高的六个学生', 'isCorrect': '-1', 'option': 'B', 'optionValue': '返回分数最高的六个学生'}, {'optionContent': 'C.返回分数最低的五个学生', 'isCorrect': '-1', 'option': 'C', 'optionValue': '返回分数最低的五个学生'}, {'optionContent': 'D.返回分数最低的六个学生', 'isCorrect': '-1', 'option': 'D', 'optionValue': '返回分数最低的六个学生'}]",asc是从小打大，然后传入了2个参数从最低开始取5个,C
"(单选题)下面HQL语句的含义是（ ）。
select stu
from TblStudent stu
where stu.score > ( select avg(score) from TblStudent )","[{'optionContent': 'A.查询所有学生的平均分', 'isCorrect': '-1', 'option': 'A', 'optionValue': '查询所有学生的平均分'}, {'optionContent': 'B.查询得分大于平均分的学生的成绩', 'isCorrect': '-1', 'option': 'B', 'optionValue': '查询得分大于平均分的学生的成绩'}, {'optionContent': 'C.查询得分最高的学生', 'isCorrect': '-1', 'option': 'C', 'optionValue': '查询得分最高的学生'}, {'optionContent': 'D.查询得分大于平均分的学生', 'isCorrect': '-1', 'option': 'D', 'optionValue': '查询得分大于平均分的学生'}]",avg是求平均数，stu.score > ( select avg(score) from TblStudent )就是求大于平均分的学生,D
(单选题)已知系统中TBL_USER 表对应的实体类是TblUser，下列HQL 语句中正确的是（ ）。,"[{'optionContent': 'A.from Tbl_User', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'from Tbl_User'}, {'optionContent': 'B.select * from tbluser', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select * from tbluser'}, {'optionContent': 'C.select TblUser from TblUser', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select TblUser from TblUser'}, {'optionContent': 'D.from TblUser t where t.age= 15', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'from TblUser t where t.age= 15'}]",ABC都是语法错误,D
(单选题)下面代码能够返回房屋表中第51行数据后的20 行数据的是（ ）。,"[{'optionContent': 'A.Criteria criteria = session.createCriteria(House.class);\nCriteria.setFirstResult(51);\nList result = criteria.list();', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Criteria criteria = session.createCriteria(House.class);\nCriteria.setFirstResult(51);\nList result = criteria.list();'}, {'optionContent': 'B.Criteria criteria = session.createCriteria(House.class);\ncriteria.setFirstResult(51);\ncriteria.setMaxResult(20);\nList result = criteria.list();', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Criteria criteria = session.createCriteria(House.class);\ncriteria.setFirstResult(51);\ncriteria.setMaxResult(20);\nList result = criteria.list();'}, {'optionContent': 'C.Criteria criteria = session.createCriteria(House.class);\ncriteria.setMaxResult(20);\nList result = criteria.list();', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Criteria criteria = session.createCriteria(House.class);\ncriteria.setMaxResult(20);\nList result = criteria.list();'}, {'optionContent': 'D.Criteria criteria = session.createCriteria(House.class);\ncriteria.setFirst(51);\ncriteria.setMax(20);\nList result = criteria.list();', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Criteria criteria = session.createCriteria(House.class);\ncriteria.setFirst(51);\ncriteria.setMax(20);\nList result = criteria.list();'}]",setFirstResult从第几行开始setMaxResult取多少条数据，估选B,B
(单选题)setMaxResult(3)方法中，参数值3是指( )。,"[{'optionContent': 'A.从第3条记录开始', 'isCorrect': '-1', 'option': 'A', 'optionValue': '从第3条记录开始'}, {'optionContent': 'B.从第4条记录开始', 'isCorrect': '-1', 'option': 'B', 'optionValue': '从第4条记录开始'}, {'optionContent': 'C.查询3条记录', 'isCorrect': '-1', 'option': 'C', 'optionValue': '查询3条记录'}, {'optionContent': 'D.查询4条记录', 'isCorrect': '-1', 'option': 'D', 'optionValue': '查询4条记录'}]",setMaxResult方法是查询多少条语句，参数3就代表查询3条,C
"(单选题)与下面代码效果相同的HQL 语句是（ ）。
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.like(""name"",""admin%""));
List result = criteria.list();","[{'optionContent': ""A.from User where name like 'admin%'"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""from User where name like 'admin%'""}, {'optionContent': ""B.from User where name like '%admin%'"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""from User where name like '%admin%'""}, {'optionContent': ""C.from name where Restrictions like 'admin%'"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""from name where Restrictions like 'admin%'""}, {'optionContent': ""D.select u.name from Useras u where u. Restrictions like 'admin%'"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""select u.name from Useras u where u. Restrictions like 'admin%'""}]","仔细看题干Restrictions.like(""name"",""admin%"")是查询name中的admin%",A
(单选题)选出不是Expression方法的选项（）,"[{'optionContent': 'A.eq()', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'eq()'}, {'optionContent': 'B.gt()', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'gt()'}, {'optionContent': 'C.like()', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'like()'}, {'optionContent': 'D.isNULL()', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'isNULL()'}]","Expression中的方法有：
Expression.gt：对应SQL条件中的""field > value ""。如：Expression.gt(""salary"", new Integer(5000))
Expression.ge：对应SQL条件中的""field >= value""。
Expression.lt：对应SQL条件中的""field < value""。
Expression.le：对应SQL条件中的""field <= value""。
Expression.between：对应SQL条件中的""between""。
Expression.like：对应SQL条件中的""field like value""。
Expression.in：对应SQL条件中的""field in …""。
Expression.eqProperty：用于比较两个属性之间的值，对应SQL条件中的""field = field""。如：Expression.eqProperty(""Employee.id"", ""Group.eid"");
Expression.gtProperty：用于比较两个属性之间的值，对应SQL条件中的""field > field""。
Expression.geProperty：用于比较两个属性之间的值，对应SQL条件中的""field >= field""。
Expression.ltProperty：用于比较两个属性之间的值，对应SQL条件中的""field < field""。
Expression.leProperty：用于比较两个属性之间的值，对应SQL条件中的""field <= field""。
Expression.and：and关系组合。",D
"(单选题)执行下面代码返回的结果为（ ）。
Criteria criteria = session.createCriteria(User.class);
criteria.addOrder(Order.desc(""id""));
List result = criteria.list();","[{'optionContent': 'A.以id降序排列的User对象列表', 'isCorrect': '-1', 'option': 'A', 'optionValue': '以id降序排列的User对象列表'}, {'optionContent': 'B.以id升序排列的User对象列表', 'isCorrect': '-1', 'option': 'B', 'optionValue': '以id升序排列的User对象列表'}, {'optionContent': 'C.返回Order为id的User对象的列表', 'isCorrect': '-1', 'option': 'C', 'optionValue': '返回Order为id的User对象的列表'}, {'optionContent': 'D.不返回对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '不返回对象'}]",desc是降序,A
(单选题)不属于Struts 2表单标签库的是（）,"[{'optionContent': 'A.<s: textfield > ', 'isCorrect': '-1', 'option': 'A', 'optionValue': '<s: textfield > '}, {'optionContent': 'B.<s: textarea >', 'isCorrect': '-1', 'option': 'B', 'optionValue': '<s: textarea >'}, {'optionContent': 'C.<s: submit >   ', 'isCorrect': '-1', 'option': 'C', 'optionValue': '<s: submit >   '}, {'optionContent': 'D.<select>', 'isCorrect': '-1', 'option': 'D', 'optionValue': '<select>'}]",<select>标签属于HTML,D
(单选题)Struts 框架可以支持以下哪种程序开发语言（ ）,"[{'optionContent': 'A. C', 'isCorrect': '-1', 'option': 'A', 'optionValue': ' C'}, {'optionContent': 'B.C++', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'C++'}, {'optionContent': 'C.JAVA', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'JAVA'}, {'optionContent': 'D.C#', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'C#'}]",Struts 是Apache软件基金会（ASF）赞助的一个开源项目。它最初是Jakarta项目中的一个子项目，并在2004年3月成为ASF的顶级项目。它通过采用JavaServlet/JSP技术，实现了基于Java EEWeb应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。,C
(单选题)关于struts框架，下面那些说法是正确的？,"[{'optionContent': 'A.Struts中无法完成上传功能', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'Struts中无法完成上传功能'}, {'optionContent': 'B.Struts框架基于MVC模式', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'Struts框架基于MVC模式'}, {'optionContent': 'C.Struts框架容易引起流程复杂、结构不清晰等问题', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'Struts框架容易引起流程复杂、结构不清晰等问题'}, {'optionContent': 'D.Struts可以有效地降低项目的类文件数目', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'Struts可以有效地降低项目的类文件数目'}]","答案：B
A，struts可以进行文件上传
B，struts基于MVC模式，MVC是模型，视图，控制器，是一种设计模式
C，struts框架让流程结构更清晰
D，struts需要很多 action类，会增加类文件数目",B
(单选题)struts提供了Action接口定义了5个标准字符串常量，不包括的有（  ） ,"[{'optionContent': 'A.SUCCESS', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'SUCCESS'}, {'optionContent': 'B.NONE', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'NONE'}, {'optionContent': 'C.REG', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'REG'}, {'optionContent': 'D.LOGIN ', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'LOGIN '}]",action接口的五个字符串常量分别是：ERROR，NONE，INPUT，LOGIN，SUCCES,C
(单选题)下面关于spring mvc 和struts2的描述，错误的是？,"[{'optionContent': 'A.spring mvc的入口是filter，而struts2是servlet', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'spring mvc的入口是filter，而struts2是servlet'}, {'optionContent': 'B.spring mvc是基于方法的设计，而struts2是基于类的设计', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'spring mvc是基于方法的设计，而struts2是基于类的设计'}, {'optionContent': 'C.struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式'}, {'optionContent': 'D.spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的'}]","spring MVC与struts2的区别:1. 机制: spring  mvc的入口是 servlet,而struts2是filter,这样就导致了二者的机制不同。",A
(单选题)不同的线程在调用Action时创建几个Action实例（）,"[{'optionContent': 'A.1个', 'isCorrect': '-1', 'option': 'A', 'optionValue': '1个'}, {'optionContent': 'B.2个', 'isCorrect': '-1', 'option': 'B', 'optionValue': '2个'}, {'optionContent': 'C.每个线程创建1个', 'isCorrect': '-1', 'option': 'C', 'optionValue': '每个线程创建1个'}, {'optionContent': 'D.可以自定义配置。', 'isCorrect': '-1', 'option': 'D', 'optionValue': '可以自定义配置。'}]",在线程调用action时，每一个线程调用都会重新创建一个action,C
(多选题)下面属性中，哪些是action的属性（）,"[{'optionContent': 'A.path', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'path'}, {'optionContent': 'B.type', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'type'}, {'optionContent': 'C.name', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'name'}, {'optionContent': 'D.validate', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'validate'}]","path属性：指定请求访问Action的路径  
type属性：指定Action的完整类名   
name属性：指定需要传递给Action的ActionForm Bean  
scope属性：指定ActionForm Bean的存放范围  
validate属性：指定是否执行表单验证   
input属性：指定当表单验证失败时的转发路径。
综上，ABCD都对","A,B,C,D"
(多选题)OGNL表达式有什么特点（）,"[{'optionContent': 'A.支持对象方法调用，支持类静态的方法调用和值访问', 'isCorrect': '-1', 'option': 'A', 'optionValue': '支持对象方法调用，支持类静态的方法调用和值访问'}, {'optionContent': 'B.支持赋值操作和表达式串联', 'isCorrect': '-1', 'option': 'B', 'optionValue': '支持赋值操作和表达式串联'}, {'optionContent': 'C.访问OGNL上下文（OGNL context）和ActionContext；', 'isCorrect': '-1', 'option': 'C', 'optionValue': '访问OGNL上下文（OGNL context）和ActionContext；'}, {'optionContent': 'D.操作集合对象', 'isCorrect': '-1', 'option': 'D', 'optionValue': '操作集合对象'}]","OGNL（Object-Graph Navigation Language），大概可以理解为：对象图形化导航语言。是一种可以方便地操作对象属性的开源表达式语言。OGNL有如下特点：
1、支持对象方法调用，形式如：objName.methodName()；
2、支持类静态的方法调用和值访问，表达式的格式为@[类全名（包括包路）]@[方法名 |  值名]，例如：
@java.lang.String@format(‘foo %s’, ‘bar’)或@tutorial.MyConstant@APP_NAME；
3、支持赋值操作和表达式串联，例如：
price=100, discount=0.8, calculatePrice()，这个表达式会返回80；
4、访问OGNL上下文（OGNL context）和ActionContext；
5、操作集合对象。","A,B,C,D"
(单选题)数据库DB，数据库系统DBS，和数据库管理系统DBMS三者之间的关系是（）,"[{'optionContent': 'A.DBS包含DB和DBMS', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'DBS包含DB和DBMS'}, {'optionContent': 'B.DBMS包含DB和DBS', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'DBMS包含DB和DBS'}, {'optionContent': 'C.DB包含DBS和DBMS', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'DB包含DBS和DBMS'}, {'optionContent': 'D.DBS就是DB,也就是DBMS', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'DBS就是DB,也就是DBMS'}]",此题目考查的是 DBS包含DB和DBMS DBS（DataBase System）：数据库系统，是采用了数据库技术的计算机系统，是一个实际可运行的、按照数据库方法存储、维护和向应用系统提供数据支持的系统，它是数据库、硬件和软件，以及数据库管理员的集合体。 DB（DataBase）: 数据库，数据库实际上就是一个文件集合，本质就是一个文件系统，数据按照特定的格式存储到文件中，使用sql语言对数据进行增删改查操作。 DBMS（DataBase Management System）：数据库管理系统，是指数据库系统中对数据进行管理的软件系统，用于建立，使用和维护数据库，对数据进行统一的管理和控制，用户通过DBMS访问数据库中的数据。 选项A正确。,A
(单选题)已知一张表中的'姓名'列被定义为name varchar(10)，则以下说法正确的是（）,"[{'optionContent': 'A.也可以定义为char(10)，二者没有区别', 'isCorrect': '-1', 'option': 'A', 'optionValue': '也可以定义为char(10)，二者没有区别'}, {'optionContent': 'B.如果存放中文字符最多可以存放5个', 'isCorrect': '-1', 'option': 'B', 'optionValue': '如果存放中文字符最多可以存放5个'}, {'optionContent': 'C.如果存放中文字符最多可以存放10个', 'isCorrect': '-1', 'option': 'C', 'optionValue': '如果存放中文字符最多可以存放10个'}, {'optionContent': 'D.如果输入字符长度短于10字节时用空白字符填满', 'isCorrect': '-1', 'option': 'D', 'optionValue': '如果输入字符长度短于10字节时用空白字符填满'}]",此题目考查的是 数据库数据类型--字符串 char(m): m代表显示长度，长度不可变 varchar(m): 长度是可变的 一个中文占两个字节 不是必须插入5个中文或10个英文 选项B正确。,B
(单选题)以下能够删除一列的是（）,"[{'optionContent': 'A.alter table tableName remove columnName;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'alter table tableName remove columnName;'}, {'optionContent': 'B.alter table tableName drop columnName;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'alter table tableName drop columnName;'}, {'optionContent': 'C.alter table tableName from columnName;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'alter table tableName from columnName;'}, {'optionContent': 'D.alter table tableName delete columnName;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'alter table tableName delete columnName;'}]",此题目考查的是 DDL 数据定义语言， 表的修改 删除表的字段 格式为: alter table 表名 drop 字段名; 选项B正确。,B
"(单选题)已知表
student(
  sname varchar(20), --'学生姓名'
  cname varchar(20), --'课程名'
  grade int --'成绩'
)
则下列（）选项是正确的。","[{'optionContent': ""A.insert into student values('张三',98,'数学');"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""insert into student values('张三',98,'数学');""}, {'optionContent': ""B.insert into student values('张三','数学',98);"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""insert into student values('张三','数学',98);""}, {'optionContent': ""C.insert into student values('张三',98,数学);"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""insert into student values('张三',98,数学);""}, {'optionContent': ""D.insert into student values('张三',数学,98);"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""insert into student values('张三',数学,98);""}]","此题目考查的是 DML 数据操作语言 插入数据 全表插入: 要求插入的数据的数量、顺序要和表字段的数量、顺序一致 格式: insert into 表名 values(值1,值2,值3,...); 选项B正确。",B
"(单选题)已知商品表
t_item(
  title varchar(20), --'商品名称'
  price double --'单价'
)
查询商品名中第二个字是""赠""字的商品及价格，则下列选项正确的是（）","[{'optionContent': ""A.select title,price from t_item where title like '_赠%';"", 'isCorrect': '-1', 'option': 'A', 'optionValue': ""select title,price from t_item where title like '_赠%';""}, {'optionContent': ""B.select title,price from t_item where title like '__赠%';"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""select title,price from t_item where title like '__赠%';""}, {'optionContent': ""C.select title,price from t_item where title like '赠_%';"", 'isCorrect': '-1', 'option': 'C', 'optionValue': ""select title,price from t_item where title like '赠_%';""}, {'optionContent': ""D.select title,price from t_item where title like '%赠_';"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""select title,price from t_item where title like '%赠_';""}]",此题目考查的是 like _:代表单个未知字符 %:代表多个未知字符 举例: 以a开头 a% 以a结尾 %a 第二个字符是a _a% 包含a %a% 倒数第三个字符是a %a__ 第二个和最后一个是a _a%a 选项A正确。,A
"(单选题)查询person表中，年龄(age)是25,28,30,22岁的所有信息（）","[{'optionContent': 'A.select * from person having age=(25,28,30,22);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select * from person having age=(25,28,30,22);'}, {'optionContent': 'B.select * from person where age=(25,28,30,22);', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select * from person where age=(25,28,30,22);'}, {'optionContent': 'C.select * from person where age in(25,28,30,22);', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select * from person where age in(25,28,30,22);'}, {'optionContent': 'D.select * from person haveing age in(25,28,30,22);', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select * from person haveing age in(25,28,30,22);'}]",此题目考查的是 where子句（in）查询 查询字段的值为多个的时候可以使用in关键字 选项C正确。,C
(单选题)select语句中的条件，年龄between 22 and 26，表示年龄在22至26之间，且（）,"[{'optionContent': 'A.包括22岁和26岁', 'isCorrect': '-1', 'option': 'A', 'optionValue': '包括22岁和26岁'}, {'optionContent': 'B.不包括22岁和26岁', 'isCorrect': '-1', 'option': 'B', 'optionValue': '不包括22岁和26岁'}, {'optionContent': 'C.包括22岁但不包括26岁', 'isCorrect': '-1', 'option': 'C', 'optionValue': '包括22岁但不包括26岁'}, {'optionContent': 'D.包括26岁但不包括22岁', 'isCorrect': '-1', 'option': 'D', 'optionValue': '包括26岁但不包括22岁'}]","此题目考查的是 between...and... 在某两个数值之间, 包含and两边的数值 选项A正确。",A
"(多选题)已知商品表
t_item(
  title varchar(20), --'商品名称'
  price double --'单价'
)
查询表中所有商品，要求按单价升序进行排序，每页显示3条数据，且显示第三页的数据，则下列选项正确的是（）","[{'optionContent': 'A.select title,price from t_item order by price desc limit 3,6;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select title,price from t_item order by price desc limit 3,6;'}, {'optionContent': 'B.select title,price from t_item order by price limit 3,6;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select title,price from t_item order by price limit 3,6;'}, {'optionContent': 'C.select title,price from t_item order by price limit 6,3;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select title,price from t_item order by price limit 6,3;'}, {'optionContent': 'D.select title,price from t_item order by price asc limit 6,3;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select title,price from t_item order by price asc limit 6,3;'}]","此题目考查的是 ---limit 分页查询 limit 跳过条数,查询条数 ---排序 order by 格式: order by 字段名 默认升序, 指定升序是:asc 降序:desc 选项CD正确。","C,D"
(单选题)已知员工表（emp），请查询出每个员工的姓名（name）和工资（sal），同时要求工资后面显示元，例如，8888元，正确的是（）,"[{'optionContent': 'A.select name,sal(元) from emp;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select name,sal(元) from emp;'}, {'optionContent': ""B.select name,concat(sal,'元') from emp;"", 'isCorrect': '-1', 'option': 'B', 'optionValue': ""select name,concat(sal,'元') from emp;""}, {'optionContent': 'C.select name,sal 元 from emp;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select name,sal 元 from emp;'}, {'optionContent': ""D.select name,concat('sal','元') from emp;"", 'isCorrect': '-1', 'option': 'D', 'optionValue': ""select name,concat('sal','元') from emp;""}]","此题目考查的是 字符串拼接函数 concat(a,b) 将a与b进行拼接，如果a为字段，则将a的值与后面的b拼接， 如果a为常量值，则直接将常量值与后面的b拼接。 选项B正确。",B
(多选题)已知员工表（emp），现要求把员工表中，没有奖金（bonus）的员工的奖金项修改为零，符合要求的是（）,"[{'optionContent': 'A.update emp set bonus=ifnull(bonus,0);', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'update emp set bonus=ifnull(bonus,0);'}, {'optionContent': 'B.update emp set bonus=ifnull(null,bonus);', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'update emp set bonus=ifnull(null,bonus);'}, {'optionContent': 'C.update emp set bonus=0 where bonus is null;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'update emp set bonus=0 where bonus is null;'}, {'optionContent': 'D.update emp set bonus=0 where bonus=null;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'update emp set bonus=0 where bonus=null;'}]","此题目考查的是 函数 ifnull() 格式: bonus=ifnull(x,y) 判断x是否为null 如果是 bonus=y， 如果不是 bonus=x; 选项AC正确。","A,C"
(多选题)已知员工表（emp），请查询出部门员工工资（sal）的平均值大于2000的部门编号（deptno）以及部门平均工资，以下正确的是（）,"[{'optionContent': 'A.select deptno,avg(sal) a from emp group by deptno having a>2000;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select deptno,avg(sal) a from emp group by deptno having a>2000;'}, {'optionContent': 'B.select deptno,avg(sal) a from emp having a>2000 group by deptno;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select deptno,avg(sal) a from emp having a>2000 group by deptno;'}, {'optionContent': 'C.select deptno,avg(sal) a from emp group by deptno where a>2000;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select deptno,avg(sal) a from emp group by deptno where a>2000;'}, {'optionContent': 'D.select deptno,avg(sal) from emp group by deptno having avg(sal)>2000;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select deptno,avg(sal) from emp group by deptno having avg(sal)>2000;'}]","此题目考查的是 分组查询 group by - 分组查询通常和聚合函数结合使用 - 查询条件中每个xxx 就以xxx作为分组的条件 having 有条件的分组统计 - where后面只能对普通字段进行筛选 - having写在 group by 后面,通常是和group by结合使用,对分组后的查询结果进行过滤 - 普通字段的条件写在where后面,聚合函数条件写在having后面,having写在group by后面 选项AD正确。","A,D"
(多选题)查询出学生表（student）中，数学（math）成绩最高的学生姓名（name），以下正确的是（）,"[{'optionContent': 'A.select name from student where math is (select max(math) from student); ', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select name from student where math is (select max(math) from student); '}, {'optionContent': 'B.select name from student where math (select max(math) from student); ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select name from student where math (select max(math) from student); '}, {'optionContent': 'C.select name from student where math=(select max(math) from student); ', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select name from student where math=(select max(math) from student); '}, {'optionContent': 'D.select name from student where math in (select max(math) from student); ', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select name from student where math in (select max(math) from student); '}]",此题目考查的是 子查询 分析如下: 假如数学最高成绩99 1. 首先查询出数学最高成绩 select max(math) from student; --99 2. 然后查寻数学成绩等于99的学生姓名 select name from student where math=99; 或 select name from student where math in(99); 选项CD正确。,"C,D"
(单选题)已知一家公司可以雇佣多名员工为其进行工作，且每名员工只能与一家公司达成劳务关系，那么从公司的角度出发该公司与旗下员工之间的关系属于以下哪一种（）,"[{'optionContent': 'A.一对多', 'isCorrect': '-1', 'option': 'A', 'optionValue': '一对多'}, {'optionContent': 'B.多对多', 'isCorrect': '-1', 'option': 'B', 'optionValue': '多对多'}, {'optionContent': 'C.一对一', 'isCorrect': '-1', 'option': 'C', 'optionValue': '一对一'}, {'optionContent': 'D.多对一', 'isCorrect': '-1', 'option': 'D', 'optionValue': '多对一'}]","此题目考查的是 表设计之关联关系 一对一: 有两张表A和B,A表中有一条数据对应B表中的一条数据称为一对一关系 一对多: AB两张表中A表中一条数据对应B表中多条数据，并且B表中一条数据对应A表中一条数据，两张表的关系称为一对多或多对一关系 多对多: AB两张表,A表中的一条数据对应B表的多条数据,同时B表的一条数据对应A表的多条数据,这种关系称为多对多关系 选项A正确。",A
"(多选题)数据库中有两张表，员工表emp(id int,ename varchar(10),sal int,deptid int)和部门表dept(id int,dname varchar(10)),员工表和部门表的id是主键自增的，现在想要查询每个员工姓名及所对应的部门名称，下列正确的是（）","[{'optionContent': 'A.select emp.ename,dept.dname from emp,dept where emp.id=dept.deptid;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select emp.ename,dept.dname from emp,dept where emp.id=dept.deptid;'}, {'optionContent': 'B.select e.ename,d.dname from emp e join dept d on e.id=d.deptid;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select e.ename,d.dname from emp e join dept d on e.id=d.deptid;'}, {'optionContent': 'C.select emp.ename,dept.dname from emp,dept where emp.deptid=dept.id;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select emp.ename,dept.dname from emp,dept where emp.deptid=dept.id;'}, {'optionContent': 'D.select e.ename,d.dname from emp e join dept d on e.deptid=d.id;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select e.ename,d.dname from emp e join dept d on e.deptid=d.id;'}]","此题目考查的是 等值连接格式: select * from A,B where A.x=B.x and A.y=abc 内连接格式: select * from A join B on A.x=B.x where A.y=abc 例如:查询教研部的员工姓名 select emp.ename,dept.dname from emp,dept where emp.deptid=dept.id and dept.dname='教研部'; select e.ename,d.dname from emp e join dept d on e.deptid=d.id where d.dname='教研部'; 选项CD正确。","C,D"
"(多选题)数据库中有两张表，员工表emp(id int,ename varchar(10),sal int,deptid int)和部门表dept(id int,dname varchar(10)),现在想要查询所有员工的姓名和其所对应的部门名称，下列正确的是（）","[{'optionContent': 'A.select e.ename,d.dname from emp e left join dept d on e.deptid=d.id;', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'select e.ename,d.dname from emp e left join dept d on e.deptid=d.id;'}, {'optionContent': 'B.select e.ename,d.dname from emp e right join dept d on e.deptid=d.id;', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'select e.ename,d.dname from emp e right join dept d on e.deptid=d.id;'}, {'optionContent': 'C.select ename,dname from emp e right join dept d on e.deptid=d.id;', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'select ename,dname from emp e right join dept d on e.deptid=d.id;'}, {'optionContent': 'D.select ename,dname from emp e left join dept d on e.deptid = d.id;', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select ename,dname from emp e left join dept d on e.deptid = d.id;'}]","此题目考查的是 外连接 基本语法： 左表 left/right join 右表 on 左表.字段=右表.字段； 分类：分为两种 左外连接, 右外连接 left join 左外连接---以join左边表为主表查询所有数据,右边表只查询有关系的数据 right join 右外连接---以join右边表为主表查询所有数据,左边表只查询有关系的数据 选项AD正确。","A,D"
(多选题)下列关于视图说法正确的是（）,"[{'optionContent': 'A.表和视图都是数据库中的对象', 'isCorrect': '-1', 'option': 'A', 'optionValue': '表和视图都是数据库中的对象'}, {'optionContent': 'B.创建视图时名称可以和表名相同', 'isCorrect': '-1', 'option': 'B', 'optionValue': '创建视图时名称可以和表名相同'}, {'optionContent': 'C.视图是一张虚拟的表', 'isCorrect': '-1', 'option': 'C', 'optionValue': '视图是一张虚拟的表'}, {'optionContent': 'D.原表的数据改变时，视图中的数据也会随之改变', 'isCorrect': '-1', 'option': 'D', 'optionValue': '原表的数据改变时，视图中的数据也会随之改变'}]","此题目考查的是 对视图的理解 视图: 数据库中存在多种对象，表和视图都是数据库中的对象,创建视图时名称不能和表名重名,视图实际上是一段sql查询语句的映射,可以理解成视图是一张虚拟的表,表中的数据会随着原表的改变而改变 选项ACD正确。","A,C,D"
(多选题)下列关于索引说法正确的是（）,"[{'optionContent': 'A.索引创建的越多越好', 'isCorrect': '-1', 'option': 'A', 'optionValue': '索引创建的越多越好'}, {'optionContent': 'B.索引创建需谨慎', 'isCorrect': '-1', 'option': 'B', 'optionValue': '索引创建需谨慎'}, {'optionContent': 'C.索引是用来提高查询速度的技术，类似一个目录', 'isCorrect': '-1', 'option': 'C', 'optionValue': '索引是用来提高查询速度的技术，类似一个目录'}, {'optionContent': 'D.无论表中有多少数据，创建索引，就可以提高查询效率', 'isCorrect': '-1', 'option': 'D', 'optionValue': '无论表中有多少数据，创建索引，就可以提高查询效率'}]","此题目考查的是 什么是索引
索引是用来提高查询速度的技术,类似一个目录
索引会占用磁盘空间,所以创建时需谨慎,根据查询需求和表结构来决定创建什么索引
索引需要建立在大量数据的表中,如果数据量不够大,有可能会降低查询效率
选项BC正确。","B,C"
(多选题)约束就是给表字段添加的限制条件，那么关于约束下列说法正确的是（）,"[{'optionContent': 'A.每个表中可以有多个unique约束，但是每个表只能有一个primary key约束', 'isCorrect': '-1', 'option': 'A', 'optionValue': '每个表中可以有多个unique约束，但是每个表只能有一个primary key约束'}, {'optionContent': 'B.unique和primary key约束值都不能为null，值都不能重复 ', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'unique和primary key约束值都不能为null，值都不能重复 '}, {'optionContent': 'C.not null给字段添加非空约束，值不能为null', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'not null给字段添加非空约束，值不能为null'}, {'optionContent': 'D.defautl 给字段设置默认值，当字段不赋值的时候，默认值生效', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'defautl 给字段设置默认值，当字段不赋值的时候，默认值生效'}]","此题目考查的是
约束
非空 not null
- 添加非空约束的字段，值不能为null
唯一 unique
- 添加唯一约束的字段，值不能重复，可以为null
主键约束 primary key
- 添加了主键约束的字段，值不能为null也不能重复
默认约束 default
- 给字段设置默认值，当字段不赋值的时候，默认值生效
选项ACD正确。","A,C,D"
"(单选题)事务是数据库执行逻辑的基本工作单位。如果一个事务执行成功，则全部更新提交；
如果一个事务执行失败，则已做过的更新被恢复原状，好像整个事务从未有过这些更新，这样保持了数据库处于_______状态。","[{'optionContent': 'A.完整性', 'isCorrect': '-1', 'option': 'A', 'optionValue': '完整性'}, {'optionContent': 'B.持久性', 'isCorrect': '-1', 'option': 'B', 'optionValue': '持久性'}, {'optionContent': 'C.一致性', 'isCorrect': '-1', 'option': 'C', 'optionValue': '一致性'}, {'optionContent': 'D.安全性', 'isCorrect': '-1', 'option': 'D', 'optionValue': '安全性'}]",此题目考查的是 事务的四大特性： 1、原子性 事务是数据库执行逻辑的工作单元，事务包括的所有操作，要么都做，要么都不做。 2、一致性 事务执行的结果是使数据库从一个一致性状态变成另一个一致性状态。 一致性与原子性是密切相关的。 3、隔离性 一个事务的执行不能被其他事务干扰。 4、持久性 一个事务一旦提交，它对数据库中数据的改变应该是永久性的。 选项C正确。,C
(单选题)SQL语句分为DDL、DML、DQL、TCL、DCL，以下属于DML的是_______，是否_______事务。,"[{'optionContent': 'A.drop  不支持', 'isCorrect': '-1', 'option': 'A', 'optionValue': 'drop  不支持'}, {'optionContent': 'B.insert 支持', 'isCorrect': '-1', 'option': 'B', 'optionValue': 'insert 支持'}, {'optionContent': 'C.alter  支持', 'isCorrect': '-1', 'option': 'C', 'optionValue': 'alter  支持'}, {'optionContent': 'D.select 不支持', 'isCorrect': '-1', 'option': 'D', 'optionValue': 'select 不支持'}]",此题目考查的是 对SQL语句的分类的了解 DDL 数据定义语言: create drop alter truncate 不支持事务 DML 数据操作语言: insert update delete 支持事务 DQL 数据查询语言: select 不支持事务 TCL 事务控制语言: commit rollback 等 DCL 数据控制语言: 分配用户权限 选项B正确。,B
